/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports,require("@tensorflow/tfjs-core")):"function"==typeof define&&define.amd?define(["exports","@tensorflow/tfjs-core"],e):e((t=t||self).tf=t.tf||{},t.tf)}(this,(function(t,e){"use strict";const n="Add",r="BatchMatMul",i="BatchToSpaceND",a="Cast",s="Concat",o="Conv2D",u="Conv2DBackpropInput",l="Cosh",c="Cumsum",h="RealDiv",p="ExpandDims",d="Floor",f="FloorDiv",g="GatherV2",m="GreaterEqual",y="Identity",v="Maximum",b="Multiply",w="Pack",k="PadV2",S="Reshape",N="Reverse",x="Rsqrt",z="Select",I="Slice",A="Sinh",C="Sigmoid",T="Sqrt",E="SpaceToBatchND",F="SplitV",D="Tile",L="Transpose",_="Unpack",R="UnsortedSegmentSum",O="ZerosLike",M="Step";function B(t){throw new Error(`'${t}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function P(t,e){if(!t)throw new Error("string"==typeof e?e:e())}function $(t,e=[],n=!1){if(null==e&&(e=[]),Array.isArray(t)||q(t)&&!n)for(let r=0;r<t.length;++r)$(t[r],e,n);else e.push(t);return e}function W(t){if(0===t.length)return 1;let e=t[0];for(let n=1;n<t.length;n++)e*=t[n];return e}function U(t,e){if(t===e)return!0;if(null==t||null==e)return!1;if(t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(t[n]!==e[n])return!1;return!0}function j(t){return t%1==0}function V(t,e){return e<=t.length?t:t+" ".repeat(e-t.length)}function K(t,e){const n=e.length;return P((t=null==t?e.map(((t,e)=>e)):[].concat(t)).every((t=>t>=-n&&t<n)),(()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${t}`)),P(t.every((t=>j(t))),(()=>`All values in axis param must be integers but got axis ${t}`)),t.map((t=>t<0?n+t:t))}function q(t){return t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array}function G(t){if("float32"===t||"int32"===t)return 4;if("complex64"===t)return 8;if("bool"===t)return 1;throw new Error(`Unknown dtype ${t}`)}function H(t){return"string"==typeof t||t instanceof String}function J(t){return Array.isArray(t)?J(t[0]):t instanceof Float32Array?"float32":t instanceof Int32Array||t instanceof Uint8Array?"int32":"number"==typeof t?"float32":H(t)?"string":function(t){return"boolean"==typeof t}(t)?"bool":"float32"}function Z(t){return!!(t&&t.constructor&&t.call&&t.apply)}function Y(t){const e=t.length;if(e<2)return[];const n=new Array(e-1);n[e-2]=t[e-1];for(let r=e-3;r>=0;--r)n[r]=n[r+1]*t[r+1];return n}function X(t,e,n,r=!1){const i=new Array;if(1===e.length){const a=e[0]*(r?2:1);for(let e=0;e<a;e++)i[e]=n[t+e]}else{const a=e[0],s=e.slice(1),o=s.reduce(((t,e)=>t*e))*(r?2:1);for(let e=0;e<a;e++)i[e]=X(t+e*o,s,n,r)}return i}function Q(t,e,n=!1){if(0===t.length)return e[0];const r=t.reduce(((t,e)=>t*e))*(n?2:1);if(0===r)return[];if(r!==e.length)throw new Error(`[${t}] does not match the input size ${e.length}${n?" for a complex tensor":""}.`);return X(0,t,e,n)}function tt(t,e){const n=et(t,e);for(let t=0;t<n.length;t++)n[t]=1;return n}function et(t,e){if(null==e||"float32"===e||"complex64"===e)return new Float32Array(t);if("int32"===e)return new Int32Array(t);if("bool"===e)return new Uint8Array(t);throw new Error(`Unknown data type ${e}`)}function nt(t){return t&&t.then&&"function"==typeof t.then}function rt(...t){ot().getBool("IS_TEST")||ot().getBool("PROD")||console.warn(...t)}const it="tfjsflags";class at{constructor(t){this.global=t,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=st,this.populateURLFlags()}setPlatform(t,e){null!=this.platform&&rt(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`),this.platformName=t,this.platform=e}registerFlag(t,e,n){if(this.flagRegistry[t]={evaluationFn:e,setHook:n},null!=this.urlFlags[t]){const e=this.urlFlags[t];rt(`Setting feature override from URL ${t}: ${e}.`),this.set(t,e)}}async getAsync(t){return t in this.flags||(this.flags[t]=await this.evaluateFlag(t)),this.flags[t]}get(t){if(t in this.flags)return this.flags[t];const e=this.evaluateFlag(t);if(nt(e))throw new Error(`Flag ${t} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[t]=e,this.flags[t]}getNumber(t){return this.get(t)}getBool(t){return this.get(t)}getFlags(){return this.flags}get features(){return this.flags}set(t,e){if(null==this.flagRegistry[t])throw new Error(`Cannot set flag ${t} as it has not been registered.`);this.flags[t]=e,null!=this.flagRegistry[t].setHook&&this.flagRegistry[t].setHook(e)}evaluateFlag(t){if(null==this.flagRegistry[t])throw new Error(`Cannot evaluate flag '${t}': no evaluation function found.`);return this.flagRegistry[t].evaluationFn()}setFlags(t){this.flags=Object.assign({},t)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(void 0===this.global||void 0===this.global.location||void 0===this.global.location.search)return;const t=this.getQueryParams(this.global.location.search);if(it in t){t.tfjsflags.split(",").forEach((t=>{const[e,n]=t.split(":");this.urlFlags[e]=function(t,e){if("true"===(e=e.toLowerCase())||"false"===e)return"true"===e;if(""+ +e===e)return+e;throw new Error(`Could not parse value flag value ${e} for flag ${t}.`)}(e,n)}))}}}function st(t){const e={};return t.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,((t,...n)=>(function(t,e,n){t[decodeURIComponent(e)]=decodeURIComponent(n||"")}(e,n[0],n[1]),n.join("=")))),e}function ot(){return lt}let ut,lt=null;function ct(){if(null==ut){let t;if("undefined"!=typeof window)t=window;else if("undefined"!=typeof global)t=global;else if("undefined"!=typeof process)t=process;else{if("undefined"==typeof self)throw new Error("Could not find a global object");t=self}ut=t}return ut}function ht(t,e){const n=function(){const t=ct();return null==t._tfGlobals&&(t._tfGlobals=new Map),t._tfGlobals}();if(n.has(t))return n.get(t);{const r=e();return n.set(t,r),n.get(t)}}const pt=ht("kernelRegistry",(()=>new Map)),dt=ht("gradRegistry",(()=>new Map));function ft(t,e){const n=function(t,e){return`${e}_${t}`}(t,e);return pt.get(n)}function gt(t){return dt.get(t)}function mt(t){const e=pt.entries(),n=[];for(;;){const{done:r,value:i}=e.next();if(r)break;const[a,s]=i,[o]=a.split("_");o===t&&n.push(s)}return n}function yt(t){const{kernelName:e}=t;dt.has(e)&&ot().getBool("DEBUG")&&rt(`Overriding the gradient for '${e}'`),dt.set(e,t)}function vt(t,e){if("string"===e)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(t)&&(t=$(t)),ot().getBool("DEBUG")&&function(t,e){for(let n=0;n<t.length;n++){const r=t[n];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${e} being uploaded contains ${r}.`)}}(t,e),function(t,e){return t instanceof Float32Array&&"float32"===e||t instanceof Int32Array&&"int32"===e||t instanceof Uint8Array&&"bool"===e}(t,e))return t;if(null==e||"float32"===e||"complex64"===e)return new Float32Array(t);if("int32"===e)return new Int32Array(t);if("bool"===e){const e=new Uint8Array(t.length);for(let n=0;n<e.length;++n)0!==Math.round(t[n])&&(e[n]=1);return e}throw new Error(`Unknown data type ${e}`)}function bt(){return ot().platform.now()}function wt(t,e="utf-8"){return e=e||"utf-8",ot().platform.decode(t,e)}class kt{constructor(t,e){this.backendTimer=t,this.logger=e,null==e&&(this.logger=new Nt)}profileKernel(t,e,n){let r;const i=()=>{r=n()};let a;const s=bt();if(this.backendTimer.timerAvailable())a=this.backendTimer.time(i);else{i();for(const t of r)t.dataSync();a=Promise.resolve({kernelMs:bt()-s})}if(ot().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let e=0;e<r.length;e++){const n=r[e];n.data().then((e=>{St(e,n.dtype,t)}))}return{kernelName:t,outputs:r,inputs:e,timeMs:a.then((t=>t.kernelMs)),extraInfo:a.then((t=>null!=t.getExtraProfileInfo?t.getExtraProfileInfo():""))}}logKernelProfile(t){const{kernelName:e,outputs:n,timeMs:r,inputs:i,extraInfo:a}=t;n.forEach((t=>{Promise.all([t.data(),r,a]).then((n=>{this.logger.logKernelProfile(e,t,n[0],n[1],i,n[2])}))}))}}function St(t,e,n){if("float32"!==e)return!1;for(let e=0;e<t.length;e++){const r=t[e];if(isNaN(r)||!isFinite(r))return console.warn(`Found ${r} in the result of '${n}'`),!0}return!1}class Nt{logKernelProfile(t,e,n,r,i,a){const s="number"==typeof r?V(`${r}ms`,9):r.error,o=V(t,25),u=e.rank,l=e.size,c=V(e.shape.toString(),14);let h="";for(const t in i){const n=i[t];if(null!=n){const r=n.shape||e.shape,i=r.length;h+=`${t}: ${i}D ${i>0?r:""} `}}console.log(`%c${o}\t%c${s}\t%c${u}D ${c}\t%c${l}\t%c${h}\t%c${a}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}function xt(t,e,n,r){const i=Y(e),a=function(t,e,n,r){const i=W(e),a=r[r.length-1],s=new Array(a).fill(0),o=e.length,u="complex64"===n?Ct(t):t;if(o>1)for(let t=0;t<i/a;t++){const e=t*a;for(let t=0;t<a;t++)s[t]=Math.max(s[t],zt(u[e+t],0,n).length)}return s}(t,e,n,i),s=e.length,o=At(t,e,n,i,a),u=["Tensor"];return r&&(u.push(`  dtype: ${n}`),u.push(`  rank: ${s}`),u.push(`  shape: [${e}]`),u.push("  values:")),u.push(o.map((t=>"    "+t)).join("\n")),u.join("\n")}function zt(t,e,n){let r;return r=Array.isArray(t)?`${parseFloat(t[0].toFixed(7))} + ${parseFloat(t[1].toFixed(7))}j`:H(t)?`'${t}'`:"bool"===n?It(t):parseFloat(t.toFixed(7)).toString(),V(r,e)}function It(t){return 0===t?"false":"true"}function At(t,e,n,r,i,a=!0){const s="complex64"===n?2:1,o=e[0],u=e.length;if(0===u){if("complex64"===n){return[zt(Ct(t)[0],0,n)]}return"bool"===n?[It(t[0])]:[t[0].toString()]}if(1===u){if(o>20){const e=3*s;let r=Array.from(t.slice(0,e)),a=Array.from(t.slice((o-3)*s,o*s));return"complex64"===n&&(r=Ct(r),a=Ct(a)),["["+r.map(((t,e)=>zt(t,i[e],n))).join(", ")+", ..., "+a.map(((t,e)=>zt(t,i[o-3+e],n))).join(", ")+"]"]}return["["+("complex64"===n?Ct(t):Array.from(t)).map(((t,e)=>zt(t,i[e],n))).join(", ")+"]"]}const l=e.slice(1),c=r.slice(1),h=r[0]*s,p=[];if(o>20){for(let e=0;e<3;e++){const r=e*h,a=r+h;p.push(...At(t.slice(r,a),l,n,c,i,!1))}p.push("...");for(let e=o-3;e<o;e++){const r=e*h,a=r+h;p.push(...At(t.slice(r,a),l,n,c,i,e===o-1))}}else for(let e=0;e<o;e++){const r=e*h,a=r+h;p.push(...At(t.slice(r,a),l,n,c,i,e===o-1))}const d=2===u?",":"";p[0]="["+p[0]+d;for(let t=1;t<p.length-1;t++)p[t]=" "+p[t]+d;let f=",\n";for(let t=2;t<u;t++)f+="\n";return p[p.length-1]=" "+p[p.length-1]+"]"+(a?"":f),p}function Ct(t){const e=[];for(let n=0;n<t.length;n+=2)e.push([t[n],t[n+1]]);return e}let Tt=null,Et=null;class Ft{constructor(t,e,n,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=t.slice(),this.dtype=e||"float32",this.size=W(t),this.strides=Y(t),this.dataId=n,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const t=await this.data();return Et.buffer(this.shape,this.dtype,t)}bufferSync(){return Et.buffer(this.shape,this.dtype,this.dataSync())}async array(){const t=await this.data();return Q(this.shape,t,"complex64"===this.dtype)}arraySync(){return Q(this.shape,this.dataSync(),"complex64"===this.dtype)}async data(){this.throwIfDisposed();const t=Tt().read(this.dataId);if("string"===this.dtype){const e=await t;try{return e.map((t=>wt(t)))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return t}dataSync(){this.throwIfDisposed();const t=Tt().readSync(this.dataId);if("string"===this.dtype)try{return t.map((t=>wt(t)))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return t}async bytes(){this.throwIfDisposed();const t=await Tt().read(this.dataId);return"string"===this.dtype?t:new Uint8Array(t.buffer)}dispose(){this.isDisposed||(Tt().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(t=!1){return Et.print(this,t)}clone(){return this.throwIfDisposed(),Et.clone(this)}toString(t=!1){return xt(this.dataSync(),this.shape,this.dtype,t)}cast(t){return this.throwIfDisposed(),Et.cast(this,t)}variable(t=!0,e,n){return this.throwIfDisposed(),Tt().makeVariable(this,t,e,n)}}Object.defineProperty(Ft,Symbol.hasInstance,{value:t=>!!t&&null!=t.data&&null!=t.dataSync&&null!=t.throwIfDisposed}),ht("Tensor",(()=>Ft));class Dt extends Ft{constructor(t,e,n,r){super(t.shape,t.dtype,t.dataId,r),this.trainable=e,this.name=n}assign(t){if(t.dtype!==this.dtype)throw new Error(`dtype of the new value (${t.dtype}) and previous value (${this.dtype}) must match`);if(!U(t.shape,this.shape))throw new Error(`shape of the new value (${t.shape}) and previous value (${this.shape}) must match`);Tt().disposeTensor(this),this.dataId=t.dataId,Tt().incRef(this,null)}dispose(){Tt().disposeVariable(this),this.isDisposedInternal=!0}}var Lt,_t,Rt,Ot,Mt;Object.defineProperty(Dt,Symbol.hasInstance,{value:t=>t instanceof Ft&&null!=t.assign&&t.assign instanceof Function}),function(t){t.R0="R0",t.R1="R1",t.R2="R2",t.R3="R3",t.R4="R4",t.R5="R5",t.R6="R6"}(Lt||(Lt={})),function(t){t.float32="float32",t.int32="int32",t.bool="int32",t.complex64="complex64"}(_t||(_t={})),function(t){t.float32="float32",t.int32="int32",t.bool="bool",t.complex64="complex64"}(Rt||(Rt={})),function(t){t.float32="float32",t.int32="float32",t.bool="float32",t.complex64="complex64"}(Ot||(Ot={})),function(t){t.float32="complex64",t.int32="complex64",t.bool="complex64",t.complex64="complex64"}(Mt||(Mt={}));const Bt={float32:Ot,int32:_t,bool:Rt,complex64:Mt};function Pt(t,e){if(t.dtype===e.dtype)return[t,e];const n=function(t,e){if("string"===t||"string"===e){if("string"===t&&"string"===e)return"string";throw new Error(`Can not upcast ${t} with ${e}`)}return Bt[t][e]}(t.dtype,e.dtype);return[t.cast(n),e.cast(n)]}function $t(t){const e=[];return Wt(t,e,new Set),e}function Wt(t,e,n){if(null==t)return;if(t instanceof Ft)return void e.push(t);if(r=t,!Array.isArray(r)&&"object"!=typeof r)return;var r;const i=t;for(const t in i){const r=i[t];n.has(r)||(n.add(r),Wt(r,e,n))}}function Ut(t){return null!=t.kernelName}class jt{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map((t=>t.name))))}}}dispose(){for(const t in this.registeredVariables)this.registeredVariables[t].dispose()}}class Vt{constructor(t){this.ENV=t,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new jt}async ready(){if(null!=this.pendingBackendInit)return this.pendingBackendInit.then((()=>{}));if(null!=this.backendInstance)return;const t=this.getSortedBackends();for(let e=0;e<t.length;e++){const n=t[e];if(await this.initializeBackend(n).success)return void await this.setBackend(n)}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){const{name:t,asyncInit:e}=this.initializeBackendsAndReturnBest();if(e)throw new Error(`The highest priority backend '${t}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(t)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(t){if(!(t in this.registry)){if(!(t in this.registryFactory))return null;{const{asyncInit:e}=this.initializeBackend(t);if(e)return null}}return this.registry[t]}findBackendFactory(t){return t in this.registryFactory?this.registryFactory[t].factory:null}registerBackend(t,e,n=1){return t in this.registryFactory?(rt(`${t} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[t]={factory:e,priority:n},!0)}async setBackend(t){if(null==this.registryFactory[t])throw new Error(`Backend name '${t}' not found in registry`);if(this.backendName=t,null==this.registry[t]){this.backendInstance=null;const{success:e,asyncInit:n}=this.initializeBackend(t);if(!(n?await e:e))return!1}return this.backendInstance=this.registry[t],this.setupRegisteredKernels(),this.profiler=new kt(this.backendInstance),!0}setupRegisteredKernels(){mt(this.backendName).forEach((t=>{null!=t.setupFunc&&t.setupFunc(this.backendInstance)}))}disposeRegisteredKernels(t){mt(t).forEach((e=>{null!=e.disposeFunc&&e.disposeFunc(this.registry[t])}))}initializeBackend(t){const e=this.registryFactory[t];if(null==e)throw new Error(`Cannot initialize backend ${t}, no registration found.`);try{const n=e.factory();if(!n||n instanceof class{refCount(t){return B("refCount")}incRef(t){return B("incRef")}timerAvailable(){return!0}time(t){return B("time")}read(t){return B("read")}readSync(t){return B("readSync")}numDataIds(){return B("numDataIds")}disposeData(t,e){return B("disposeData")}write(t,e,n){return B("write")}move(t,e,n,r,i){return B("move")}memory(){return B("memory")}floatPrecision(){return B("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return B("dispose")}}||"function"!=typeof n.then)return this.registry[t]=n,{success:!0,asyncInit:!1};{const e=++this.pendingBackendInitId,r=n.then((n=>!(e<this.pendingBackendInitId)&&(this.registry[t]=n,this.pendingBackendInit=null,!0))).catch((n=>(e<this.pendingBackendInitId||(this.pendingBackendInit=null,rt(`Initialization of backend ${t} failed`),rt(n.stack||n.message)),!1)));return this.pendingBackendInit=r,{success:r,asyncInit:!0}}}catch(e){return rt(`Initialization of backend ${t} failed`),rt(e.stack||e.message),{success:!1,asyncInit:!1}}}removeBackend(t){if(!(t in this.registryFactory))throw new Error(`${t} backend not found in registry`);this.backendName===t&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,t in this.registry&&(this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t]),delete this.registryFactory[t],this.backendName===t&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort(((t,e)=>this.registryFactory[e].priority-this.registryFactory[t].priority))}initializeBackendsAndReturnBest(){const t=this.getSortedBackends();for(let e=0;e<t.length;e++){const n=t[e],{success:r,asyncInit:i}=this.initializeBackend(n);if(i||r)return{name:n,asyncInit:i}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(t,e){const n=this.state.tensorInfo.get(e),r=n.backend,i=this.readSync(e),a=r.refCount(e);r.disposeData(e,!0),n.backend=t,t.move(e,i,n.shape,n.dtype,a),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(t,e){let n,r=null;if(null==e){if("function"!=typeof t)throw new Error("Please provide a function to tidy()");e=t}else{if("string"!=typeof t&&!(t instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof e)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=t}return this.scopedRun((()=>this.startScope(r)),(()=>this.endScope(n)),(()=>(n=e(),n instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),n)))}scopedRun(t,e,n){t();try{const t=n();return e(),t}catch(t){throw e(),t}}nextTensorId(){return Vt.nextTensorId++}nextVariableId(){return Vt.nextVariableId++}clone(t){const e=Kt.runKernel(y,{x:t}),n={x:t};return this.addTapeNode(this.state.activeScope.name,n,[e],(t=>({x:()=>{const e={x:t},n={dtype:"float32"};return Kt.runKernel(a,e,n)}})),[],{}),e}runKernel(t,e,n){null==this.backendName&&this.backend;if(!(null!=ft(t,this.backendName)))throw new Error(`Kernel '${t}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:t,inputs:e,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(t,e,n){const r=this.backend.numDataIds();let i=0;n.forEach((t=>{i+="complex64"===t.dtype?3:1}));const a=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],s=r-e-i-a;if(s>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${s} data ids) after running '${t}'`)}runKernelFunc(t){let e,n=[];const r=this.isTapeOn(),i=this.state.numBytes,a=this.state.numTensors;let s,o;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0),null==this.backendName&&this.backend;const u=Ut(t)?t.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(Ut(t)){const{kernelName:e,inputs:i,attrs:a}=t;null==this.backendName&&this.backend;const u=ft(e,this.backendName);P(null!=u,(()=>`Cannot find registered kernel '${e}' for backend '${this.backendName}'`)),s=()=>{const t=this.backend.numDataIds();o=u.kernelFunc({inputs:i,attrs:a,backend:this.backend});const s=Array.isArray(o)?o:[o];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(e,t,s);const l=s.map((t=>{if(null!=t.rank)return t;const{dataId:e,shape:n,dtype:r}=t;return this.makeTensorFromDataId(e,n,r)}));if(r){const t=this.getTensorsForGradient(e,i,l);n=this.saveTensorsForBackwardMode(t)}return l}}else{const{forwardFunc:e}=t,i=t=>{r&&(n=t.map((t=>this.keep(this.clone(t)))))};s=()=>{const t=this.backend.numDataIds();o=this.tidy((()=>e(this.backend,i)));const n=Array.isArray(o)?o:[o];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(u,t,n),n}}const{inputs:l,attrs:c}=t,h=Ut(t)?null:t.backwardsFunc;let p;return this.scopedRun((()=>this.state.kernelDepth++),(()=>this.state.kernelDepth--),(()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(p=this.profiler.profileKernel(u,l,(()=>s())),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(p),e=p.outputs):e=s()})),r&&this.addTapeNode(u,l,e,h,n,c),this.state.profiling&&this.state.activeProfile.kernels.push({name:u,bytesAdded:this.state.numBytes-i,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-a,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(l).map((t=>null!=l[t]?l[t].shape:null)),outputShapes:e.map((t=>t.shape)),kernelTimeMs:p.timeMs,extraInfo:p.extraInfo}),Array.isArray(o)?e:e[0]}saveTensorsForBackwardMode(t){return t.map((t=>this.keep(this.clone(t))))}getTensorsForGradient(t,e,n){const r=gt(t);if(null!=r){const t=r.inputsToSave||[],i=r.outputsToSave||[];let a;r.saveAllInputs?(P(Array.isArray(e),(()=>"saveAllInputs is true, expected inputs to be an array.")),a=Object.keys(e).map((t=>e[t]))):a=t.map((t=>e[t]));const s=n.filter(((t,e)=>i[e]));return a.concat(s)}return[]}makeTensor(t,e,n,r){if(null==t)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",r=r||this.backend;let i=t;"string"===n&&H(t[0])&&(i=t.map((t=>function(t,e="utf-8"){return e=e||"utf-8",ot().platform.encode(t,e)}(t))));const a=r.write(i,e,n),s=new Ft(e,n,a,this.nextTensorId());if(this.trackTensor(s,r),"string"===n){const t=this.state.tensorInfo.get(a),e=function(t){if(null==t)return 0;let e=0;return t.forEach((t=>e+=t.length)),e}(i);this.state.numBytes+=e-t.bytes,t.bytes=e}return s}makeTensorFromDataId(t,e,n,r){const i=new Ft(e,n=n||"float32",t,this.nextTensorId());return this.trackTensor(i,r),i}makeVariable(t,e=!0,n,r){n=n||this.nextVariableId().toString(),null!=r&&r!==t.dtype&&(t=t.cast(r));const i=new Dt(t,e,n,this.nextTensorId());if(null!=this.state.registeredVariables[i.name])throw new Error(`Variable with name ${i.name} was already registered`);return this.state.registeredVariables[i.name]=i,this.incRef(i,this.backend),i}trackTensor(t,e){this.state.numTensors++,"string"===t.dtype&&this.state.numStringTensors++;let n=0;"complex64"!==t.dtype&&"string"!==t.dtype&&(n=t.size*G(t.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(t.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(t.dataId,{backend:e||this.backend,dtype:t.dtype,shape:t.shape,bytes:n})),t instanceof Dt||this.track(t)}incRef(t,e){this.trackTensor(t,e),this.backend.incRef(t.dataId)}removeDataId(t,e){this.state.tensorInfo.has(t)&&this.state.tensorInfo.get(t).backend===e&&(this.state.tensorInfo.delete(t),this.state.numDataBuffers--)}disposeTensor(t){if(!this.state.tensorInfo.has(t.dataId))return;const e=this.state.tensorInfo.get(t.dataId);if(this.state.numTensors--,"string"===t.dtype&&(this.state.numStringTensors--,this.state.numBytes-=e.bytes),"complex64"!==t.dtype&&"string"!==t.dtype){const e=t.size*G(t.dtype);this.state.numBytes-=e}e.backend.disposeData(t.dataId)&&this.removeDataId(t.dataId,e.backend)}disposeVariables(){for(const t in this.state.registeredVariables){const e=this.state.registeredVariables[t];this.disposeVariable(e)}}disposeVariable(t){this.disposeTensor(t),null!=this.state.registeredVariables[t.name]&&delete this.state.registeredVariables[t.name]}memory(){const t=this.backend.memory();return t.numTensors=this.state.numTensors,t.numDataBuffers=this.state.numDataBuffers,t.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(t.unreliable=!0,null==t.reasons&&(t.reasons=[]),t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),t}async profile(t){this.state.profiling=!0;const e=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await t(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map((t=>t.totalBytesSnapshot))),this.state.activeProfile.newBytes=this.state.numBytes-e,this.state.activeProfile.newTensors=this.state.numTensors-n;for(const t of this.state.activeProfile.kernels)t.kernelTimeMs=await t.kernelTimeMs,t.extraInfo=await t.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(t,e,n,r,i,a){const s={id:this.state.nextTapeNodeId++,kernelName:t,inputs:e,outputs:n,saved:i},o=gt(t);null!=o&&(r=o.gradFunc),null!=r&&(s.gradient=t=>(t=t.map(((t,e)=>{if(null==t){const t=n[e],r=et(t.size,t.dtype);return this.makeTensor(r,t.shape,t.dtype)}return t})),r(t.length>1?t:t[0],i,a))),this.state.activeTape.push(s)}keep(t){return t.kept=!0,t}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(t){const e={track:[],name:"unnamed scope",id:this.state.nextScopeId++};t&&(e.name=t),this.state.scopeStack.push(e),this.state.activeScope=e}endScope(t){const e=$t(t),n=new Set(e.map((t=>t.id)));for(let t=0;t<this.state.activeScope.track.length;t++){const e=this.state.activeScope.track[t];e.kept||n.has(e.id)||e.dispose()}const r=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],e.forEach((t=>{t.kept||t.scopeId!==r.id||this.track(t)}))}gradients(t,e,n,r=!1){if(P(e.length>0,(()=>"gradients() received an empty list of xs.")),null!=n&&"float32"!==n.dtype)throw new Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);const i=this.scopedRun((()=>this.startTape()),(()=>this.endTape()),(()=>this.tidy("forward",t)));P(i instanceof Ft,(()=>"The result y returned by f() must be a tensor."));const a=function(t,e,n){const r={},i={};for(let t=0;t<e.length;t++)r[e[t].id]=!0;for(let n=0;n<t.length;n++){const a=t[n],s=a.inputs;for(const t in s){const n=s[t];let o=!1;for(let t=0;t<e.length;t++)if(r[n.id]){a.outputs.forEach((t=>r[t.id]=!0)),o=!0,i[a.id]=!0;break}if(o)break}}const a={};a[n.id]=!0;const s={};for(let e=t.length-1;e>=0;e--){const n=t[e],r=n.inputs;for(let t=0;t<n.outputs.length;t++)if(a[n.outputs[t].id]){for(const t in r)a[r[t].id]=!0,s[n.id]=!0;break}}const o=[];for(let e=0;e<t.length;e++){const n=t[e];if(i[n.id]&&s[n.id]){const t={};for(const e in n.inputs){const i=n.inputs[e];r[i.id]&&(t[e]=i)}const e=Object.assign({},n);e.inputs=t,e.outputs=n.outputs,o.push(e)}}return o}(this.state.activeTape,e,i);if(!r&&0===a.length&&e.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",(()=>{const t={};t[i.id]=null==n?function(t){const e=tt(W(t),"float32");return Kt.makeTensor(e,t,"float32")}(i.shape):n,function(t,e,n,r){for(let i=e.length-1;i>=0;i--){const a=e[i],s=[];if(a.outputs.forEach((e=>{const n=t[e.id];null!=n?s.push(n):s.push(null)})),null==a.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${a.kernelName}.`);const o=a.gradient(s);for(const e in a.inputs){if(!(e in o))throw new Error(`Cannot backprop through input ${e}. Available gradients found: ${Object.keys(o)}.`);const i=n((()=>o[e]()));if("float32"!==i.dtype)throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input ${e} must have 'float32' dtype, but has '${i.dtype}'`);const s=a.inputs[e];if(!U(i.shape,s.shape))throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input '${e}' has shape '${i.shape}', which does not match the shape of the input '${s.shape}'`);if(null==t[s.id])t[s.id]=i;else{const e=t[s.id];t[s.id]=r(e,i),e.dispose()}}}}(t,a,(t=>this.tidy(t)),qt);const r=e.map((e=>t[e.id]));return 0===this.state.gradientDepth&&(this.state.activeTape.forEach((t=>{for(const e of t.saved)e.dispose()})),this.state.activeTape=null),{value:i,grads:r}}))}customGrad(t){return P(Z(t),(()=>"The f passed in customGrad(f) must be a function.")),(...e)=>{let n;P(e.every((t=>t instanceof Ft)),(()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors"));const r={};e.forEach(((t,e)=>{r[e]=t}));return this.runKernelFunc({forwardFunc:(r,i)=>(n=t(...e,i),P(n.value instanceof Ft,(()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor")),P(Z(n.gradFunc),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.")),n.value),backwardsFunc:(t,r)=>{const i=n.gradFunc(t,r),a=Array.isArray(i)?i:[i];P(a.length===e.length,(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).")),P(a.every((t=>t instanceof Ft)),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors."));const s={};return a.forEach(((t,e)=>{s[e]=()=>t})),s},inputs:r})}}readSync(t){return this.state.tensorInfo.get(t).backend.readSync(t)}read(t){return this.state.tensorInfo.get(t).backend.read(t)}async time(t){const e=bt(),n=await this.backend.time(t);return n.wallMs=bt()-e,n}track(t){return null!=this.state.activeScope&&(t.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(t)),t}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new jt;for(const t in this.registry)this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}Vt.nextTensorId=0,Vt.nextVariableId=0;const Kt=function(){const t=ct();if(null==t._tfengine){const e=new at(t);t._tfengine=new Vt(e)}var e;return e=t._tfengine.ENV,lt=e,Tt=()=>t._tfengine,t._tfengine}();function qt(t,e){const r={a:t,b:e};return Kt.runKernel(n,r)}function Gt(t,e){let n=t;if(q(t))return"string"===e?[]:[t.length];if(!Array.isArray(t))return[];const r=[];for(;Array.isArray(n)||q(n)&&"string"!==e;)r.push(n.length),n=n[0];return Array.isArray(t)&&ot().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&Ht(t,r,[]),r}function Ht(t,e,n){if(n=n||[],!Array.isArray(t)&&!q(t))return void P(0===e.length,(()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`));P(e.length>0,(()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${t.length} elements`)),P(t.length===e[0],(()=>`Element arr[${n.join("][")}] should have ${e[0]} elements, but has ${t.length} elements`));const r=e.slice(1);for(let e=0;e<t.length;++e)Ht(t[e],r,n.concat(e))}function Jt(t,e,n,r){if("string_or_numeric"!==t){if(null==t)throw new Error("Expected dtype cannot be null.");if("numeric"!==t&&t!==e||"numeric"===t&&"string"===e)throw new Error(`Argument '${n}' passed to '${r}' must be ${t} tensor, but got ${e} tensor`)}}function Zt(t,e,n,r="numeric"){if(t instanceof Ft)return Jt(r,t.dtype,e,n),t;let i=J(t);if("string"!==i&&["bool","int32","float32"].indexOf(r)>=0&&(i=r),Jt(r,i,e,n),null==t||!q(t)&&!Array.isArray(t)&&"number"!=typeof t&&"boolean"!=typeof t&&"string"!=typeof t){const r=null==t?"null":t.constructor.name;throw new Error(`Argument '${e}' passed to '${n}' must be a Tensor or TensorLike, but got '${r}'`)}const a=Gt(t,i);q(t)||Array.isArray(t)||(t=[t]);const s="string"!==i?vt(t,i):$(t,[],!0);return Kt.makeTensor(s,a,i)}function Yt(t,e,n,r="numeric"){if(!Array.isArray(t))throw new Error(`Argument ${e} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return t.map(((t,i)=>Zt(t,`${e}[${i}]`,n,r)))}function Xt(t){const e=Object.keys(t);if(1!==e.length)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let n=e[0];const r=t[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n+="__op";const i=(...t)=>{Kt.startScope(n);try{const e=r(...t);return nt(e)&&console.error("Cannot return a Promise inside of tidy."),Kt.endScope(e),e}catch(t){throw Kt.endScope(null),t}};return Object.defineProperty(i,"name",{value:n,configurable:!0}),i}const Qt=Xt({cast_:function(t,e){const n=Zt(t,"x","cast");if(!function(t){return"bool"===t||"complex64"===t||"float32"===t||"int32"===t||"string"===t}(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if("string"===e&&"string"!==n.dtype||"string"!==e&&"string"===n.dtype)throw new Error("Only strings can be casted to strings");const r={x:n},i={dtype:e};return Kt.runKernel(a,r,i)}});const te=Xt({mul_:function(t,e){let n=Zt(t,"a","mul"),r=Zt(e,"b","mul");[n,r]=Pt(n,r);const i={a:n,b:r};return Kt.runKernel(b,i)}});const ee=Xt({step_:function(t,e=0){const n={x:Zt(t,"x","step")},r={alpha:e};return Kt.runKernel(M,n,r)}}),ne={kernelName:"Abs",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>te(t,ee(Qt(n,"float32"),-1))}}};const re=Xt({floorDiv_:function(t,e){let n=Zt(t,"a","floorDiv"),r=Zt(e,"b","floorDiv");[n,r]=Pt(n,r);const i={a:n,b:r};return Kt.runKernel(f,i)}});const ie=Xt({div_:function(t,e){let n=Zt(t,"a","div"),r=Zt(e,"b","div");if([n,r]=Pt(n,r),"int32"===n.dtype&&"int32"===r.dtype)return re(n,r);const i={a:n,b:r};return Kt.runKernel(h,i,{})}});const ae=Xt({neg_:function(t){const e={x:Zt(t,"x","neg")};return Kt.runKernel("Neg",e)}});function se(t,e,n,r){if(null==r&&(r=J(t)),"complex64"===r)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!q(t)&&!Array.isArray(t)&&"number"!=typeof t&&"boolean"!=typeof t&&"string"!=typeof t)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=e){!function(t){t.forEach((e=>{P(Number.isInteger(e)&&e>=0,(()=>`Tensor must have a shape comprised of positive integers but got shape [${t}].`))}))}(e);const t=W(e),r=W(n);P(t===r,(()=>`Based on the provided shape, [${e}], the tensor should have ${t} values but has ${r}`));for(let t=0;t<n.length;++t){const r=n[t],i=t!==n.length-1||r!==W(e.slice(t));P(n[t]===e[t]||!i,(()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${e}). `))}}return q(t)||Array.isArray(t)||(t=[t]),e=e||n,t="string"!==r?vt(t,r):$(t,[],!0),Kt.makeTensor(t,e,r)}function oe(t,e){if((q(t)&&"string"!==e||Array.isArray(t))&&"complex64"!==e)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===e&&q(t)&&!(t instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return se(t,[],[],e)}const ue=Xt({sqrt_:function(t){const e={x:Zt(t,"x","sqrt")};return Kt.runKernel(T,e)}});const le=Xt({square_:function(t){const e=Zt(t,"x","square");return Kt.runKernel("Square",{x:e},{})}});const ce=Xt({sub_:function(t,e){let n=Zt(t,"a","sub"),r=Zt(e,"b","sub");[n,r]=Pt(n,r);const i={a:n,b:r};return Kt.runKernel("Sub",i)}}),he={kernelName:"Acos",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const e=le(Qt(n,"float32")),r=ue(ce(oe(1),e));return ae(ie(t,r))}}}},pe={kernelName:"Acosh",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const e=ue(ce(le(Qt(n,"float32")),1));return ie(t,e)}}}};function de(t,e){const n=[];for(let r=0;r<e.length;r++){const i=t[t.length-r-1],a=e.length-r-1,s=e[a];(null==i||1===i&&s>1)&&n.unshift(a)}return n}function fe(t,e){const n=[],r=Math.max(t.length,e.length);for(let i=0;i<r;i++){let r=t[t.length-i-1];null==r&&(r=1);let a=e[e.length-i-1];if(null==a&&(a=1),1===r)n.unshift(a);else if(1===a)n.unshift(r);else{if(r!==a){throw Error(`Operands could not be broadcast together with shapes ${t} and ${e}.`)}n.unshift(r)}}return n}const ge=Xt({reshape_:function(t,e){const n={x:Zt(t,"x","reshape","string_or_numeric")},r={shape:e};return Kt.runKernel(S,n,r)}});const me=Xt({sum_:function(t,e=null,n=!1){let r=Zt(t,"x","sum");"bool"===r.dtype&&(r=Qt(r,"int32"));const i={x:r},a={axis:e,keepDims:n};return Kt.runKernel("Sum",i,a)}}),ye={kernelName:n,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,i=fe(n.shape,r.shape);return{a:()=>{let e=t;const r=de(n.shape,i);return r.length>0&&(e=me(e,r)),ge(e,n.shape)},b:()=>{let e=t;const n=de(r.shape,i);return n.length>0&&(e=me(e,n)),ge(e,r.shape)}}}},ve={kernelName:"AddN",saveAllInputs:!0,gradFunc:(t,e)=>{const n={};return e.forEach(((e,r)=>{n[r]=()=>t.clone()})),n}};const be=Xt({zerosLike_:function(t){const e={x:Zt(t,"x","zerosLike")};return Kt.runKernel(O,e)}}),we={kernelName:"ArgMax",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>be(n)}}},ke={kernelName:"ArgMin",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>be(n)}}},Se={kernelName:"Asin",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>ie(t,ue(ce(oe(1),le(Qt(n,"float32")))))}}};const Ne=Xt({add_:function(t,e){let r=Zt(t,"a","add"),i=Zt(e,"b","add");[r,i]=Pt(r,i);const a={a:r,b:i};return Kt.runKernel(n,a)}}),xe={kernelName:"Asinh",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const e=ue(Ne(oe(1),le(Qt(n,"float32"))));return ie(t,e)}}}},ze={kernelName:"Atan2",inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,i=fe(n.shape,r.shape);return{a:()=>{const e=Ne(le(n),le(r));let a=te(t,ie(r,e));const s=de(n.shape,i);return s.length>0&&(a=me(a,s)),ge(a,n.shape)},b:()=>{const e=Ne(le(n),le(r));let a=ae(te(t,ie(n,e)));const s=de(r.shape,i);return s.length>0&&(a=me(a,s)),ge(a,r.shape)}}}},Ie={kernelName:"Atan",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>ie(t,Ne(le(Qt(n,"float32")),1))}}},Ae={kernelName:"Atanh",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>ie(t,ce(oe(1),le(Qt(n,"float32"))))}}};const Ce=Xt({avgPool3dGrad_:function(t,e,n,r,i,a){const s=Zt(t,"dy","avgPool3dGrad"),o=Zt(e,"input","avgPool3dGrad");let u=s,l=o,c=!1;4===o.rank&&(c=!0,u=ge(s,[1,s.shape[0],s.shape[1],s.shape[2],s.shape[3]]),l=ge(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),P(5===u.rank,(()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${u.rank}.`)),P(5===l.rank,(()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${l.rank}.`)),null!=a&&P(j(i),(()=>`Error in avgPool3dGrad: pad must be an integer when using, dimRoundingMode ${a} but got pad ${i}.`));const h={dy:u,input:l},p={filterSize:n,strides:r,pad:i,dimRoundingMode:a},d=Kt.runKernel("AvgPool3DGrad",h,p);return c?ge(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}}),Te={kernelName:"AvgPool3D",inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{filterSize:i,strides:a,pad:s,dimRoundingMode:o}=n;return{x:()=>Ce(t,r,i,a,s,o)}}};const Ee=Xt({avgPoolGrad_:function(t,e,n,r,i){const a=Zt(t,"dy","avgPoolGrad"),s=Zt(e,"input","avgPoolGrad");P(s.rank===a.rank,(()=>`Rank of input (${s.rank}) does not match rank of dy (${a.rank})`));let o=s,u=a,l=!1;3===s.rank&&(l=!0,o=ge(s,[1,s.shape[0],s.shape[1],s.shape[2]]),u=ge(a,[1,a.shape[0],a.shape[1],a.shape[2]])),P(4===u.rank,(()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${u.rank}.`)),P(4===o.rank,(()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${o.rank}.`));const c={dy:u,input:o},h={filterSize:n,strides:r,pad:i},p=Kt.runKernel("AvgPoolGrad",c,h);return l?ge(p,[p.shape[1],p.shape[2],p.shape[3]]):p}}),Fe={kernelName:"AvgPool",inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{filterSize:i,strides:a,pad:s}=n;return{x:()=>Ee(t,r,i,a,s)}}};const De=Xt({matMul_:function(t,e,n=!1,i=!1){let a=Zt(t,"a","matMul"),s=Zt(e,"b","matMul");[a,s]=Pt(a,s);const o={a:a,b:s},u={transposeA:n,transposeB:i};return Kt.runKernel(r,o,u)}}),Le={kernelName:r,inputsToSave:["a","b"],gradFunc:(t,e,n)=>{const[r,i]=e,{transposeA:a,transposeB:s}=n;return a||s?!a&&s?{a:()=>De(t,i,!1,!1),b:()=>De(t,r,!0,!1)}:a&&!s?{a:()=>De(i,t,!1,!0),b:()=>De(r,t,!1,!1)}:{a:()=>De(i,t,!0,!0),b:()=>De(t,r,!0,!0)}:{a:()=>De(t,i,!1,!0),b:()=>De(r,t,!0,!1)}}};const _e=Xt({spaceToBatchND_:function(t,e,n){const r=Zt(t,"x","spaceToBatchND");P(r.rank>=1+e.length,(()=>`input rank ${r.rank} should be > than [blockShape] ${e.length}`)),P(n.length===e.length,(()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${e.length}`)),P(r.shape.reduce(((t,r,i)=>i>0&&i<=e.length?t&&(r+n[i-1][0]+n[i-1][1])%e[i-1]==0:t),!0),(()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${e.toString()}`));const i={x:r},a={blockShape:e,paddings:n};return Kt.runKernel(E,i,a)}}),Re={kernelName:i,gradFunc:(t,e,n)=>{const{blockShape:r,crops:i}=n;return{x:()=>_e(t,r,i)}}},Oe={kernelName:"BroadcastTo",gradFunc:(t,e,n)=>{const r=n,i=r.inputShape,a=r.shape,s=Array.from(a);for(let t=i.length-1;t>=0;t--)if(i[t]===a[t])s[t]=1;else if(1!==i[t])throw new Error(`broadcastTo(): [${i}] cannot be broadcast to [${a}].`);const o=[];for(let t=0;t<s.length;t++)s[t]>1&&o.push(t);return{x:()=>me(t,o,!0)}}},Me={kernelName:a,gradFunc:t=>({x:()=>t.clone()})},Be={kernelName:"Ceil",gradFunc:t=>({x:()=>be(t)})};const Pe=Xt({greaterEqual_:function(t,e){let n=Zt(t,"a","greaterEqual","string_or_numeric"),r=Zt(e,"b","greaterEqual","string_or_numeric");[n,r]=Pt(n,r),fe(n.shape,r.shape);const i={a:n,b:r};return Kt.runKernel(m,i)}});const $e=Xt({lessEqual_:function(t,e){let n=Zt(t,"a","lessEqual","string_or_numeric"),r=Zt(e,"b","lessEqual","string_or_numeric");[n,r]=Pt(n,r),fe(n.shape,r.shape);const i={a:n,b:r};return Kt.runKernel("LessEqual",i)}});const We=Xt({logicalAnd_:function(t,e){const n=Zt(t,"a","logicalAnd","bool"),r=Zt(e,"b","logicalAnd","bool");fe(n.shape,r.shape);const i={a:n,b:r};return Kt.runKernel("LogicalAnd",i)}});const Ue=Xt({clone_:function(t){const e={x:Zt(t,"x","clone","string_or_numeric")};return Kt.runKernel(y,e)}});const je=Xt({broadcastTo_:function(t,e){let n=Zt(t,"broadcastTo","x");const r=n.shape;if(e.some((t=>!(t>0)||t%1!=0)))throw new Error(`broadcastTo(): Invalid broadcast shape [${e}].`);if(e.length<n.rank)throw new Error(`broadcastTo(): shape.length=${e.length} < input.rank=${n.rank}.`);if(e.length>n.rank){const t=n.shape.slice();for(;t.length<e.length;)t.unshift(1);n=ge(n,t)}const i=n.shape,a=Array.from(e);for(let t=e.length-1;t>=0;t--)if(i[t]===e[t])a[t]=1;else if(1!==n.shape[t])throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${e}].`);if(0===a.map(((t,e)=>t>1?e:-1)).filter((t=>t>=0)).length)return Ue(n);const s={x:n},o={reps:a};return Kt.runKernel(D,s,o)}});const Ve=Xt({where_:function(t,e,n){const r=Zt(e,"a","where"),i=Zt(n,"b","where"),a=Zt(t,"condition","where","bool"),s=fe(fe(a.shape,r.shape),i.shape),o={condition:je(a,s),t:je(r,s),e:je(i,s)};return Kt.runKernel(z,o)}}),Ke={kernelName:"ClipByValue",inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{clipValueMin:i,clipValueMax:a}=n;return{x:()=>Ve(We(Pe(r,i),$e(r,a)),t,be(t))}}},qe={kernelName:"ComplexAbs",inputsToSave:["x"],gradFunc:ne.gradFunc};const Ge=Xt({split_:function(t,e,n=0){const r={x:Zt(t,"x","split")},i={numOrSizeSplits:e,axis:n};return Kt.runKernel(F,r,i)}}),He={kernelName:s,saveAllInputs:!0,gradFunc:(t,e,n)=>{const r=e.map((t=>t.shape)),{axis:i}=n,a=K(i,e[0].shape)[0],s=r.map((t=>t[a]));return Ge(t,s,a).map((t=>()=>t))}};const Je=Xt({conv2DBackpropFilter_:function(t,e,n,r,i,a="NHWC",s){let o=t;3===t.rank&&(o=ge(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let u=e;3===u.rank&&(u=ge(e,[1,e.shape[0],e.shape[1],e.shape[2]])),P(4===o.rank,(()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${o.shape}.`)),P(4===u.rank,(()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${u.shape}.`)),P(4===n.length,(()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`));const l="NHWC"===a?o.shape[3]:o.shape[1],c="NHWC"===a?u.shape[3]:u.shape[1];P(l===n[2],(()=>`Error in conv2dDerFilter: depth of input ${l}) must match input depth in filter (${n[2]}.`)),P(c===n[3],(()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${n[3]}).`)),null!=s&&P(j(i),(()=>`Error in conv2dDerFilter: pad must be an integer when using, dimRoundingMode ${s} but got pad ${i}.`));const h={x:o,dy:u},p={strides:r,pad:i,dataFormat:a,dimRoundingMode:s,filterShape:n};return Kt.runKernel("Conv2DBackpropFilter",h,p)}});const Ze=Xt({conv2DBackpropInput_:function(t,e,n,r,i,a="NHWC",s){P(t.length===e.rank,(()=>`Length of inShape (${t.length}) and rank of dy (${e.rank}) must match`));let o=t,l=e,c=!1;3===e.rank&&(c=!0,l=ge(e,[1,e.shape[0],e.shape[1],e.shape[2]]),o=[1,t[0],t[1],t[2]]),P(4===o.length,(()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${o.length}.`)),P(4===l.rank,(()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`)),P(4===n.rank,(()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`));const h="NHWC"===a?o[3]:o[1],p="NHWC"===a?l.shape[3]:l.shape[1];P(h===n.shape[2],(()=>`Error in conv2dDerInput: depth of input (${h}) must match input depth for filter ${n.shape[2]}.`)),P(p===n.shape[3],(()=>`Error in conv2dDerInput: depth of output (${p}) must match output depth for filter ${n.shape[3]}.`)),null!=s&&P(j(i),(()=>`Error in conv2dDerInput: pad must be an integer when using, dimRoundingMode ${s} but got pad ${i}.`));const d={dy:l,filter:n},f={strides:r,pad:i,dataFormat:a,dimRoundingMode:s,inputShape:o},g=Kt.runKernel(u,d,f);return c?ge(g,[g.shape[1],g.shape[2],g.shape[3]]):g}});function Ye(t){const[e,n,r]=function(t){return"number"==typeof t?[t,t,t]:2===t.length?[t[0],t[1],1]:t}(t);return 1===e&&1===n&&1===r}function Xe(t,e){return Ye(t)||Ye(e)}const Qe={kernelName:o,inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const[r,i]=e,{dilations:a,strides:s,pad:o,dataFormat:u}=n;return P(Ye(a),(()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${a}'`)),{x:()=>Ze(r.shape,t,i,s,o,u),filter:()=>Je(r,t,i.shape,s,o,u)}}};const tn=Xt({conv2d_:function(t,e,n,r,i="NHWC",a=[1,1],s){const u=Zt(t,"x","conv2d"),l=Zt(e,"filter","conv2d");let c=u,h=!1;3===u.rank&&(h=!0,c=ge(u,[1,u.shape[0],u.shape[1],u.shape[2]])),P(4===c.rank,(()=>`Error in conv2d: input must be rank 4, but got rank ${c.rank}.`)),P(4===l.rank,(()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`)),null!=s&&P(j(r),(()=>`Error in conv2d: pad must be an integer when using, dimRoundingMode ${s} but got pad ${r}.`));const p="NHWC"===i?c.shape[3]:c.shape[1];P(p===l.shape[2],(()=>`Error in conv2d: depth of input (${p}) must match input depth for filter ${l.shape[2]}.`)),P(Xe(n,a),(()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`));const d={x:c,filter:l},f={strides:n,pad:r,dataFormat:i,dilations:a,dimRoundingMode:s},g=Kt.runKernel(o,d,f);return h?ge(g,[g.shape[1],g.shape[2],g.shape[3]]):g}}),en={kernelName:u,inputsToSave:["dy","filter"],gradFunc:(t,e,n)=>{const[r,i]=e,{strides:a,pad:s,dataFormat:o,dimRoundingMode:u}=n;return{dy:()=>tn(t,i,a,s,o,1,u),filter:()=>Je(t,r,i.shape,a,s,o,u)}}};const nn=Xt({conv3DBackpropFilter_:function(t,e,n,r,i){let a=t;4===t.rank&&(a=ge(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]));let s=e;4===s.rank&&(s=ge(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]])),P(5===a.rank,(()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${a.shape}.`)),P(5===s.rank,(()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${s.shape}.`)),P(5===n.length,(()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${n}.`)),P(a.shape[4]===n[3],(()=>`Error in conv3dDerFilter: depth of input ${a.shape[4]}) must match input depth in filter (${n[3]}.`)),P(s.shape[4]===n[4],(()=>`Error in conv3dDerFilter: depth of dy (${s.shape[4]}) must match output depth for filter (${n[4]}).`));const o={x:a,dy:s},u={strides:r,pad:i,filterShape:n};return Kt.runKernel("Conv3DBackpropFilterV2",o,u)}});const rn=Xt({conv3DBackpropInput_:function(t,e,n,r,i){P(t.length===e.rank,(()=>`Length of inShape (${t.length}) and rank of dy (${e.rank}) must match`));let a=t,s=e,o=!1;4===e.rank&&(o=!0,s=ge(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]),a=[1,t[0],t[1],t[2],t[3]]);const u=a[4],l=s.shape[4];P(5===a.length,(()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${a.length}.`)),P(5===s.rank,(()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${s.rank}`)),P(5===n.rank,(()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`)),P(u===n.shape[3],(()=>`Error in conv3dDerInput: depth of input (${u}) must match input depth for filter ${n.shape[3]}.`)),P(l===n.shape[4],(()=>`Error in conv3dDerInput: depth of output (${l}) must match output depth for filter ${n.shape[4]}.`));const c={dy:s,filter:n},h={pad:i,strides:r,inputShape:a},p=Kt.runKernel("Conv3DBackpropInputV2",c,h);return o?ge(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}}),an={kernelName:"Conv3D",inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const{dilations:r,strides:i,pad:a}=n;P(Ye(r),(()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`));const[s,o]=e;return{x:()=>rn(s.shape,t,o,i,a),filter:()=>nn(s,t,o.shape,i,a)}}};const sn=Xt({sin_:function(t){const e={x:Zt(t,"x","sin")};return Kt.runKernel("Sin",e)}}),on={kernelName:"Cos",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>te(ae(sn(Qt(n,"float32"))),t)}}};const un=Xt({sinh_:function(t){const e={x:Zt(t,"x","sinh")};return Kt.runKernel(A,e)}}),ln={kernelName:l,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>te(un(Qt(n,"float32")),t)}}};function cn(t,e){return function(t,e,n){const r=t.length+e.length,i=[];let a=0,s=0;for(let o=0;o<r;o++)-1===n.indexOf(o)?i.push(t[a++]):i.push(e[s++]);return i}(t,e.map((t=>1)),e)}function hn(t){return t.map(((t,e)=>[e,t])).sort(((t,e)=>t[1]-e[1])).map((t=>t[0]))}const pn=Xt({cumsum_:function(t,e=0,n=!1,r=!1){const i={x:Zt(t,"x","cumsum")},a={axis:e,exclusive:n,reverse:r};return Kt.runKernel(c,i,a)}});const dn=Xt({transpose_:function(t,e){const n=Zt(t,"x","transpose");if(null==e&&(e=n.shape.map(((t,e)=>e)).reverse()),P(n.rank===e.length,(()=>`Error in transpose: rank of input ${n.rank} must match length of perm ${e}.`)),e.forEach((t=>{P(t>=0&&t<n.rank,(()=>"All entries in 'perm' must be between 0 and "+(n.rank-1)+` but got ${e}`))})),n.rank<=1)return n.clone();const r={x:n},i={perm:e};return Kt.runKernel(L,r,i)}}),fn={kernelName:c,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{axis:i,exclusive:a,reverse:s}=n;return{x:()=>{const e=function(t,e){if(function(t,e){for(let n=0;n<t.length;++n)if(t[t.length-n-1]!==e-1-n)return!1;return!0}(t,e))return null;const n=[];for(let r=0;r<e;++r)-1===t.indexOf(r)&&n.push(r);return t.forEach((t=>n.push(t))),n}([i],r.rank);let n=pn(t,i,a,!s);return null!=e&&(n=dn(n,e)),n}}}};const gn=Xt({depthwiseConv2dNativeBackpropFilter_:function(t,e,n,r,i,a=[1,1],s){let o=t;3===t.rank&&(o=ge(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let u=e;3===u.rank&&(u=ge(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const l={x:o,dy:u},c={strides:r,pad:i,dimRoundingMode:s,dilations:a,filterShape:n};return Kt.runKernel("DepthwiseConv2dNativeBackpropFilter",l,c)}});const mn=Xt({depthwiseConv2dNativeBackpropInput_:function(t,e,n,r,i,a=[1,1],s){let o=e,u=!1;3===e.rank&&(u=!0,o=ge(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const l={dy:o,filter:n},c={strides:r,pad:i,dimRoundingMode:s,dilations:a,inputShape:t},h=Kt.runKernel("DepthwiseConv2dNativeBackpropInput",l,c);return u?ge(h,[h.shape[1],h.shape[2],h.shape[3]]):h}}),yn={kernelName:"DepthwiseConv2dNative",inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const{dilations:r,strides:i,pad:a,dimRoundingMode:s}=n,o=null==r?[1,1]:r;P(Ye(o),(()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`));const[u,l]=e;return P(4===u.rank,(()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${u.rank}.`)),P(4===l.rank,(()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${l.rank}.`)),P(u.shape[3]===l.shape[2],(()=>`Error in gradient of depthwiseConv2d: number of input channels (${u.shape[3]}) must match the inChannels dimension in filter ${l.shape[2]}.`)),P(Xe(i,o),(()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${i} and dilations '${o}'.`)),null!=s&&P(j(a),(()=>`Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode ${s} but got pad ${a}.`)),{x:()=>mn(u.shape,t,l,i,a,o,s),filter:()=>gn(u,t,l.shape,i,a,o,s)}}},vn={kernelName:"Dilation2D",inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const[r,i]=e,a={x:r,filter:i,dy:t},s={x:r,filter:i,dy:t};return{x:()=>Kt.runKernel("Dilation2DBackpropInput",a,n),filter:()=>Kt.runKernel("Dilation2DBackpropFilter",s,n)}}},bn={kernelName:"Elu",outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e,r={dy:t,y:n};return{x:()=>Kt.runKernel("EluGrad",r)}}};const wn=Xt({exp_:function(t){const e={x:Zt(t,"x","exp")};return Kt.runKernel("Exp",e)}}),kn={kernelName:"Erf",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e,r=te(wn(ae(le(n))),2/Math.sqrt(Math.PI));return{x:()=>te(t,r)}}},Sn={kernelName:"Exp",outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e;return{x:()=>te(t,n)}}},Nn={kernelName:p,inputsToSave:["input"],gradFunc:(t,e)=>{const[n]=e;return{input:()=>ge(t,n.shape)}}},xn={kernelName:"Expm1",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>te(t,wn(n))}}},zn={kernelName:d,gradFunc:t=>({x:()=>be(t)})},In={kernelName:f,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,i=fe(n.shape,r.shape);return{a:()=>{const e=ie(t,Qt(r,"float32")),a=de(n.shape,i);return a.length>0?ge(me(e,a),n.shape):e},b:()=>{let e=te(t,Qt(n,"float32"));const a=de(r.shape,i);a.length>0&&(e=ge(me(e,a),r.shape));const s=le(r);return ae(ie(e,Qt(s,"float32")))}}}};const An=Xt({rsqrt_:function(t){const e={x:Zt(t,"x","rsqrt")};return Kt.runKernel(x,e)}});const Cn=Xt({tile_:function(t,e){const n=Zt(t,"x","tile","string_or_numeric");P(n.rank===e.length,(()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${e}.`));const r={x:n},i={reps:e};return Kt.runKernel(D,r,i)}}),Tn={kernelName:"FusedBatchNorm",inputsToSave:["x","mean","variance","scale"],gradFunc:(t,e,n)=>{const{varianceEpsilon:r}=n,[i,a,s,o]=e,u=null==o?oe(1):o,l=de(a.shape,i.shape),c=[];if(1===a.rank){for(let t=0;t<i.shape.length-1;++t)c.push(i.shape[t]);c.push(1)}const h=ce(i,a),p=te(t,u),d=An(Ne(s,oe(r))),f=te(te(te(d,d),d),oe(-.5));return{x:()=>1===a.rank?ge(te(te(t,Cn(ge(d,[1,1,1,a.shape[0]]),c)),u),i.shape):ge(te(te(t,d),u),i.shape),mean:()=>{let t=te(te(d,oe(-1)),p);return 1===a.rank&&(t=me(t,l)),ge(t,a.shape)},variance:()=>{let t=te(te(f,h),p);return 1===a.rank&&(t=me(t,l)),ge(t,a.shape)},scale:()=>{const e=te(h,d);let n=te(t,e);return 1===a.rank&&(n=me(n,l)),ge(n,a.shape)},offset:()=>{let e=t;return 1===a.rank&&(e=me(e,l)),ge(e,a.shape)}}}};const En=Xt({unsortedSegmentSum_:function(t,e,n){const r=Zt(t,"x","unsortedSegmentSum"),i=Zt(e,"segmentIds","unsortedSegmentSum","int32");P(j(n),(()=>"numSegments must be of dtype int"));const a={x:r,segmentIds:i},s={numSegments:n};return Kt.runKernel(R,a,s)}}),Fn={kernelName:g,inputsToSave:["x","indices"],gradFunc:(t,e,n)=>{const[r,i]=e,{axis:a}=n,s=K(a,r.shape)[0];return{x:()=>{const e=r.shape,n=i.size,o=e.slice(0,s),u=o.length,l=e.slice(a,e.length).slice(1),c=l.length,h=Dn(0,u),p=Dn(u+1,u+1+c),d=Ln([o,[n],l]),f=ge(t,d),g=ge(i,[n]),m=Ln([[u],h,p]),y=dn(f,m);let v=En(y,g,r.shape[s]);const b=hn(m);return v=dn(v,b),v},indices:()=>i}}};function Dn(t,e){const n=[];for(let r=t;r<e;++r)n.push(r);return n}function Ln(t){const e=[];for(let n=0;n<t.length;++n)for(let r=0;r<t[n].length;++r)e.push(t[n][r]);return e}const _n={kernelName:m,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e;return{a:()=>be(n),b:()=>be(r)}}},Rn={kernelName:y,gradFunc:t=>({x:()=>Qt(t,"float32")})},On={kernelName:"IsFinite",gradFunc:t=>({x:()=>be(t)})},Mn={kernelName:"IsInf",gradFunc:t=>({x:()=>be(t)})},Bn={kernelName:"IsNan",gradFunc:t=>({x:()=>be(t)})};const Pn=Xt({greater_:function(t,e){let n=Zt(t,"a","greater","string_or_numeric"),r=Zt(e,"b","greater","string_or_numeric");[n,r]=Pt(n,r),fe(n.shape,r.shape);const i={a:n,b:r};return Kt.runKernel("Greater",i)}}),$n={kernelName:"LeakyRelu",inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{alpha:i}=n,a=Pn(r,0);return{x:()=>Ve(a,t,te(t,i))}}},Wn={kernelName:"Log1p",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>ie(t,Ne(n,1))}}},Un={kernelName:"Log",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>ie(t,Qt(n,"float32"))}}},jn={kernelName:"LogSoftmax",inputsToSave:[],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[r]=e,{axis:i}=n;return{logits:()=>{const e=wn(r);return ce(t,te(me(t,i,!0),e))}}}};const Vn=Xt({localResponseNormalizationBackprop_:function(t,e,n,r=5,i=1,a=1,s=.5){const o={x:t,y:e,dy:n},u={depthRadius:r,bias:i,alpha:a,beta:s};return Kt.runKernel("LRNGrad",o,u)}}),Kn={kernelName:"LRN",inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[r,i]=e,{depthRadius:a,bias:s,alpha:o,beta:u}=n;return{x:()=>Vn(r,i,t,a,s,o,u)}}};const qn=Xt({equal_:function(t,e){let n=Zt(t,"a","equal","string_or_numeric"),r=Zt(e,"b","equal","string_or_numeric");[n,r]=Pt(n,r),fe(n.shape,r.shape);const i={a:n,b:r};return Kt.runKernel("Equal",i)}});function Gn(t,e,n,r){return e.rank<n.rank&&(e=ge(e,cn(e.shape,r))),t.rank<n.rank&&(t=ge(t,cn(t.shape,r))),{x:()=>te(t,Qt(qn(n,e),t.dtype))}}const Hn={kernelName:"Max",inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const r=n,{reductionIndices:i}=r,a=e[0],s=Gn(t,e[1],a,K(i,a.shape));return{x:()=>s.x()}}};const Jn=Xt({less_:function(t,e){let n=Zt(t,"a","less","string_or_numeric"),r=Zt(e,"b","less","string_or_numeric");[n,r]=Pt(n,r),fe(n.shape,r.shape);const i={a:n,b:r};return Kt.runKernel("Less",i)}}),Zn={kernelName:v,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e;return{a:()=>te(t,Qt(Pe(n,r),"float32")),b:()=>te(t,Qt(Jn(n,r),"float32"))}}};const Yn=Xt({maxPool3dGrad_:function(t,e,n,r,i,a,s){const o=Zt(t,"dy","maxPool3dGrad"),u=Zt(e,"input","maxPool3dGrad"),l=Zt(n,"output","maxPool3dGrad");let c=o,h=u,p=l,d=!1;4===u.rank&&(d=!0,c=ge(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),h=ge(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]]),p=ge(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]])),P(5===c.rank,(()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`)),P(5===h.rank,(()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${h.rank}.`)),P(5===p.rank,(()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${p.rank}.`)),null!=s&&P(j(a),(()=>`Error in maxPool3dGrad: pad must be an integer when using, dimRoundingMode ${s} but got pad ${a}.`));const f={dy:c,input:h,output:p},g={filterSize:r,strides:i,pad:a,dimRoundingMode:s},m=Kt.runKernel("MaxPool3DGrad",f,g);return d?ge(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}}),Xn={kernelName:"MaxPool3D",inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[r,i]=e,{filterSize:a,strides:s,pad:o,dimRoundingMode:u}=n;return{x:()=>Yn(t,r,i,a,s,o,u)}}};const Qn=Xt({maxPoolGrad_:function(t,e,n,r,i,a,s){const o=Zt(t,"dy","maxPoolGrad"),u=Zt(e,"input","maxPoolGrad"),l=Zt(n,"output","maxPoolGrad");P(u.rank===o.rank,(()=>`Rank of input (${u.rank}) does not match rank of dy (${o.rank})`)),P(4===o.rank,(()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${o.rank}.`)),P(4===u.rank,(()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${u.rank}.`)),null!=s&&P(j(a),(()=>`Error in maxPoolGrad: pad must be an integer when using, dimRoundingMode ${s} but got pad ${a}.`));const c={dy:o,input:u,output:l},h={filterSize:r,strides:i,pad:a,dimRoundingMode:s};return Kt.runKernel("MaxPoolGrad",c,h)}}),tr={kernelName:"MaxPool",inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[r,i]=e,{filterSize:a,strides:s,pad:o}=n;return{x:()=>Qn(t,r,i,a,s,o)}}};const er=Xt({complex_:function(t,e){const n=Zt(t,"real","complex"),r=Zt(e,"imag","complex");!function(t,e,n=""){P(U(t,e),(()=>n+` Shapes ${t} and ${e} must match`))}(n.shape,r.shape,`real and imag shapes, ${n.shape} and ${r.shape}, must match in call to tf.complex().`);const i={real:n,imag:r};return Kt.runKernel("Complex",i)}});function nr(t,e="float32"){if("complex64"===e){const e=nr(t,"float32"),n=nr(t,"float32");return er(e,n)}const n=et(W(t),e);return Kt.makeTensor(n,t,e)}function rr(t,e="float32"){if("complex64"===e){const e=rr(t,"float32"),n=nr(t,"float32");return er(e,n)}const n=tt(W(t),e);return Kt.makeTensor(n,t,e)}const ir={kernelName:"Mean",inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{axis:i}=n,a=K(i,r.shape),s=W(function(t,e){const n=[],r=t.length;for(let i=0;i<r;i++)-1===e.indexOf(i)&&n.push(t[i]);return[n,e.map((e=>t[e]))]}(r.shape,a)[1]);return{x:()=>{const e=r.shape.slice();a.forEach((t=>{e[t]=1}));const n=ge(t,e);return ie(te(n,rr(r.shape,"float32")),s)}}}},ar={kernelName:"Min",inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const r=n,{axis:i}=r,[a,s]=e,o=Gn(t,s,a,K(i,a.shape));return{x:()=>o.x()}}},sr={kernelName:"Minimum",inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e;return{a:()=>te(t,Qt($e(n,r),"float32")),b:()=>te(t,Qt(Pn(n,r),"float32"))}}};const or=Xt({slice_:function(t,e,n){const r=Zt(t,"x","slice","string_or_numeric");if(0===r.rank)throw new Error("Slicing scalar is not possible");const i={x:r},a={begin:e,size:n};return Kt.runKernel(I,i,a)}}),ur={kernelName:"MirrorPad",inputsToSave:["x"],gradFunc:(t,e,n)=>{const r=e[0],{paddings:i}=n,a=i.map((t=>t[0]));return{x:()=>or(t,a,r.shape)}}};const lr=Xt({floor_:function(t){const e={x:Zt(t,"x","floor")};return Kt.runKernel(d,e)}}),cr={kernelName:"Mod",inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,i=fe(n.shape,r.shape);return{a:()=>{const e=de(n.shape,i);return e.length>0?ge(me(t,e),n.shape):t},b:()=>{const e=te(t,ae(lr(ie(n,r)))),a=de(r.shape,i);return a.length>0?ge(me(e,a),r.shape):e}}}},hr={kernelName:b,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,i=fe(n.shape,r.shape);return{a:()=>{const e=te(t,Qt(r,"float32")),a=de(n.shape,i);return a.length>0?ge(me(e,a),n.shape):e},b:()=>{const e=te(t,Qt(n,"float32")),a=de(r.shape,i);return a.length>0?ge(me(e,a),r.shape):e}}}},pr={kernelName:"Neg",gradFunc:t=>({x:()=>ae(t)})},dr={kernelName:"OneHot",inputsToSave:["indices"],gradFunc:(t,e)=>{const n=e[0];return{indices:()=>nr(n.shape,"float32")}}},fr={kernelName:"OnesLike",gradFunc:t=>({x:()=>be(t)})};const gr=Xt({unstack_:function(t,e=0){const n=Zt(t,"x","unstack","string_or_numeric");P(e>=-n.shape.length&&e<n.shape.length,(()=>`Axis = ${e} is not in [-${n.shape.length}, ${n.shape.length})`));const r={value:n},i={axis:e};return Kt.runKernel(_,r,i)}}),mr={kernelName:w,saveAllInputs:!0,gradFunc:(t,e,n)=>{const{axis:r}=n;return gr(t,r).map((t=>()=>t))}},yr={kernelName:k,inputsToSave:["x"],gradFunc:(t,e,n)=>{const r=e[0],{paddings:i}=n,a=i.map((t=>t[0]));return{x:()=>or(t,a,r.shape)}}};const vr=Xt({log_:function(t){const e={x:Zt(t,"x","log")};return Kt.runKernel("Log",e)}});const br=Xt({pow_:function(t,e){let n=Zt(t,"base","pow"),r=Zt(e,"exp","pow");[n,r]=Pt(n,r);const i={a:n,b:r};return Kt.runKernel("Pow",i)}}),wr={kernelName:"Pow",inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(t,e)=>{const[n,r,i]=e,a=n,s=r,o=fe(a.shape,s.shape);return{a:()=>{const e=Qt(s,"float32");let n=te(t,te(e,br(a,ce(e,oe(1)))));const r=de(a.shape,o);return r.length>0&&(n=me(n,r)),ge(n,a.shape)},b:()=>{const e=Pn(a,0),n=Ve(e,vr(a),be(a));let r=te(t,te(i,n));const u=de(s.shape,o);return u.length>0&&(r=me(r,u)),ge(r,s.shape)}}}},kr={kernelName:"Prelu",inputsToSave:["x","alpha"],gradFunc:(t,e)=>{const[n,r]=e,i=Pn(n,0);return{x:()=>Ve(i,t,te(t,r)),alpha:()=>{let e=Ve(i,be(t),te(t,n));const a=de(r.shape,t.shape);return a.length>0&&(e=me(e,a)),ge(e,r.shape)}}}},Sr={kernelName:h,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,i=fe(n.shape,r.shape);return{a:()=>{const e=ie(t,Qt(r,"float32")),a=de(n.shape,i);return a.length>0?ge(me(e,a),n.shape):e},b:()=>{let e=te(t,Qt(n,"float32"));const a=de(r.shape,i);a.length>0&&(e=ge(me(e,a),r.shape));const s=le(r);return ae(ie(e,Qt(s,"float32")))}}}},Nr={kernelName:"Reciprocal",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>ie(t,ae(le(n)))}}},xr={kernelName:"Relu6",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e,r=te($e(n,6),ee(n));return{x:()=>te(t,Qt(r,"float32"))}}},zr={kernelName:"Relu",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>te(t,Qt(ee(n),"float32"))}}},Ir={kernelName:S,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>ge(t,n.shape)}}},Ar={kernelName:"ResizeBilinear",inputsToSave:["images"],gradFunc:(t,e,n)=>{const[r]=e,i={dy:t,images:r};return{images:()=>Kt.runKernel("ResizeBilinearGrad",i,n)}}},Cr={kernelName:"ResizeNearestNeighbor",inputsToSave:["images"],gradFunc:(t,e,n)=>{const[r]=e,i={dy:t,images:r};return{images:()=>Kt.runKernel("ResizeNearestNeighborGrad",i,n)}}};const Tr=Xt({reverse_:function(t,e){const n={x:Zt(t,"x","reverse")},r={dims:e};return Kt.runKernel(N,n,r)}}),Er={kernelName:N,gradFunc:(t,e,n)=>{const{dims:r}=n,i=K(r,t.shape);return{x:()=>Tr(t,i)}}},Fr={kernelName:"Round",gradFunc:t=>({x:()=>be(t)})},Dr={kernelName:x,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>ae(ie(t,te(br(n,1.5),2)))}}};const Lr=Xt({logicalNot_:function(t){const e={x:Zt(t,"x","logicalNot","bool")};return Kt.runKernel("LogicalNot",e)}}),_r={kernelName:z,inputsToSave:["condition"],gradFunc:(t,e)=>{const[n]=e;return{condition:()=>Qt(be(n),"float32"),t:()=>te(t,Qt(n,t.dtype)),e:()=>te(t,Qt(Lr(n),t.dtype))}}},Rr={kernelName:"Selu",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const e=Pn(n,oe(0)),r=oe(1.7580993408473768),i=oe(1.0507009873554805),a=te(t,i),s=te(te(t,r),wn(Qt(n,"float32")));return Ve(e,a,s)}}}},Or={kernelName:C,outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e;return{x:()=>te(t,te(n,ce(oe(1),n)))}}},Mr={kernelName:"Sign",gradFunc:t=>({x:()=>be(t)})};const Br=Xt({cos_:function(t){const e={x:Zt(t,"x","cos")};return Kt.runKernel("Cos",e)}}),Pr={kernelName:"Sin",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>te(Br(Qt(n,"float32")),t)}}};const $r=Xt({cosh_:function(t){const e={x:Zt(t,"x","cosh")};return Kt.runKernel(l,e)}}),Wr={kernelName:A,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>te($r(Qt(n,"float32")),t)}}};const Ur=Xt({pad_:function(t,e,n=0){const r=Zt(t,"x","pad");if(0===r.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const i={paddings:e,constantValue:n},a={x:r};return Kt.runKernel(k,a,i)}});const jr={kernelName:I,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{begin:i,size:a}=n,s=r.shape,[o,u]=function(t,e,n){let r;const i=t.shape.length;let a;return r="number"==typeof e?[e,...new Array(i-1).fill(0)]:e.length<i?e.concat(new Array(i-e.length).fill(0)):e.slice(),r.forEach((t=>{P(-1!==t,(()=>"slice() does not support negative begin indexing."))})),a=null==n?new Array(i).fill(-1):"number"==typeof n?[n,...new Array(i-1).fill(-1)]:n.length<i?n.concat(new Array(i-n.length).fill(-1)):n,a=a.map(((e,n)=>e>=0?e:(P(-1===e,(()=>`Negative size values should be exactly -1 but got ${e} for the slice() size at index ${n}.`)),t.shape[n]-r[n]))),[r,a]}(r,i,a),l=[];for(let e=0;e<t.rank;e++)l.push([o[e],s[e]-o[e]-u[e]]);return{x:()=>Ur(t,l)}}},Vr={kernelName:"Softmax",outputsToSave:[!0],gradFunc:(t,e,n)=>{const[r]=e,{dim:i}=n,a=te(t,r);return{logits:()=>ce(a,te(me(a,[i],true),r))}}};const Kr=Xt({sigmoid_:function(t){const e={x:Zt(t,"x","sigmoid")};return Kt.runKernel(C,e)}}),qr={kernelName:"Softplus",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>te(t,Kr(n))}}};const Gr=Xt({batchToSpaceND_:function(t,e,n){const r=Zt(t,"x","batchToSpaceND"),a=e.reduce(((t,e)=>t*e));P(r.rank>=1+e.length,(()=>`input rank is ${r.rank} but should be > than blockShape.length ${e.length}`)),P(n.length===e.length,(()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${e.length}`)),P(r.shape[0]%a==0,(()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(" * ")} === ${a}`));const s={x:r},o={blockShape:e,crops:n};return Kt.runKernel(i,s,o)}}),Hr={kernelName:E,gradFunc:(t,e,n)=>{const{blockShape:r,paddings:i}=n;return{x:()=>Gr(t,r,i)}}};const Jr=Xt({concat_:function(t,e=0){P(t.length>=1,(()=>"Pass at least one tensor to concat"));const n=Yt(t,"tensors","concat","string_or_numeric");if("complex64"===n[0].dtype&&n.forEach((t=>{if("complex64"!==t.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${t.dtype}. `)})),1===n.length)return Ue(n[0]);const r=n,i={axis:e};return Kt.runKernel(s,r,i)}}),Zr={kernelName:F,gradFunc:(t,e,n)=>{const{axis:r}=n;return{x:()=>Jr(t,r)}}},Yr={kernelName:T,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>ie(t,te(ue(Qt(n,"float32")),2))}}},Xr={kernelName:"Square",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>te(t,te(Qt(n,"float32"),2))}}},Qr={kernelName:"SquaredDifference",inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,i=oe(2);return{a:()=>te(t,te(i,ce(n,r))),b:()=>te(t,te(i,ce(r,n)))}}},ti={kernelName:M,gradFunc:t=>({x:()=>be(t)})},ei={kernelName:"Sub",inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,i=fe(n.shape,r.shape);return{a:()=>{let e=t;const r=de(n.shape,i);return r.length>0&&(e=me(e,r)),ge(e,n.shape)},b:()=>{let e=t;const n=de(r.shape,i);return n.length>0&&(e=me(e,n)),ge(ae(e),r.shape)}}}},ni={kernelName:"Sum",inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,i=r.shape.slice(),{axis:a}=n;K(a,r.shape).forEach((t=>{i[t]=1}));const s=ge(t,i),o=te(s,rr(r.shape,"float32"));return{x:()=>o}}},ri={kernelName:"Tan",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>ie(t,le(Br(n)))}}},ii={kernelName:"Tanh",outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e;return{x:()=>te(ce(oe(1),le(n)),t)}}},ai={kernelName:D,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{reps:i}=n;return{x:()=>{let e=be(r);if(1===r.rank)for(let n=0;n<i[0];++n)e=Ne(e,or(t,[n*r.shape[0]],[r.shape[0]]));else if(2===r.rank)for(let n=0;n<i[0];++n)for(let a=0;a<i[1];++a)e=Ne(e,or(t,[n*r.shape[0],a*r.shape[1]],[r.shape[0],r.shape[1]]));else if(3===r.rank)for(let n=0;n<i[0];++n)for(let a=0;a<i[1];++a)for(let s=0;s<i[2];++s)e=Ne(e,or(t,[n*r.shape[0],a*r.shape[1],s*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else{if(4!==r.rank)throw new Error(`Gradient for tile operation is not implemented for rank-${r.rank} tensors yet.`);for(let n=0;n<i[0];++n)for(let a=0;a<i[1];++a)for(let s=0;s<i[2];++s)for(let o=0;o<i[3];++o)e=Ne(e,or(t,[n*r.shape[0],a*r.shape[1],s*r.shape[2],o*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]))}return e}}}},si={kernelName:L,gradFunc:(t,e,n)=>{const r=n,{perm:i}=r,a=hn(i);return{x:()=>dn(t,a)}}};const oi=Xt({stack_:function(t,e=0){const n=Yt(t,"tensors","stack","string_or_numeric");P(n.length>=1,(()=>"Pass at least one tensor to tf.stack")),n.length>0&&P(e<=n[0].rank,(()=>"Axis must be <= rank of the tensor"));const r=n,i={axis:e};return Kt.runKernel(w,r,i)}}),ui={kernelName:_,gradFunc:(t,e,n)=>{const r=n,{axis:i}=r;return{value:()=>oi(t,i)}}};const li=Xt({expandDims_:function(t,e=0){const n=Zt(t,"x","expandDims","string_or_numeric");P(e<=n.rank,(()=>"Axis must be <= rank of the tensor"));const r={input:n},i={dim:e};return Kt.runKernel(p,r,i)}});const ci=Xt({gather_:function(t,e,n=0,r=0){const i={x:Zt(t,"x","gather"),indices:Zt(e,"indices","gather","int32")},a={axis:n,batchDims:r};return Kt.runKernel(g,i,a)}});const hi=Xt({maximum_:function(t,e){let n=Zt(t,"a","maximum"),r=Zt(e,"b","maximum");[n,r]=Pt(n,r),"bool"===n.dtype&&(n=Qt(n,"int32"),r=Qt(r,"int32")),fe(n.shape,r.shape);const i={a:n,b:r};return Kt.runKernel(v,i)}});const pi=[ne,he,pe,ye,ve,we,ke,Se,xe,ze,Ie,Ae,Te,Fe,Le,Re,Oe,Me,Be,Ke,qe,He,en,Qe,an,on,ln,fn,yn,vn,Sr,bn,kn,Sn,Nn,xn,In,zn,Tn,Fn,_n,Rn,On,Mn,Bn,$n,Wn,Un,jn,Kn,Hn,Hn,Zn,Xn,tr,ir,ar,sr,ur,cr,hr,pr,dr,fr,mr,yr,yr,wr,kr,Nr,xr,zr,Ir,Ar,Cr,Er,Fr,Dr,_r,Rr,Or,Mr,Pr,Wr,jr,Vr,qr,Hr,Hr,Zr,Zr,Yr,Qr,Xr,ti,ei,ni,ri,ii,ai,si,ui,{kernelName:R,inputsToSave:["segmentIds"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>function(t,e){const n=hi(e,be(e)),r=ci(t,n);let i=Pe(e,oe(0,"int32"));const a=r.rank-i.rank;for(let t=0;t<a;++t)i=li(i,t+1);i=We(i,rr(r.shape,"bool"));const s=be(r);return Ve(i,r,s)}(t,n)}}},{kernelName:O,gradFunc:t=>({x:()=>be(t)})}];for(const t of pi)yt(t);var di=function(t,e){return(di=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e}||function(t,e){for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n])})(t,e)};function fi(t,e){function n(){this.constructor=t}di(t,e),t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)}var gi,mi=function(){return(mi=Object.assign||function(t){for(var e,n=1,r=arguments.length;n<r;n++)for(var i in e=arguments[n])Object.prototype.hasOwnProperty.call(e,i)&&(t[i]=e[i]);return t}).apply(this,arguments)};function yi(t,e,n,r){return new(n||(n=Promise))((function(i,a){function s(t){try{u(r.next(t))}catch(t){a(t)}}function o(t){try{u(r.throw(t))}catch(t){a(t)}}function u(t){var e;t.done?i(t.value):(e=t.value,e instanceof n?e:new n((function(t){t(e)}))).then(s,o)}u((r=r.apply(t,e||[])).next())}))}function vi(t,e){var n,r,i,a,s={label:0,sent:function(){if(1&i[0])throw i[1];return i[1]},trys:[],ops:[]};return a={next:o(0),throw:o(1),return:o(2)},"function"==typeof Symbol&&(a[Symbol.iterator]=function(){return this}),a;function o(a){return function(o){return function(a){if(n)throw new TypeError("Generator is already executing.");for(;s;)try{if(n=1,r&&(i=2&a[0]?r.return:a[0]?r.throw||((i=r.return)&&i.call(r),0):r.next)&&!(i=i.call(r,a[1])).done)return i;switch(r=0,i&&(a=[2&a[0],i.value]),a[0]){case 0:case 1:i=a;break;case 4:return s.label++,{value:a[1],done:!1};case 5:s.label++,r=a[1],a=[0];continue;case 7:a=s.ops.pop(),s.trys.pop();continue;default:if(!(i=s.trys,(i=i.length>0&&i[i.length-1])||6!==a[0]&&2!==a[0])){s=0;continue}if(3===a[0]&&(!i||a[1]>i[0]&&a[1]<i[3])){s.label=a[1];break}if(6===a[0]&&s.label<i[1]){s.label=i[1],i=a;break}if(i&&s.label<i[2]){s.label=i[2],s.ops.push(a);break}i[2]&&s.ops.pop(),s.trys.pop();continue}a=e.call(t,s)}catch(t){a=[6,t],r=0}finally{n=i=0}if(5&a[0])throw a[1];return{value:a[0]?a[1]:void 0,done:!0}}([a,o])}}}function bi(){return null==gi&&(gi=e.backend().epsilon()),gi}var wi=function(t){function e(n){var r=t.call(this,n)||this;return Object.setPrototypeOf(r,e.prototype),r}return fi(e,t),e}(Error),ki=function(t){function e(n){var r=t.call(this,n)||this;return Object.setPrototypeOf(r,e.prototype),r}return fi(e,t),e}(Error),Si=function(t){function e(n){var r=t.call(this,n)||this;return Object.setPrototypeOf(r,e.prototype),r}return fi(e,t),e}(Error),Ni=function(t){function e(n){var r=t.call(this,n)||this;return Object.setPrototypeOf(r,e.prototype),r}return fi(e,t),e}(Error),xi=function(t){function e(n){var r=t.call(this,n)||this;return Object.setPrototypeOf(r,e.prototype),r}return fi(e,t),e}(Error);!function(t){function e(n){var r=t.call(this,n)||this;return Object.setPrototypeOf(r,e.prototype),r}fi(e,t)}(Error);function zi(t,e){if(Array.isArray(t)){for(var n=[],r=0;r<e;r++)n=n.concat(t);return n}return(n=new Array(e)).fill(t),n}function Ii(t,e){if(!t)throw new xi(e)}function Ai(t,e){for(var n=0,r=0,i=t;r<i.length;r++){i[r]===e&&n++}return n}function Ci(t){return 1===t.length?t[0]:t}function Ti(t){return Array.isArray(t)?t:[t]}function Ei(t){var e=t.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==e[0]?e:"private"+e}function Fi(t){return t.length<=1||-1===t.indexOf("_")?t:t.replace(/[_]+(\w|$)/g,(function(t,e){return e.toUpperCase()}))}var Di={};function Li(t){if(null==t)return null;var e={};return e.className=t.getClassName(),e.config=t.getConfig(),e}function _i(t){if(null!=t&&"object"==typeof t)if(Array.isArray(t))t.forEach((function(t){return _i(t)}));else for(var e=0,n=Object.keys(t);e<n.length;e++){var r=n[e],i=t[r];null!=i&&"object"==typeof i&&(Array.isArray(i)||"ndarray"!==i.type||"number"!=typeof i.value?_i(i):t[r]=i.value)}}function Ri(t,e,n,r,i){var a,s,o;if(void 0===e&&(e={}),void 0===n&&(n={}),void 0===r&&(r="object"),void 0===i&&(i=!1),"string"==typeof t){var u=t,l=void 0;if(u in n)l=n[u];else if(u in Di)l=Di[u];else if(null==(l=e[u]))throw new Si("Unknown "+r+": "+t+". This may be due to one of the following reasons:\n1. The "+r+" is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom "+r+" is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().");return l}var c=t;if(null==c.className||null==c.config)throw new Si(r+": Improper config format: "+JSON.stringify(c)+".\n'className' and 'config' must set.");var h=c.className,p=void 0,d=void 0;if(h in n?(p=(a=n[h])[0],d=a[1]):h in Di?(p=(s=Di.className)[0],d=s[1]):h in e&&(p=(o=e[h])[0],d=o[1]),null==p)throw new Si("Unknown "+r+": "+h+". This may be due to one of the following reasons:\n1. The "+r+" is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom "+r+" is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().");if(null!=d){for(var f={},g=0,m=Object.keys(Di);g<m.length;g++){f[S=m[g]]=Di[S]}for(var y=0,v=Object.keys(n);y<v.length;y++){f[S=v[y]]=n[S]}c.config.customObjects=f;for(var b=mi({},Di),w=0,k=Object.keys(n);w<k.length;w++){var S=k[w];Di[S]=n[S]}_i(c.config);var N=d(p,c.config,n,i);return Di=mi({},b),N}b=mi({},Di);for(var x=0,z=Object.keys(n);x<z.length;x++){S=z[x];Di[S]=n[S]}N=new p(c.config);return Di=mi({},b),N}function Oi(t,e){return-1*function(t,e){return t<e?-1:t>e?1:0}(t,e)}function Mi(t){if(null==t)return t;for(var e=[],n=0,r=t;n<r.length;n++){var i=r[n];-1===e.indexOf(i)&&e.push(i)}return e}function Bi(t){if(null==t)throw new Si("Invalid value in obj: "+JSON.stringify(t));for(var e in t)if(t.hasOwnProperty(e))return!1;return!0}function Pi(t,e,n){if(null!=n&&t.indexOf(n)<0)throw new Si(n+" is not a valid "+e+".  Valid values are "+t+" or null/undefined.")}function $i(t,e,n,r){return void 0===n&&(n=0),void 0===r&&(r=1/0),Ii(n>=0),Ii(r>=n),Array.isArray(t)&&t.length>=n&&t.length<=r&&t.every((function(t){return typeof t===e}))}function Wi(t,n){Array.isArray(t)?(e.util.assert(t.length>0,(function(){return n+" is unexpectedly an empty array."})),t.forEach((function(t,e){return Wi(t,"element "+(e+1)+" of "+n)}))):e.util.assert(Number.isInteger(t)&&t>0,(function(){return"Expected "+n+" to be a positive integer, but got "+Ui(t)+"."}))}function Ui(t){return null===t?"null":Array.isArray(t)?"["+t.map((function(t){return Ui(t)})).join(",")+"]":"string"==typeof t?'"'+t+'"':""+t}function ji(t){return"relu"===t?"relu":"linear"===t?"linear":"elu"===t?"elu":null}function Vi(t,n){return e.tidy((function(){return e.sqrt(e.sum(e.mul(t,t),n,!0))}))}var Ki=function(t){function e(){return null!==t&&t.apply(this,arguments)||this}return fi(e,t),e.prototype.getConfig=function(){return{}},e}(e.serialization.Serializable),qi=function(t){function n(e){var n=t.call(this)||this;return n.defaultMaxValue=2,n.defaultAxis=0,n.maxValue=null!=e.maxValue?e.maxValue:n.defaultMaxValue,n.axis=null!=e.axis?e.axis:n.defaultAxis,n}return fi(n,t),n.prototype.apply=function(t){var n=this;return e.tidy((function(){var r=Vi(t,n.axis),i=e.clipByValue(r,0,n.maxValue);return e.mul(t,e.div(i,e.add(bi(),r)))}))},n.prototype.getConfig=function(){return{maxValue:this.maxValue,axis:this.axis}},n.className="MaxNorm",n}(Ki);e.serialization.registerClass(qi);var Gi=function(t){function n(e){var n=t.call(this)||this;return n.defaultAxis=0,n.axis=null!=e.axis?e.axis:n.defaultAxis,n}return fi(n,t),n.prototype.apply=function(t){var n=this;return e.tidy((function(){return e.div(t,e.add(bi(),Vi(t,n.axis)))}))},n.prototype.getConfig=function(){return{axis:this.axis}},n.className="UnitNorm",n}(Ki);e.serialization.registerClass(Gi);var Hi=function(t){function n(){return null!==t&&t.apply(this,arguments)||this}return fi(n,t),n.prototype.apply=function(t){return e.relu(t)},n.className="NonNeg",n}(Ki);e.serialization.registerClass(Hi);var Ji=function(t){function n(e){var n=t.call(this)||this;return n.defaultMinValue=0,n.defaultMaxValue=1,n.defaultRate=1,n.defaultAxis=0,n.minValue=null!=e.minValue?e.minValue:n.defaultMinValue,n.maxValue=null!=e.maxValue?e.maxValue:n.defaultMaxValue,n.rate=null!=e.rate?e.rate:n.defaultRate,n.axis=null!=e.axis?e.axis:n.defaultAxis,n}return fi(n,t),n.prototype.apply=function(t){var n=this;return e.tidy((function(){var r=Vi(t,n.axis),i=e.add(e.mul(n.rate,e.clipByValue(r,n.minValue,n.maxValue)),e.mul(1-n.rate,r));return e.mul(t,e.div(i,e.add(bi(),r)))}))},n.prototype.getConfig=function(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}},n.className="MinMaxNorm",n}(Ki);e.serialization.registerClass(Ji);var Zi={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function Yi(t){return Li(t)}function Xi(t,n){return void 0===n&&(n={}),Ri(t,e.serialization.SerializationMap.getMap().classNameMap,n,"constraint")}function Qi(t){return null==t?null:"string"==typeof t?Xi({className:t in Zi?Zi[t]:t,config:{}}):t instanceof Ki?t:Xi(t)}var ta={__proto__:null,maxNorm:function(t){return new qi(t)},unitNorm:function(t){return new Gi(t)},nonNeg:function(){return new Hi},minMaxNorm:function(t){return new Ji(t)}},ea=["channelsFirst","channelsLast"],na=["nearest","bilinear"],ra=["valid","same","causal"],ia=["max","avg"],aa=["sum","mul","concat","ave"],sa=new Map;function oa(t){Pi(ea,"DataFormat",t)}function ua(t){Pi(ra,"PaddingMode",t)}function la(t){Pi(ia,"PoolMode",t)}var ca=[];function ha(t,e){ca.push(t);try{var n=e();return ca.pop(),n}catch(t){throw ca.pop(),t}}function pa(t){if(!ga(t))throw new Error("Not a valid tensor name: '"+t+"'");return(0===ca.length?"":ca.join("/")+"/")+t}function da(t){if(!ga(t))throw new Error("Not a valid tensor name: '"+t+"'");sa.has(t)||sa.set(t,0);var e=sa.get(t);if(sa.set(t,sa.get(t)+1),e>0){var n=t+"_"+e;return sa.set(n,1),n}return t}var fa=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function ga(t){return!!t.match(fa)}function ma(t,e,n){null==e&&(e=0),null==n&&(n=t.length);for(var r=1,i=e;i<n;++i)r*=t[i];return r}function ya(t){if(0===t.length)return Number.NaN;for(var e=Number.POSITIVE_INFINITY,n=0;n<t.length;n++){var r=t[n];r<e&&(e=r)}return e}function va(t){if(0===t.length)return Number.NaN;for(var e=Number.NEGATIVE_INFINITY,n=0;n<t.length;n++){var r=t[n];r>e&&(e=r)}return e}function ba(t,e){if(e<t)throw new Si("end ("+e+") < begin ("+t+") is forbidden.");for(var n=[],r=t;r<e;++r)n.push(r);return n}function wa(t,n){return e.cast(t,n)}function ka(t,n){void 0===n&&(n=-1);var r=t.shape.slice();return n<0&&(n=r.length+n+1),r.splice(n,0,1),e.reshape(t,r)}function Sa(t,n,r){return e.tidy((function(){switch(t.rank){case 1:return e.slice1d(t,n,r);case 2:return e.slice2d(t,[n,0],[r,t.shape[1]]);case 3:return e.slice3d(t,[n,0,0],[r,t.shape[1],t.shape[2]]);case 4:return e.slice4d(t,[n,0,0,0],[r,t.shape[1],t.shape[2],t.shape[3]]);case 5:return e.slice(t,[n,0,0,0,0],[r,t.shape[1],t.shape[2],t.shape[3],t.shape[4]]);case 6:return e.slice(t,[n,0,0,0,0,0],[r,t.shape[1],t.shape[2],t.shape[3],t.shape[4],t.shape[5]]);default:throw new Si("sliceAlongFirstAxis() received an unsupported tensor rank: "+t.rank)}}))}function Na(t,n,r){return e.tidy((function(){switch(t.rank){case 1:return e.slice1d(t,n,r);case 2:return e.slice2d(t,[0,n],[t.shape[0],r]);case 3:return e.slice3d(t,[0,0,n],[t.shape[0],t.shape[1],r]);case 4:return e.slice4d(t,[0,0,0,n],[t.shape[0],t.shape[1],t.shape[2],r]);default:throw new Si("sliceAlongLastAxis() received an unsupported tensor rank: "+t.rank)}}))}function xa(t,n,r,i){return e.tidy((function(){switch(t.rank){case 1:return e.slice1d(t,n,r);case 2:switch(i){case 1:return Sa(t,n,r);case 2:return Na(t,n,r);default:throw new Si("The axis is not within the rank of the tensor "+i)}case 3:switch(i){case 1:return Sa(t,n,r);case 2:return e.slice3d(t,[0,n,0],[t.shape[0],r,t.shape[2]]);case 3:return Na(t,n,r);default:throw new Si("The axis is not within the rank of the tensor "+i)}case 4:switch(i){case 1:return Sa(t,n,r);case 2:return e.slice4d(t,[0,n,0,0],[t.shape[0],r,t.shape[2],t.shape[3]]);case 3:return e.slice4d(t,[0,0,n,0],[t.shape[0],t.shape[1],r,t.shape[3]]);case 4:return Na(t,n,r);default:throw new Si("The axis is not within the rank of the tensor "+i)}default:throw new Si("sliceAlongLastAxis() received an unsupported tensor rank: "+t.rank)}}))}function za(t,n){var r;return void 0===n&&(n=-1),n<0&&(n=0!==(r=t[0].rank)?r:0),n===t[0].rank&&(n=-1),e.concat(t,n)}function Ia(t,n){switch(t.rank){case 1:return e.concat1d([t,n]);case 2:return e.concat2d([t,n],0);case 3:return e.concat3d([t,n],0);case 4:return e.concat4d([t,n],0);default:throw new Si("concatAlongFirstAxis() received an unsupported tensor rank: "+t.rank)}}function Aa(t,n){if(Array.isArray(n)||(n=[n]),t.rank!==n.length)throw new Si("The length of input n ("+n.length+") does not match the number of dimensions in input x ("+t.rank+")");return e.tile(t,n)}function Ca(t,n,r,i,a){return void 0===n&&(n=0),void 0===r&&(r=1),e.randomNormal(t,n,r,i,a)}function Ta(t,n,r,i){if(t.rank<2||n.rank<2)throw new Ni("dot requires both inputs to be rank >= 2 but got x shape = "+t.shape+" and y shape = "+n.shape);if(n.rank>=3&&t.shape.slice(-1)[0]!==(h=n.shape.slice(-2)[0]))throw new Ni("If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = "+t.shape+" and  y shape = "+n.shape);if(2===t.rank&&2===n.rank){var a=!1,s=!1;return e.fused.matMul({a:t,b:n,transposeA:a,transposeB:s,bias:i?Da(t.rank,i,"channelsLast"):null,activation:r})}var o=t.shape.slice(),u=o.pop();t=e.reshape(t,[-1,u]);var l=n.shape.slice(),c=l.pop(),h=l.pop(),p=l.concat([c]),d=Array.from({length:n.rank},(function(t,e){return 0===e?n.rank-2:e<=n.rank-2?e-1:e}));n=e.reshape(e.transpose(n,d),[h,-1]);var f=o.concat(p);a=!1,s=!1;return e.reshape(e.fused.matMul({a:t,b:n,transposeA:a,transposeB:s,bias:i?Da(t.rank,i,"channelsLast"):null,activation:r}),f)}function Ea(t,n,r){return e.tidy((function(){return n=Array.isArray(n)?e.tensor1d(n,"int32"):e.cast(n,"int32"),e.gather(t,n,r)}))}function Fa(t){return e.mul(t,t)}function Da(t,n,r){var i=n.shape;if(1!==n.rank&&n.rank!==t)throw new Si("Unexpected bias dimensions: "+n.rank+"; expected it to be 1 or "+t);if(5===t){if("channelsFirst"===r)return 1===i.length?e.reshape(n,[1,i[0],1,1,1]):e.reshape(n,[1,i[3],i[0],i[1],i[2]]);if("channelsLast"===r)return 1===i.length?e.reshape(n,[1,1,1,1,i[0]]):e.reshape(n,[1].concat(i))}else if(4===t){if("channelsFirst"===r)return 1===i.length?e.reshape(n,[1,i[0],1,1]):e.reshape(n,[1,i[2],i[0],i[1]]);if("channelsLast"===r)return 1===i.length?e.reshape(n,[1,1,1,i[0]]):e.reshape(n,[1].concat(i))}else if(3===t){if("channelsFirst"===r)return 1===i.length?e.reshape(n,[1,i[0],1]):e.reshape(n,[1,i[1],i[0]]);if("channelsLast"===r)return 1===i.length?e.reshape(n,[1,1,i[0]]):e.reshape(n,[1].concat(i))}else if(t<3)return n;throw new Si("Unsupported input rank by biasAdd: "+n.rank)}function La(t,n,r){return e.tidy((function(){return null==r&&(r="channelsLast"),oa(r),e.add(t,Da(t.rank,n,r))}))}function _a(t,n,r,i){return e.tidy((function(){return e.dropout(t,n,r,i)}))}function Ra(t,e,n){return void 0===n&&(n=!1),n?t():e()}var Oa=["fanIn","fanOut","fanAvg"],Ma=["normal","uniform","truncatedNormal"];var Ba=function(t){function e(){return null!==t&&t.apply(this,arguments)||this}return fi(e,t),e.prototype.fromConfigUsesCustomObjects=function(){return!1},e.prototype.getConfig=function(){return{}},e}(e.serialization.Serializable),Pa=function(t){function n(){return null!==t&&t.apply(this,arguments)||this}return fi(n,t),n.prototype.apply=function(t,n){return e.zeros(t,n)},n.className="Zeros",n}(Ba);e.serialization.registerClass(Pa);var $a=function(t){function n(){return null!==t&&t.apply(this,arguments)||this}return fi(n,t),n.prototype.apply=function(t,n){return e.ones(t,n)},n.className="Ones",n}(Ba);e.serialization.registerClass($a);var Wa=function(t){function n(e){var n=t.call(this)||this;if("object"!=typeof e)throw new Si("Expected argument of type ConstantConfig but got "+e);if(void 0===e.value)throw new Si("config must have value set but got "+e);return n.value=e.value,n}return fi(n,t),n.prototype.apply=function(t,n){var r=this;return e.tidy((function(){return e.mul(e.scalar(r.value),e.ones(t,n))}))},n.prototype.getConfig=function(){return{value:this.value}},n.className="Constant",n}(Ba);e.serialization.registerClass(Wa);var Ua=function(t){function n(e){var n=t.call(this)||this;return n.DEFAULT_MINVAL=-.05,n.DEFAULT_MAXVAL=.05,n.minval=e.minval||n.DEFAULT_MINVAL,n.maxval=e.maxval||n.DEFAULT_MAXVAL,n.seed=e.seed,n}return fi(n,t),n.prototype.apply=function(t,n){return e.randomUniform(t,this.minval,this.maxval,n)},n.prototype.getConfig=function(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}},n.className="RandomUniform",n}(Ba);e.serialization.registerClass(Ua);var ja=function(t){function e(e){var n=t.call(this)||this;return n.DEFAULT_MEAN=0,n.DEFAULT_STDDEV=.05,n.mean=e.mean||n.DEFAULT_MEAN,n.stddev=e.stddev||n.DEFAULT_STDDEV,n.seed=e.seed,n}return fi(e,t),e.prototype.apply=function(t,e){if("float32"!==(e=e||"float32")&&"int32"!==e)throw new Ni("randomNormal does not support dType "+e+".");return Ca(t,this.mean,this.stddev,e,this.seed)},e.prototype.getConfig=function(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}},e.className="RandomNormal",e}(Ba);e.serialization.registerClass(ja);var Va=function(t){function n(e){var n=t.call(this)||this;return n.DEFAULT_MEAN=0,n.DEFAULT_STDDEV=.05,n.mean=e.mean||n.DEFAULT_MEAN,n.stddev=e.stddev||n.DEFAULT_STDDEV,n.seed=e.seed,n}return fi(n,t),n.prototype.apply=function(t,n){if("float32"!==(n=n||"float32")&&"int32"!==n)throw new Ni("truncatedNormal does not support dType "+n+".");return e.truncatedNormal(t,this.mean,this.stddev,n,this.seed)},n.prototype.getConfig=function(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}},n.className="TruncatedNormal",n}(Ba);e.serialization.registerClass(Va);var Ka=function(t){function n(e){var n=t.call(this)||this;return n.gain=null!=e.gain?e.gain:1,n}return fi(n,t),n.prototype.apply=function(t,n){var r=this;return e.tidy((function(){if(2!==t.length||t[0]!==t[1])throw new Si("Identity matrix initializer can only be used for 2D square matrices.");return e.mul(r.gain,e.eye(t[0]))}))},n.prototype.getConfig=function(){return{gain:this.gain}},n.className="Identity",n}(Ba);e.serialization.registerClass(Ka);var qa=function(t){function n(e){var n,r=t.call(this)||this;if(e.scale<0)throw new Si("scale must be a positive float. Got: "+e.scale);return r.scale=null==e.scale?1:e.scale,r.mode=null==e.mode?"fanIn":e.mode,n=r.mode,Pi(Oa,"FanMode",n),r.distribution=null==e.distribution?"normal":e.distribution,function(t){Pi(Ma,"Distribution",t)}(r.distribution),r.seed=e.seed,r}return fi(n,t),n.prototype.apply=function(t,n){var r=function(t,e){var n,r;if(void 0===e&&(e="channelsLast"),oa(e),2===t.length)n=t[0],r=t[1];else if(-1!==[3,4,5].indexOf(t.length))if("channelsFirst"===e){var i=ma(t,2);n=t[1]*i,r=t[0]*i}else"channelsLast"===e&&(i=ma(t,0,t.length-2),n=t[t.length-2]*i,r=t[t.length-1]*i);else{var a=ma(t);n=Math.sqrt(a),r=Math.sqrt(a)}return[n,r]}(t),i=r[0],a=r[1],s=this.scale;if("fanIn"===this.mode?s/=Math.max(1,i):"fanOut"===this.mode?s/=Math.max(1,a):s/=Math.max(1,(i+a)/2),"normal"===this.distribution){var o=Math.sqrt(s);if("float32"!==(n=n||"float32")&&"int32"!==n)throw new Ni(this.getClassName()+" does not support dType "+n+".");return e.truncatedNormal(t,0,o,n,this.seed)}var u=Math.sqrt(3*s);return e.randomUniform(t,-u,u,n)},n.prototype.getConfig=function(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}},n.className="VarianceScaling",n}(Ba);e.serialization.registerClass(qa);var Ga=function(t){function e(e){return t.call(this,{scale:1,mode:"fanAvg",distribution:"uniform",seed:null==e?null:e.seed})||this}return fi(e,t),e.prototype.getClassName=function(){return qa.className},e.className="GlorotUniform",e}(qa);e.serialization.registerClass(Ga);var Ha=function(t){function e(e){return t.call(this,{scale:1,mode:"fanAvg",distribution:"normal",seed:null==e?null:e.seed})||this}return fi(e,t),e.prototype.getClassName=function(){return qa.className},e.className="GlorotNormal",e}(qa);e.serialization.registerClass(Ha);var Ja=function(t){function e(e){return t.call(this,{scale:2,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})||this}return fi(e,t),e.prototype.getClassName=function(){return qa.className},e.className="HeNormal",e}(qa);e.serialization.registerClass(Ja);var Za=function(t){function e(e){return t.call(this,{scale:2,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})||this}return fi(e,t),e.prototype.getClassName=function(){return qa.className},e.className="HeUniform",e}(qa);e.serialization.registerClass(Za);var Ya=function(t){function e(e){return t.call(this,{scale:1,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})||this}return fi(e,t),e.prototype.getClassName=function(){return qa.className},e.className="LeCunNormal",e}(qa);e.serialization.registerClass(Ya);var Xa=function(t){function e(e){return t.call(this,{scale:1,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})||this}return fi(e,t),e.prototype.getClassName=function(){return qa.className},e.className="LeCunNormal",e}(qa);e.serialization.registerClass(Xa);var Qa=function(t){function n(e){var n=t.call(this)||this;if(n.DEFAULT_GAIN=1,n.gain=null==e.gain?n.DEFAULT_GAIN:e.gain,n.seed=e.seed,null!=n.seed)throw new Ni("Random seed is not implemented for Orthogonal Initializer yet.");return n}return fi(n,t),n.prototype.apply=function(t,n){var r=this;return e.tidy((function(){if(t.length<2)throw new Ni("Shape must be at least 2D.");t[0]*t[1]>2e3&&console.warn("Orthogonal initializer is being called on a matrix with more than 2000 ("+t[0]*t[1]+") elements: Slowness may result.");var n=Ca(t[0]>t[1]?[t[1],t[0]]:t,0,1,"float32"),i=e.linalg.gramSchmidt(n);return t[0]>t[1]&&(i=e.transpose(i)),e.mul(r.gain,i)}))},n.prototype.getConfig=function(){return{gain:this.gain,seed:this.seed}},n.className="Orthogonal",n}(Ba);e.serialization.registerClass(Qa);var ts={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function es(t,n){return void 0===n&&(n={}),Ri(t,e.serialization.SerializationMap.getMap().classNameMap,n,"initializer")}function ns(t){return Li(t)}function rs(t){if("string"==typeof t){var e=t in ts?ts[t]:t;if("GlorotNormal"===e)return new Ha;if("GlorotUniform"===e)return new Ga;if("HeNormal"===e)return new Ja;if("HeUniform"===e)return new Za;if("LeCunNormal"===e)return new Ya;if("LeCunUniform"===e)return new Xa;var n={};return n.className=e,n.config={},es(n)}return t instanceof Ba?t:es(t)}var is={__proto__:null,zeros:function(){return new Pa},ones:function(){return new $a},constant:function(t){return new Wa(t)},randomUniform:function(t){return new Ua(t)},randomNormal:function(t){return new ja(t)},truncatedNormal:function(t){return new Va(t)},identity:function(t){return new Ka(t)},varianceScaling:function(t){return new qa(t)},glorotUniform:function(t){return new Ga(t)},glorotNormal:function(t){return new Ha(t)},heNormal:function(t){return new Ja(t)},heUniform:function(t){return new Za(t)},leCunNormal:function(t){return new Ya(t)},leCunUniform:function(t){return new Xa(t)},orthogonal:function(t){return new Qa(t)}},as=0;function ss(){return as++}var os={};function us(t){return void 0===t&&(t=""),t in os||(os[t]=0),os[t]+=1,t+os[t].toString()}function ls(t){return Array.isArray(t)&&Array.isArray(t[0])}function cs(t){return 0===t.length?[]:Array.isArray(t[0])?t:[t]}function hs(t){var e;if(Array.isArray(t)){if(1!==t.length)throw new Si("Expected Tensor length to be 1; got "+t.length);e=t[0]}else e=t;return e}function ps(t){if(Array.isArray(t)&&Array.isArray(t[0])){if(1===t.length)return(t=t)[0];throw new Si("Expected exactly 1 Shape; got "+t.length)}return t}function ds(t){for(var e=0,n=0,r=t;n<r.length;n++){var i=r[n];0===i.shape.length?e+=1:e+=i.shape.reduce((function(t,e){return t*e}))}return e}var fs="Variable",gs=function(){function t(t,n,r,i,a){void 0===n&&(n="float32"),void 0===r&&(r=fs),void 0===i&&(i=!0),void 0===a&&(a=null),this.dtype=null==n?"float32":n,this.shape=t.shape,this.id=ss(),r=null==r?fs:r,this.originalName=pa(r),this.name=da(this.originalName),this.trainable_=i,this.constraint=a,this.val=e.variable(t,this.trainable_,this.name,this.dtype)}return t.prototype.read=function(){return this.assertNotDisposed(),this.val},t.prototype.write=function(t){return this.assertNotDisposed(),function(t,e){if(t.shape.toString()!==e.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(t.shape)+" vs. "+JSON.stringify(e.shape))}(this.val,t),this.val.id!==t.id&&(this.val.assign(t),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this},t.prototype.dispose=function(){this.assertNotDisposed(),this.val.dispose()},t.prototype.assertNotDisposed=function(){if(this.val.isDisposed)throw new Error("LayersVariable "+this.name+" is already disposed.")},Object.defineProperty(t.prototype,"trainable",{get:function(){return this.trainable_},set:function(t){this.trainable_=t,this.val.trainable=t},enumerable:!0,configurable:!0}),t}();function ms(t){return t.map((function(t){return t.read()}))}function ys(t){t.forEach((function(t){t[0].write(t[1])}))}var vs=function(t){this.dtype=t.dtype,this.shape=t.shape,null!=t.shape?this.ndim=t.shape.length:this.ndim=t.ndim,this.maxNDim=t.maxNDim,this.minNDim=t.minNDim,this.axes=t.axes||{}},bs=function(t,e,n,r,i,a,s){this.dtype=t,this.shape=e,this.sourceLayer=n,this.inputs=r,this.callArgs=i,this.outputTensorIndex=s,this.id=ss(),null!=a&&(this.originalName=pa(a),this.name=da(this.originalName)),this.rank=e.length},ws=0,ks=function(){function t(t,e){this.callArgs=e,this.id=ws++,this.outboundLayer=t.outboundLayer,this.inboundLayers=t.inboundLayers,this.nodeIndices=t.nodeIndices,this.tensorIndices=t.tensorIndices,this.inputTensors=t.inputTensors,this.outputTensors=t.outputTensors,this.inputMasks=t.inputMasks,this.outputMasks=t.outputMasks,this.inputShapes=t.inputShapes,this.outputShapes=t.outputShapes;for(var n=0,r=t.inboundLayers;n<r.length;n++){var i=r[n];null!=i&&i.outboundNodes.push(this)}t.outboundLayer.inboundNodes.push(this)}return t.prototype.getConfig=function(){for(var t=[],e=0,n=this.inboundLayers;e<n.length;e++){var r=n[e];null!=r?t.push(r.name):t.push(null)}return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:t,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}},t}(),Ss=0,Ns=function(t){function n(e){void 0===e&&(e={});var n=t.call(this)||this;n._callHook=null,n._addedWeightNames=[],n._stateful=!1,n.id=Ss++,n.activityRegularizer=null,n.inputSpec=null,n.supportsMasking=!1,n._trainableWeights=[],n._nonTrainableWeights=[],n._losses=[],n._updates=[],n._built=!1,n.inboundNodes=[],n.outboundNodes=[];var r=e.name;if(!r){var i=n.getClassName();r=Ei(i)+"_"+us(i)}if(n.name=r,n.trainable_=null==e.trainable||e.trainable,null!=e.inputShape||null!=e.batchInputShape){var a=void 0;if(null!=e.batchInputShape)a=e.batchInputShape;else if(null!=e.inputShape){var s=null;null!=e.batchSize&&(s=e.batchSize),a=[s].concat(e.inputShape)}n.batchInputShape=a;var o=e.dtype;null==o&&(o=e.inputDType),null==o&&(o="float32"),n.dtype=o}return null!=e.weights?n.initialWeights=e.weights:n.initialWeights=null,n._refCount=null,n.fastWeightInitDuringBuild=!1,n}return fi(n,t),n.nodeKey=function(t,e){return t.name+"_ib-"+e.toString()},n.prototype.getNodeAtIndex=function(t,e){if(0===this.inboundNodes.length)throw new ki("The layer has never been called and thus has no defined "+e+".");if(this.inboundNodes.length<=t)throw new Si("Asked to get "+e+" at node "+t+", but the layer has only "+this.inboundNodes.length+" inbound nodes.");return this.inboundNodes[t]},n.prototype.getInputAt=function(t){return Ci(this.getNodeAtIndex(t,"input").inputTensors)},n.prototype.getOutputAt=function(t){return Ci(this.getNodeAtIndex(t,"output").outputTensors)},Object.defineProperty(n.prototype,"input",{get:function(){if(this.inboundNodes.length>1)throw new wi("Layer "+this.name+' has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use `getInputAt(nodeIndex)` instead.');if(0===this.inboundNodes.length)throw new wi("Layer "+this.name+" is not connected, no input to return.");return Ci(this.getNodeAtIndex(0,"input").inputTensors)},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"output",{get:function(){if(0===this.inboundNodes.length)throw new wi("Layer "+this.name+" has no inbound nodes.");if(this.inboundNodes.length>1)throw new wi("Layer "+this.name+' has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use `getOutputAt(nodeIndex)` instead.');return Ci(this.getNodeAtIndex(0,"output").outputTensors)},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"losses",{get:function(){return this._losses},enumerable:!0,configurable:!0}),n.prototype.calculateLosses=function(){return this.losses.map((function(t){return t()}))},Object.defineProperty(n.prototype,"updates",{get:function(){return this._updates},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"built",{get:function(){return this._built},set:function(t){this._built=t},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"trainable",{get:function(){return this.trainable_},set:function(t){this._trainableWeights.forEach((function(e){return e.trainable=t})),this.trainable_=t},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"trainableWeights",{get:function(){return this.trainable_?this._trainableWeights.filter((function(t){return t.trainable})):[]},set:function(t){this._trainableWeights=t},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"nonTrainableWeights",{get:function(){return this.trainable?this._trainableWeights.filter((function(t){return!t.trainable})).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)},set:function(t){this._nonTrainableWeights=t},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"weights",{get:function(){return this.trainableWeights.concat(this.nonTrainableWeights)},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"stateful",{get:function(){return this._stateful},enumerable:!0,configurable:!0}),n.prototype.resetStates=function(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")},n.prototype.assertInputCompatibility=function(t){if(t=Ti(t),null!=this.inputSpec&&0!==this.inputSpec.length){var e=Ti(this.inputSpec);if(t.length!==e.length)throw new Si("Layer "+this.name+" expects "+e.length+" inputs, but it received "+t.length+" input tensors. Input received: "+t);for(var n=0;n<t.length;n++){var r=t[n],i=e[n];if(null!=i){var a=r.rank;if(null!=i.ndim&&a!==i.ndim)throw new Si("Input "+n+" is incompatible with layer "+this.name+": expected ndim="+i.ndim+", found ndim="+a);if(null!=i.maxNDim&&a>i.maxNDim)throw new Si("Input "+n+" is incompatible with layer "+this.name+": expected max_ndim="+i.maxNDim+", found ndim="+a);if(null!=i.minNDim&&a<i.minNDim)throw new Si("Input "+n+" is incompatible with layer "+this.name+": expected min_ndim="+i.minNDim+", found ndim="+a+".");if(null!=i.dtype&&r.dtype!==i.dtype)throw new Si("Input "+n+" is incompatible with layer "+this.name+" : expected dtype="+i.dtype+", found dtype="+r.dtype+".");if(i.axes){var s=r.shape;for(var o in i.axes){var u=Number(o),l=i.axes[o],c=u>=0?s[u]:s[s.length+u];if(null!=l&&-1===[l,null].indexOf(c))throw new Si("Input "+n+" is incompatible with layer "+this.name+": expected axis "+u+" of input shape to have value "+l+" but got shape "+s+".")}}if(null!=i.shape)for(var h=0;h<i.shape.length;++h){var p=i.shape[h],d=r.shape[h];if(null!=p&&null!=d&&p!==d)throw new Si("Input "+n+" is incompatible with layer "+this.name+": expected shape="+i.shape+", found shape="+r.shape+".")}}}}},n.prototype.call=function(t,e){return t},n.prototype.invokeCallHook=function(t,e){null!=this._callHook&&this._callHook(t,e)},n.prototype.setCallHook=function(t){this._callHook=t},n.prototype.clearCallHook=function(){this._callHook=null},n.prototype.apply=function(t,e){var n=this;e=e||{},this.assertNotDisposed();for(var r=Ti(t),i=!0,a=0,s=r;a<s.length;a++){if(!(s[a]instanceof bs)){i=!1;break}}for(var o=!0,u=0,l=r;u<l.length;u++){if(l[u]instanceof bs){o=!1;break}}if(i===o)throw new Si("Arguments to apply() must be all SymbolicTensors or all Tensors");return ha(this.name,(function(){if(!n.built){n.assertInputCompatibility(t);for(var i=[],a=0,s=Ti(t);a<s.length;a++){var u=s[a];i.push(u.shape)}n.build(Ci(i)),n.built=!0,n.initialWeights&&n.setWeights(n.initialWeights),null===n._refCount&&o&&(n._refCount=1)}if(n.assertInputCompatibility(t),o){for(var l=[],c=0,h=Ti(g=n.call(t,e));c<h.length;c++){var p=h[c];-1!==r.indexOf(p)&&(p=p.clone()),l.push(p)}if(g=Ci(l),null!=n.activityRegularizer)throw new Ni("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return g}var d=function(t){t=Ti(t);for(var e=[],n=0,r=t;n<r.length;n++){var i=r[n];e.push(i.shape)}return Ci(e)}(t),f=n.computeOutputShape(d),g=void 0,m="float32";if(n.warnOnIncompatibleInputShape(Array.isArray(t)?d[0]:d),g=null!=f&&f.length>0&&Array.isArray(f[0])?f.map((function(r,i){return new bs(m,r,n,Ti(t),e,n.name,i)})):new bs(m,f,n,Ti(t),e,n.name),n.addInboundNode(t,g,null,null,d,f,e),n._refCount++,null!=n.activityRegularizer)throw new Ni("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return g}))},n.prototype.warnOnIncompatibleInputShape=function(t){if(null!=this.batchInputShape)if(t.length!==this.batchInputShape.length)console.warn("The rank of the input tensor provided (shape: "+JSON.stringify(t)+") does not match that of the batchInputShape ("+JSON.stringify(this.batchInputShape)+") of the layer "+this.name);else{var e=!1;this.batchInputShape.forEach((function(n,r){null!=n&&null!=t[r]&&t[r]!==n&&(e=!0)})),e&&console.warn("The shape of the input tensor ("+JSON.stringify(t)+") does not match the expectation of layer "+this.name+": "+JSON.stringify(this.batchInputShape))}},Object.defineProperty(n.prototype,"outputShape",{get:function(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new wi("The layer "+this.name+" has never been called and thus has no defined output shape.");for(var t=[],e=0,n=this.inboundNodes;e<n.length;e++){var r=n[e],i=JSON.stringify(r.outputShapes);-1===t.indexOf(i)&&t.push(i)}if(1===t.length){var a=this.inboundNodes[0].outputShapes;return Array.isArray(a)&&Array.isArray(a[0])&&1===a.length?a[0]:a}throw new wi("The layer "+this.name+' has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.')},enumerable:!0,configurable:!0}),n.prototype.countParams=function(){if(!this.built)throw new ki("You tried to call countParams() on "+this.name+", but the layer is not built yet. Build it first by calling build(batchInputShape).");return ds(this.weights)},n.prototype.build=function(t){this.built=!0},n.prototype.getWeights=function(t){return void 0===t&&(t=!1),ms(t?this.trainableWeights:this.weights)},n.prototype.setWeights=function(t){var n=this;e.tidy((function(){var r=n.weights;if(r.length!==t.length)throw new Si('You called setWeights(weights) on layer "'+n.name+'" with a weight list of length '+t.length+", but the layer was expecting "+r.length+" weights. Provided weights: "+t+"...");if(0!==r.length){for(var i=[],a=ms(r),s=0;s<a.length;++s){var o=a[s],u=r[s],l=t[s];if(!e.util.arraysEqual(o.shape,l.shape))throw new Si("Layer weight shape "+o.shape+" not compatible with provided weight shape "+l.shape);i.push([u,l])}ys(i)}}))},n.prototype.addWeight=function(t,e,n,r,i,a,s){if(-1!==this._addedWeightNames.indexOf(t))throw new Si("Duplicate weight name "+t+" for layer "+this.name);this._addedWeightNames.push(t),null==n&&(n="float32"),this.fastWeightInitDuringBuild&&(r=rs("zeros"));var o=r.apply(e,n),u=new gs(o,n,t,a,s);return o.dispose(),null!=i&&this.addLoss((function(){return i.apply(u.read())})),null==a&&(a=!0),a?this._trainableWeights.push(u):this._nonTrainableWeights.push(u),u},n.prototype.setFastWeightInitDuringBuild=function(t){this.fastWeightInitDuringBuild=t},n.prototype.addLoss=function(t){var e;null==t||Array.isArray(t)&&0===t.length||(t=Ti(t),void 0!==this._losses&&null!==this._losses&&(e=this.losses).push.apply(e,t))},n.prototype.computeOutputShape=function(t){return t},n.prototype.computeMask=function(t,e){var n=this;if(!this.supportsMasking){if(null!=e){if(!Array.isArray(e))throw new TypeError("Layer "+this.name+" does not support masking, but was passed an inputMask.");e.forEach((function(t){if(null!=t)throw new TypeError("Layer "+n.name+" does not support masking, but was passed an inputMask.")}))}return null}return e},n.prototype.addInboundNode=function(t,e,n,r,i,a,s){void 0===s&&(s=null);var o=Ti(t);e=Ti(e),n=Ti(n),r=Ti(r),i=cs(i),a=cs(a);for(var u=[],l=[],c=[],h=0,p=o;h<p.length;h++){var d=p[h];u.push(d.sourceLayer),l.push(d.nodeIndex),c.push(d.tensorIndex)}new ks({outboundLayer:this,inboundLayers:u,nodeIndices:l,tensorIndices:c,inputTensors:o,outputTensors:e,inputMasks:n,outputMasks:r,inputShapes:i,outputShapes:a},s);for(var f=0;f<e.length;f++)e[f].sourceLayer=this,e[f].nodeIndex=this.inboundNodes.length-1,e[f].tensorIndex=f},n.prototype.getConfig=function(){var t={name:this.name,trainable:this.trainable};return null!=this.batchInputShape&&(t.batchInputShape=this.batchInputShape),null!=this.dtype&&(t.dtype=this.dtype),t},n.prototype.disposeWeights=function(){return this.weights.forEach((function(t){return t.dispose()})),this.weights.length},n.prototype.assertNotDisposed=function(){if(0===this._refCount)throw new Error("Layer '"+this.name+"' is already disposed.")},n.prototype.dispose=function(){if(!this.built)throw new Error("Cannot dispose Layer "+this.name+" because it has not been built yet.");if(null===this._refCount)throw new Error("Cannot dispose Layer "+this.name+" because it has not been used yet.");this.assertNotDisposed();var t=0;return 0==--this._refCount&&(t=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:t}},n}(e.serialization.Serializable);function xs(t,e,n){if((null==e||null!=n&&n>0)&&(e=t.sourceLayer,n=t.nodeIndex),0===e.inboundNodes.length)return[t];var r=e.inboundNodes[n];if(0===r.inboundLayers.length)return r.inputTensors;for(var i=[],a=0;a<r.inboundLayers.length;a++)for(var s=0,o=xs(r.inputTensors[a],r.inboundLayers[a],r.nodeIndices[a]);s<o.length;s++){var u=o[s];-1===i.indexOf(u)&&i.push(u)}return i}var zs,Is=function(t){function e(e){var n=t.call(this,{dtype:e.dtype,name:null!=e.name?e.name:us("input").toString()})||this;if(null==e.batchSize&&(e.batchSize=null),null==e.sparse&&(e.sparse=!1),n.trainable=!1,n.built=!0,n.sparse=e.sparse,null!=e.inputShape&&null!=e.batchInputShape)throw new Si("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");var r=e.batchInputShape;if(null==r){if(null==e.inputShape)throw new Si("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");r=[e.batchSize].concat(e.inputShape)}else if(null!=e.batchSize)throw new Si("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");var i=e.dtype||"float32";n.batchInputShape=r,n.dtype=i,n.inputSpec=[{shape:r}];var a=new bs(n.dtype,n.batchInputShape,n,[],{},n.name);return a.nodeIndex=0,a.tensorIndex=0,new ks({outboundLayer:n,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[a],outputTensors:[a],inputMasks:[null],outputMasks:[null],inputShapes:[r],outputShapes:[r]}),n}return fi(e,t),e.prototype.apply=function(t,e){throw new Si("Cannot pass any input to an InputLayer's apply() method. InputLayer name: "+this.name)},e.prototype.dispose=function(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}},e.prototype.getConfig=function(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}},e.className="InputLayer",e}(Ns);function As(t){if(null==t.batchShape&&null==t.shape)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(null!=t.batchShape&&null!=t.shape)throw new Si("Please provide either a `shape` or `batchShape` argument to Input, but not both.");var e=t.batchShape;null!=t.shape&&null==e&&(e=[null].concat(t.shape));var n=t.dtype;return null==n&&(n="float32"),new Is({batchInputShape:e,name:t.name,dtype:n,sparse:t.sparse}).inboundNodes[0].outputTensors[0]}function Cs(t){return yi(this,void 0,void 0,(function(){var n,r,i,a,s,o,u,l;return vi(this,(function(c){switch(c.label){case 0:if(null==t)return[2];for(a in n=[],r=[],i=[],t)"number"!=typeof(s=t[a])&&(o=s,n.push(o.data()),r.push(a),i.push(o));return n.length>0?[4,Promise.all(n)]:[3,2];case 1:for(u=c.sent(),l=0;l<u.length;++l)t[r[l]]=u[l][0];e.dispose(i),c.label=2;case 2:return[2]}}))}))}function Ts(t){if(null!=t)for(var e in t){var n=t[e];"number"!=typeof n&&n.dispose()}}e.serialization.registerClass(Is),function(t){t[t.SILENT=0]="SILENT",t[t.VERBOSE=1]="VERBOSE"}(zs||(zs={}));var Es=function(){function t(){this.validationData=null}return t.prototype.setParams=function(t){this.params=t},t.prototype.onEpochBegin=function(t,e){return yi(this,void 0,void 0,(function(){return vi(this,(function(t){return[2]}))}))},t.prototype.onEpochEnd=function(t,e){return yi(this,void 0,void 0,(function(){return vi(this,(function(t){return[2]}))}))},t.prototype.onBatchBegin=function(t,e){return yi(this,void 0,void 0,(function(){return vi(this,(function(t){return[2]}))}))},t.prototype.onBatchEnd=function(t,e){return yi(this,void 0,void 0,(function(){return vi(this,(function(t){return[2]}))}))},t.prototype.onTrainBegin=function(t){return yi(this,void 0,void 0,(function(){return vi(this,(function(t){return[2]}))}))},t.prototype.onTrainEnd=function(t){return yi(this,void 0,void 0,(function(){return vi(this,(function(t){return[2]}))}))},t.prototype.setModel=function(t){},t}(),Fs=function(){function t(t,e){void 0===e&&(e=10),null==t&&(t=[]),this.callbacks=t,this.queueLength=e}return t.prototype.append=function(t){this.callbacks.push(t)},t.prototype.setParams=function(t){for(var e=0,n=this.callbacks;e<n.length;e++){n[e].setParams(t)}},t.prototype.setModel=function(t){for(var e=0,n=this.callbacks;e<n.length;e++){n[e].setModel(t)}},t.prototype.onEpochBegin=function(t,e){return yi(this,void 0,void 0,(function(){var n,r;return vi(this,(function(i){switch(i.label){case 0:null==e&&(e={}),n=0,r=this.callbacks,i.label=1;case 1:return n<r.length?[4,r[n].onEpochBegin(t,e)]:[3,4];case 2:i.sent(),i.label=3;case 3:return n++,[3,1];case 4:return[2]}}))}))},t.prototype.onEpochEnd=function(t,e){return yi(this,void 0,void 0,(function(){var n,r;return vi(this,(function(i){switch(i.label){case 0:null==e&&(e={}),n=0,r=this.callbacks,i.label=1;case 1:return n<r.length?[4,r[n].onEpochEnd(t,e)]:[3,4];case 2:i.sent(),i.label=3;case 3:return n++,[3,1];case 4:return[2]}}))}))},t.prototype.onBatchBegin=function(t,e){return yi(this,void 0,void 0,(function(){var n,r;return vi(this,(function(i){switch(i.label){case 0:null==e&&(e={}),n=0,r=this.callbacks,i.label=1;case 1:return n<r.length?[4,r[n].onBatchBegin(t,e)]:[3,4];case 2:i.sent(),i.label=3;case 3:return n++,[3,1];case 4:return[2]}}))}))},t.prototype.onBatchEnd=function(t,e){return yi(this,void 0,void 0,(function(){var n,r;return vi(this,(function(i){switch(i.label){case 0:null==e&&(e={}),n=0,r=this.callbacks,i.label=1;case 1:return n<r.length?[4,r[n].onBatchEnd(t,e)]:[3,4];case 2:i.sent(),i.label=3;case 3:return n++,[3,1];case 4:return[2]}}))}))},t.prototype.onTrainBegin=function(t){return yi(this,void 0,void 0,(function(){var e,n;return vi(this,(function(r){switch(r.label){case 0:null==t&&(t={}),e=0,n=this.callbacks,r.label=1;case 1:return e<n.length?[4,n[e].onTrainBegin(t)]:[3,4];case 2:r.sent(),r.label=3;case 3:return e++,[3,1];case 4:return[2]}}))}))},t.prototype.onTrainEnd=function(t){return yi(this,void 0,void 0,(function(){var e,n;return vi(this,(function(r){switch(r.label){case 0:null==t&&(t={}),e=0,n=this.callbacks,r.label=1;case 1:return e<n.length?[4,n[e].onTrainEnd(t)]:[3,4];case 2:r.sent(),r.label=3;case 3:return e++,[3,1];case 4:return[2]}}))}))},t}(),Ds=function(t){function n(){return t.call(this)||this}return fi(n,t),n.prototype.onEpochBegin=function(t){return yi(this,void 0,void 0,(function(){return vi(this,(function(t){return this.seen=0,this.totals={},[2]}))}))},n.prototype.onBatchEnd=function(t,n){return yi(this,void 0,void 0,(function(){var t,r,i,a,s=this;return vi(this,(function(o){for(a in null==n&&(n={}),t=null==n.size?0:n.size,this.seen+=t,r=function(r){var a=n[r];if("number"==typeof a)i.totals.hasOwnProperty(r)||(i.totals[r]=0),i.totals[r]=i.totals[r]+a*t;else{var o=void 0;r in i.totals?o=i.totals[r]:i.totals[r]=0;var u=e.tidy((function(){return e.add(s.totals[r],e.mul(a,t))}));i.totals[r]=u,null!=o&&o.dispose()}},i=this,n)r(a);return[2]}))}))},n.prototype.onEpochEnd=function(t,n){return yi(this,void 0,void 0,(function(){var t,r,i,a,s,o=this;return vi(this,(function(u){if(null!=n)for(t=function(t){if(null==r.totals[t])return"continue";"number"==typeof r.totals[t]?n[t]=r.totals[t]/r.seen:e.tidy((function(){var r=e.mul(e.div(1,o.seen),o.totals[t]);n[t]=r,o.totals[t].dispose(),e.keep(n[t])}))},r=this,i=0,a=this.params.metrics;i<a.length;i++)s=a[i],t(s);return[2]}))}))},n}(Es),Ls=function(t){function e(){return null!==t&&t.apply(this,arguments)||this}return fi(e,t),e.prototype.onTrainBegin=function(t){return yi(this,void 0,void 0,(function(){return vi(this,(function(t){return this.epoch=[],this.history={},[2]}))}))},e.prototype.onEpochEnd=function(t,e){return yi(this,void 0,void 0,(function(){var n;return vi(this,(function(r){for(n in null==e&&(e={}),this.epoch.push(t),e)null==this.history[n]&&(this.history[n]=[]),this.history[n].push(e[n]);return[2]}))}))},e.prototype.syncData=function(){return yi(this,void 0,void 0,(function(){var t,e,n,r,i,a,s,o,u;return vi(this,(function(l){switch(l.label){case 0:for(r in t=[],e=[],n=[],this.history)for(i=this.history[r],a=0;a<i.length;++a)"number"!=typeof i[a]&&(s=i[a],t.push(s.data()),e.push(r),n.push(a));return[4,Promise.all(t)];case 1:for(o=l.sent(),u=0;u<o.length;++u)this.history[e[u]][n[u]].dispose(),this.history[e[u]][n[u]]=o[u][0];return[2]}}))}))},e}(Es),_s=function(t){function n(n,r){var i,a,s,o,u=t.call(this)||this;if(u.currentEpoch=0,u.yieldEvery=r||"auto","auto"===u.yieldEvery&&(u.yieldEvery=125),"never"===u.yieldEvery&&null!=n.onYield)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");return e.util.isNumber(u.yieldEvery)&&(u.maybeWait=(i=u.maybeWait.bind(u),a=u.yieldEvery,o=e.util.now(),function(){for(var t=[],n=0;n<arguments.length;n++)t[n]=arguments[n];var r=e.util.now();return r-o<a?s:(o=r,s=i.apply(void 0,t))})),u.trainBegin=n.onTrainBegin,u.trainEnd=n.onTrainEnd,u.epochBegin=n.onEpochBegin,u.epochEnd=n.onEpochEnd,u.batchBegin=n.onBatchBegin,u.batchEnd=n.onBatchEnd,u.yield=n.onYield,u}return fi(n,t),n.prototype.maybeWait=function(t,n,r){return yi(this,void 0,void 0,(function(){var i;return vi(this,(function(a){switch(a.label){case 0:return i=[],null==this.yield?[3,2]:[4,Cs(r)];case 1:a.sent(),i.push(this.yield(t,n,r)),a.label=2;case 2:return i.push(e.nextFrame()),[4,Promise.all(i)];case 3:return a.sent(),[2]}}))}))},n.prototype.onEpochBegin=function(t,e){return yi(this,void 0,void 0,(function(){return vi(this,(function(n){switch(n.label){case 0:return this.currentEpoch=t,null==this.epochBegin?[3,3]:[4,Cs(e)];case 1:return n.sent(),[4,this.epochBegin(t,e)];case 2:n.sent(),n.label=3;case 3:return[2]}}))}))},n.prototype.onEpochEnd=function(t,n){return yi(this,void 0,void 0,(function(){var r;return vi(this,(function(i){switch(i.label){case 0:return r=[],null==this.epochEnd?[3,2]:[4,Cs(n)];case 1:i.sent(),r.push(this.epochEnd(t,n)),i.label=2;case 2:return"epoch"===this.yieldEvery&&r.push(e.nextFrame()),[4,Promise.all(r)];case 3:return i.sent(),[2]}}))}))},n.prototype.onBatchBegin=function(t,e){return yi(this,void 0,void 0,(function(){return vi(this,(function(n){switch(n.label){case 0:return null==this.batchBegin?[3,3]:[4,Cs(e)];case 1:return n.sent(),[4,this.batchBegin(t,e)];case 2:n.sent(),n.label=3;case 3:return[2]}}))}))},n.prototype.onBatchEnd=function(t,n){return yi(this,void 0,void 0,(function(){var r;return vi(this,(function(i){switch(i.label){case 0:return r=[],null==this.batchEnd?[3,2]:[4,Cs(n)];case 1:i.sent(),r.push(this.batchEnd(t,n)),i.label=2;case 2:return"batch"===this.yieldEvery?r.push(e.nextFrame()):e.util.isNumber(this.yieldEvery)&&r.push(this.maybeWait(this.currentEpoch,t,n)),[4,Promise.all(r)];case 3:return i.sent(),[2]}}))}))},n.prototype.onTrainBegin=function(t){return yi(this,void 0,void 0,(function(){return vi(this,(function(e){switch(e.label){case 0:return null==this.trainBegin?[3,3]:[4,Cs(t)];case 1:return e.sent(),[4,this.trainBegin(t)];case 2:e.sent(),e.label=3;case 3:return[2]}}))}))},n.prototype.onTrainEnd=function(t){return yi(this,void 0,void 0,(function(){return vi(this,(function(e){switch(e.label){case 0:return null==this.trainEnd?[3,3]:[4,Cs(t)];case 1:return e.sent(),[4,this.trainEnd(t)];case 2:e.sent(),e.label=3;case 3:return[2]}}))}))},n}(Es);function Rs(t,e){return null==t&&(t={}),t instanceof Es?[t]:Array.isArray(t)&&t[0]instanceof Es?t:Ti(t).map((function(t){return new _s(t,e)}))}var Os=function(){function t(){}return t.registerCallbackConstructor=function(n,r){e.util.assert(n>=0&&Number.isInteger(n),(function(){return"Verbosity level is expected to be an integer >= 0, but got "+n})),t.checkForDuplicate(r),null==t.constructors[n]&&(t.constructors[n]=[]),t.constructors[n].push(r)},t.checkForDuplicate=function(e){for(var n in t.constructors){t.constructors[+n].forEach((function(t){if(t===e)throw new Si("Duplicate callback constructor.")}))}},t.clear=function(){t.constructors={}},t.createCallbacks=function(e){var n=[];for(var r in t.constructors){var i=+r;e>=i&&n.push.apply(n,t.constructors[i])}return n.map((function(t){return new t}))},t.constructors={},t}();function Ms(t,e,n,r,i,a,s,o,u){var l=new Ls,c=[new Ds].concat(Os.createCallbacks(e));null!=t&&c.push.apply(c,t),c.push(l);var h=new Fs(c);return h.setParams({epochs:n,initialEpoch:r,samples:i,steps:a,batchSize:s,verbose:e,doValidation:o,metrics:u}),{callbackList:h,history:l}}function Bs(t,n,r){return void 0===n&&(n={}),void 0===r&&(r=!1),Ri(t,e.serialization.SerializationMap.getMap().classNameMap,n,"layer",r)}function Ps(t,n){return e.tidy((function(){"float32"!==t.dtype&&(t=e.cast(t,"float32"));var r=e.sum(Fa(t),n,!0),i=e.fill(r.shape,bi()),a=e.sqrt(e.maximum(r,i));return e.div(t,a)}))}function $s(t,n){return e.tidy((function(){return e.mean(Fa(e.sub(n,t)),-1)}))}function Ws(t,n){return e.tidy((function(){return e.mean(e.abs(e.sub(n,t)),-1)}))}function Us(t,n){return e.tidy((function(){var r=e.sub(t,n),i=e.clipByValue(e.abs(t),bi(),Number.MAX_VALUE),a=e.abs(e.div(r,i));return e.mul(100,e.mean(a,-1))}))}function js(t,n,r){return void 0===r&&(r=!1),e.tidy((function(){if(r)n=e.softmax(n);else{var i=e.sum(n,n.shape.length-1,!0);n=e.div(n,i)}return n=e.clipByValue(n,bi(),1-bi()),e.neg(e.sum(e.mul(e.cast(t,"float32"),e.log(n)),n.shape.length-1))}))}function Vs(t,n,r){return void 0===r&&(r=!1),e.tidy((function(){var i,a,s=e.cast(e.floor((a=[ma((i=t).shape)],e.reshape(i,a))),"int32"),o=(n=e.clipByValue(n,bi(),1-bi())).shape;return js(e.reshape(e.oneHot(s,o[o.length-1]),o),n,r)}))}function Ks(t,n){return e.tidy((function(){var r;return r=e.clipByValue(n,bi(),1-bi()),r=e.log(e.div(r,e.sub(1,r))),e.mean(function(t,n){if(!e.util.arraysEqual(t.shape,n.shape))throw new Si("logits and labels must have the same shape, but got shapes "+JSON.stringify(t.shape)+" and "+JSON.stringify(n.shape));return e.tidy((function(){var r=e.relu(n),i=e.neg(e.abs(n));return e.add(e.sub(r,e.mul(n,t)),e.log1p(e.exp(i)))}))}(t,r),-1)}))}function qs(t,n){return e.tidy((function(){var r=Ps(t,-1),i=Ps(n,-1),a=e.mul(r,i);return e.neg(e.sum(a,-1))}))}var Gs={meanSquaredError:$s,meanAbsoluteError:Ws,meanAbsolutePercentageError:Us,meanSquaredLogarithmicError:function(t,n){return e.tidy((function(){var r=e.clipByValue(n,bi(),Number.MAX_VALUE),i=e.log(e.add(1,r)),a=e.clipByValue(t,bi(),Number.MAX_VALUE),s=e.log(e.add(1,a));return e.mean(Fa(e.sub(i,s)),-1)}))},squaredHinge:function(t,n){return e.tidy((function(){var r=e.maximum(0,e.sub(1,e.mul(t,n)));return e.mean(Fa(r),-1)}))},hinge:function(t,n){return e.tidy((function(){var r=e.maximum(0,e.sub(1,e.mul(t,n)));return e.mean(r,-1)}))},categoricalHinge:function(t,n){return e.tidy((function(){var r=e.sum(e.mul(t,n),-1),i=e.max(e.mul(e.sub(1,t),n),-1);return e.maximum(0,e.add(1,e.sub(i,r)))}))},logcosh:function(t,n){return e.tidy((function(){var r=Math.log(2),i=e.sub(n,t),a=e.sub(e.add(i,e.softplus(e.mul(-2,i))),r);return e.mean(a,-1)}))},categoricalCrossentropy:js,sparseCategoricalCrossentropy:Vs,binaryCrossentropy:Ks,kullbackLeiblerDivergence:function(t,n){return e.tidy((function(){var r=e.clipByValue(t,bi(),1),i=e.clipByValue(n,bi(),1);return e.sum(e.mul(t,e.log(e.div(r,i))),-1)}))},poisson:function(t,n){return e.tidy((function(){var r=e.log(e.add(bi(),n));return e.mean(e.sub(n,e.mul(t,r)),-1)}))},cosineProximity:qs};function Hs(t){if("string"==typeof t){if(t in Gs)return Gs[t];var e="Unknown loss "+t;throw t.toLowerCase().includes("softmaxcrossentropy")&&(e="Unknown loss "+t+'. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy'),new Si(e)}return t}function Js(t,n){return e.tidy((function(){var r=e.mul(.5,e.onesLike(n)),i=wa(e.greater(n,r),t.dtype);return e.mean(e.equal(t,i),-1)}))}function Zs(t,n){return e.tidy((function(){return wa(e.equal(e.argMax(t,-1),e.argMax(n,-1)),"float32")}))}function Ys(t,n){return e.tidy((function(){return e.cast(e.sum(e.logicalAnd(e.equal(t,1),e.equal(n,1))),"float32")}))}function Xs(t,n){return e.tidy((function(){var r=Ys(t,n),i=function(t,n){return e.tidy((function(){return e.cast(e.sum(e.logicalAnd(e.equal(t,0),e.equal(n,1))),"float32")}))}(t,n),a=e.add(r,i);return e.cast(e.where(e.greater(a,0),e.div(r,a),0),"float32")}))}function Qs(t,n){return e.tidy((function(){var r=Ys(t,n),i=function(t,n){return e.tidy((function(){return e.cast(e.sum(e.logicalAnd(e.equal(t,1),e.equal(n,0))),"float32")}))}(t,n),a=e.add(r,i);return e.cast(e.where(e.greater(a,0),e.div(r,a),0),"float32")}))}function to(t,e){return Ks(t,e)}function eo(t,n){return t.rank===n.rank&&(t=e.squeeze(t,[t.rank-1])),(n=e.argMax(n,-1)).dtype!==t.dtype&&(n=e.cast(n,t.dtype)),e.cast(e.equal(t,n),"float32")}var no=js,ro=Vs,io={binaryAccuracy:Js,categoricalAccuracy:Zs,precision:Xs,categoricalCrossentropy:no,sparseCategoricalCrossentropy:ro,mse:$s,MSE:$s,mae:Ws,MAE:Ws,mape:Us,MAPE:Us,cosine:qs};function ao(t){if(Ii(null!==t,"Unknown LossOrMetricFn "+t),"string"==typeof t)return t;for(var e=void 0,n=0,r=Object.keys(Gs);n<r.length;n++){var i=r[n];if(Gs[i]===t){e=i;break}}if(void 0!==e)return e;for(var a=0,s=Object.keys(io);a<s.length;a++){i=s[a];if(io[i]===t){e=i;break}}return void 0!==e?e:t.name}var so=1048576;function oo(t,e,n){if(void 0===n&&(n=!1),null==t||"object"!=typeof t||Object.getPrototypeOf(t)!==Object.prototype||!uo(t))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){var r=JSON.stringify(t);r.length>so&&console.warn('User-defined metadata of model "'+e+'" is too large in size (length='+r.length+" when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576.")}}function uo(t){if(null===t)return!0;if("object"==typeof t){if(Object.getPrototypeOf(t)===Object.prototype){for(var e=0,n=Object.keys(t);e<n.length;e++){var r=n[e];if("string"!=typeof r)return!1;if(!uo(t[r]))return!1}return!0}if(Array.isArray(t)){for(var i=0,a=t;i<a.length;i++){if(!uo(a[i]))return!1}return!0}return!1}var s=typeof t;return"string"===s||"number"===s||"boolean"===s}function lo(t,e,n,r){void 0===r&&(r=console.log);var i,a=function(t){var e=!0,n=[],r=[];for(var i in t.nodesByDepth)n.push(t.nodesByDepth[i]);for(var a=0,s=n;a<s.length;a++){var o=s[a];if(o.length>1||1===o.length&&o[0].inboundLayers.length>1){e=!1;break}r.push.apply(r,o)}if(e)for(var u=0,l=t.layers;u<l.length;u++){for(var c=!1,h=0,p=l[u].inboundNodes;h<p.length;h++){var d=p[h];if(-1!==r.indexOf(d)){if(c){e=!1;break}c=!0}}if(!e)break}return e}(t),s=["Layer (type)","Output shape","Param #"];if(a?(e=e||65,n=n||[.45,.85,1]):(e=e||98,n=n||[.33,.55,.67,1]),n[n.length-1]<=1&&(n=n.map((function(t){return Math.floor(e*t)}))),!a)for(var o in s.push("Receives inputs"),i=[],t.nodesByDepth)i.push.apply(i,t.nodesByDepth[o]);r("_".repeat(e)),co(s,n,r),r("=".repeat(e));for(var u=t.layers,l=0;l<u.length;++l)a?ho(u[l],n,r):po(u[l],n,i,r),r((l===u.length-1?"=":"_").repeat(e));t.checkTrainableWeightsConsistency();var c=function(t){var e;e=null!=t.collectedTrainableWeights?ds(t.collectedTrainableWeights):ds(t.trainableWeights);return e}(t),h=ds(t.nonTrainableWeights);r("Total params: "+(c+h)),r("Trainable params: "+c),r("Non-trainable params: "+h),r("_".repeat(e))}function co(t,e,n){void 0===n&&(n=console.log);for(var r="",i=0;i<t.length;++i)i>0&&(r=r.slice(0,r.length-1)+" "),r=(r+=t[i]).slice(0,e[i]),r+=" ".repeat(e[i]-r.length);n(r)}function ho(t,e,n){var r;try{r=JSON.stringify(t.outputShape)}catch(t){r="multiple"}co([t.name+" ("+t.getClassName()+")",r,t.countParams().toString()],e,n)}function po(t,e,n,r){var i;try{i=JSON.stringify(t.outputShape)}catch(t){i="multiple"}for(var a=[],s=0,o=t.inboundNodes;s<o.length;s++){var u=o[s];if(!(null!=n&&n.length>0&&-1===n.indexOf(u)))for(var l=0;l<u.inboundLayers.length;++l){var c=u.inboundLayers[l].name,h=u.nodeIndices[l],p=u.tensorIndices[l];a.push(c+"["+h+"]["+p+"]")}}var d=t.name,f=t.getClassName(),g=0===a.length?"":a[0];co([d+" ("+f+")",i,t.countParams().toString(),g],e,r);for(l=1;l<a.length;++l)co(["","","",a[l]],e,r)}function fo(t,e,n){return("inboundNodes"===t||"outputLayers"===t||"inputLayers"===t)&&0===e&&"string"==typeof n}function go(t,e){if(null===t)return null;if("string"==typeof t)return Fi(t);if("number"==typeof t||"boolean"==typeof t)return t;if(t instanceof Array){for(var n=[],r=t.length,i=0;i<r;++i){var a=t[i];fo(e,i,a)?n.push(a):n.push(go(a,e))}return n}for(var s={},o=0,u=Object.keys(t);o<u.length;o++){var l=u[o],c=t[l];if("name"===l&&"string"==typeof c)s[l]=c;else{var h=Fi(l);s[h]=go(c,h)}}return s}function mo(t,e){if(null==t)return null;if("string"==typeof t)return Ei(t);if("number"==typeof t||"boolean"==typeof t)return t;if(t instanceof Array){for(var n=[],r=t.length,i=0;i<r;++i){var a=t[i];fo(e,i,a)?n.push(a):n.push(mo(a,e))}return n}for(var s={},o=0,u=Object.keys(t);o<u.length;o++){var l=u[o],c=t[l],h=Ei(l);s[h]="name"!==l&&"className"!==l||"string"!=typeof c?mo(c,l):c}return s}var yo="3.9.0";var vo=function(){function t(e){if(this.id2Value={},this.id2Mask={},this.name2Id={},e instanceof t)for(var n in e.id2Value)this.id2Value[n]=e.id2Value[n],n in e.id2Mask&&(this.id2Mask[n]=e.id2Mask[n]);else{if(null==e)return;for(var r=0,i=e;r<i.length;r++){var a=i[r];this.add(a.key,a.value)}}}return t.prototype.add=function(t,n,r){if(null!=this.id2Value[t.id])throw new Si("Duplicate key: name="+t.name+", id="+t.id);return this.id2Value[t.id]=function(t,n){if(null==t.dtype||t.dtype===n.dtype)return n;try{return e.cast(n,t.dtype)}catch(e){throw new Si("The dtype of the feed ("+n.dtype+") can not be cast to the dtype of the key '"+t.name+"' ("+t.dtype+").")}}(t,n),this.name2Id[t.name]=t.id,null!=r&&(this.id2Mask[t.id]=r),this},t.prototype.addFeed=function(t){this.add(t.key,t.value)},t.prototype.hasKey=function(t){return null!=this.id2Value[t.id]},t.prototype.names=function(){return Object.keys(this.name2Id)},t.prototype.getValue=function(t){if(t instanceof bs){if(null==this.id2Value[t.id])throw new Si("Nonexistent key: "+t.name);return this.id2Value[t.id]}var e=this.name2Id[t];if(null==e)throw new Si("Feed dict has no SymbolicTensor name: "+t);return this.id2Value[e]},t.prototype.getMask=function(t){if(t instanceof bs){if(null==this.id2Value[t.id])throw new Si("Nonexistent key: "+t.name);return this.id2Mask[t.id]}var e=this.name2Id[t];if(null==e)throw new Si("Feed dict has no SymbolicTensor name: "+t);return this.id2Mask[e]},t.prototype.disposeMasks=function(){null!=this.id2Mask&&e.dispose(this.id2Mask)},t}(),bo={},wo={};function ko(t,n,r,i){for(var a=null!=r&&r.training,s=Array.isArray(t),o=s?t:[t],u=o.map((function(t){return t.name})),l=[],c=n.names(),h=0,p=u;h<p.length;h++){var d=p[h];-1!==c.indexOf(d)?l.push(n.getValue(d)):l.push(null)}null!=i&&(i.maxNumTensors=-1/0,i.minNumTensors=1/0);var f,g,m=u.join(",")+"|"+n.names().join(",");if(null==bo[m]){var y=function(t,n){e.util.assert(null!=t&&t.length>0,(function(){return"Expected at least one fetch, got none"}));var r=[],i={};if(1===t.length){var a=No(t[0],n);r=a.sorted,i=a.recipientMap}else for(var s=new Set,o=0,u=t;o<u.length;o++){for(var l=No(u[o],n),c=l.sorted,h=l.recipientMap,p=0,d=c;p<d.length;p++){var f=d[p];s.has(f.name)||(r.push(f),s.add(f.name))}var g=function(t){null==i[t]&&(i[t]=new Set),h[t].forEach((function(e){return i[t].add(e)}))};for(var m in h)g(m)}return{sorted:r,recipientCounts:So(i)}}(o,n);f=y.sorted,g=y.recipientCounts,bo[m]=f,wo[m]=g}f=bo[m],g={},a||Object.assign(g,wo[m]);for(var v=new vo(n),b=0;b<f.length;++b){if(null!=i){var w=e.memory().numTensors;w>i.maxNumTensors&&(i.maxNumTensors=w),w<i.minNumTensors&&(i.minNumTensors=w)}var k=f[b],S=k.sourceLayer;if(!(S instanceof Is)){for(var N=[],x=[],z=[],I=!1,A=0,C=k.inputs;A<C.length;A++){var T=C[A],E=v.getValue(T),F=v.getMask(T);N.push(E),x.push(F),null!=F&&(I=!0),a||(g[T.name]--,0!==g[T.name]||n.hasKey(T)||-1!==u.indexOf(T.name)||E.isDisposed||!0===T.sourceLayer.stateful||z.push(E))}I&&((r=r||{}).mask=x[0]);var D=Ti(S.apply(N,r)),L=null;S.supportsMasking&&(L=S.computeMask(N,x));for(var _=xo(k),R=Array.isArray(_)?_:[_],O=0;O<R.length;++O){v.hasKey(R[O])||v.add(R[O],D[O],Array.isArray(L)?L[0]:L);var M=u.indexOf(R[O].name);-1!==M&&(l[M]=D[O])}a||e.dispose(z)}}return v.disposeMasks(),s?l:l[0]}function So(t){var e={};for(var n in t)e[n]=t[n].size;return e}function No(t,e){for(var n=new Set,r=[],i={},a=0,s=e.names();a<s.length;a++){var o=s[a];n.add(o)}var u=[],l=[];for(u.push(t);u.length>0;){var c=u[u.length-1];if(n.has(c.name))u.pop();else{var h=l[l.length-1]===u.length-1;if(0===c.inputs.length||h)u.pop(),r.push(c),n.add(c.name),h&&l.pop();else{l.push(u.length-1);for(var p=0,d=c.inputs;p<d.length;p++){var f=d[p];null==i[f.name]&&(i[f.name]=new Set),i[f.name].add(c.name),n.has(f.name)||u.push(f)}}}}return{sorted:r,recipientMap:i}}function xo(t){var e;if(1===t.sourceLayer.inboundNodes.length)e=t.sourceLayer.output;else{for(var n=null,r=0;r<t.sourceLayer.inboundNodes.length;++r)for(var i=0,a=t.sourceLayer.inboundNodes[r].outputTensors;i<a.length;i++){if(a[i].id===t.id){n=r;break}}e=t.sourceLayer.getOutputAt(n)}return e}var zo=function(t){function n(e){var r=t.call(this,{})||this;if(r.containerNodes=new Set,r.name=e.name,null==r.name){var i=r.getClassName().toLowerCase();r.name=us(i)}if(r.supportsMasking=!1,r.trainable_=!0,Array.isArray(e.inputs)?r.inputs=e.inputs.slice():r.inputs=[e.inputs],Array.isArray(e.outputs)?r.outputs=e.outputs.slice():r.outputs=[e.outputs],Mi(r.inputs).length!==r.inputs.length)throw new Si("The list of inputs passed to the model is redundant. All inputs should only appear once. Found: "+r.inputs.map((function(t){return t.name})));Mi(r.outputs).length!==r.outputs.length&&console.warn("The list of outputs passed to the model is redundant. All outputs should only appear once. Found: "+r.outputs.map((function(t){return t.name}))),r.inputLayers=[],r.inputLayersNodeIndices=[],r.inputLayersTensorIndices=[],r.outputLayers=[],r.outputLayersNodeIndices=[],r.outputLayersTensorIndices=[],r.layers=[],r.internalContainerRefs=[];for(var a=0,s=r.outputs;a<s.length;a++){var o=(I=s[a]).sourceLayer,u=I.nodeIndex,l=I.tensorIndex;r.outputLayers.push(o),r.outputLayersNodeIndices.push(u),r.outputLayersTensorIndices.push(l)}for(var c=0,h=r.inputs;c<h.length;c++){o=(I=h[c]).sourceLayer,u=I.nodeIndex,l=I.tensorIndex;Ii(0===u,"input layer has >1 nodes"),Ii(0===l,"input layer has >1 tensors"),r.inputLayers.push(o),r.inputLayersNodeIndices.push(u),r.inputLayersTensorIndices.push(l)}r.inputNames=[],r.outputNames=[],r.feedInputShapes=[],r.feedInputNames=[],r.feedOutputNames=[];for(var p=0;p<r.inputLayers.length;p++){if(!((o=r.inputLayers[p])instanceof Is))throw new TypeError("Input layers to a LayersModel must be InputLayer objects. Received inputs: "+e.inputs+". Input "+p+" (0-based) originates from layer type "+o.getClassName()+".");r.inputNames.push(o.name),r.feedInputShapes.push(o.batchInputShape),r.feedInputNames.push(o.name)}for(var d=0,f=r.outputLayers;d<f.length;d++){o=f[d];r.outputNames.push(o.name)}r.internalInputShapes=r.inputs.map((function(t){return t.shape})),r.internalOutputShapes=r.outputs.map((function(t){return t.shape}));for(var g={},m={},y={},v={},b={},w=[],k=function(t,e,i,a,s,o){null!=a&&null!=s&&null!=o||(a=t.sourceLayer,s=t.nodeIndex,o=t.tensorIndex);var u=a.inboundNodes[s];if(-1!==i.indexOf(u))throw new ki("The tensor "+t.name+' at layer "'+a.name+'" is part of a cycle.');if(-1===e.indexOf(u)){r.containerNodes.add(n.nodeKey(a,s)),a.id in b||(b[a.id]=Object.keys(b).length),-1===i.indexOf(u)&&i.push(u);for(var l=u.inboundLayers.length,c=0;c<l;c++){var h=u.inputTensors[c],p=u.inboundLayers[c],d=u.nodeIndices[c],f=u.tensorIndices[c];k(h,e,i,p,d,f)}for(e.push(u);i.indexOf(u)>=0;)i.splice(i.indexOf(u),1);w.push(u)}},S=[],N=[],x=0,z=r.outputs;x<z.length;x++){var I=z[x];k(I,S,N)}for(var A=0,C=w.slice().reverse();A<C.length;A++){m[(Z=C[A]).id]=Z,Z.id in g||(g[Z.id]=0);var T=g[Z.id],E=null==y[Z.outboundLayer.id]?0:y[Z.outboundLayer.id];T=Math.max(T,E),y[Z.outboundLayer.id]=T,v[Z.outboundLayer.id]=Z.outboundLayer,g[Z.id]=T;for(p=0;p<Z.inboundLayers.length;p++){var F=Z.inboundLayers[p],D=(u=Z.nodeIndices[p],F.inboundNodes[u]),L=null==g[D.id]?0:g[D.id];g[D.id]=Math.max(T+1,L),m[D.id]=D}}var _={};for(var R in g){(T=g[R])in _||(_[T]=[]),_[T].push(m[R])}var O={};for(var M in y){(T=y[M])in O||(O[T]=[]),O[T].push(v[M])}var B=Object.keys(O).map((function(t){return parseInt(t,10)})).sort(Oi);r.layers=[];for(var P=0,$=B;P<$.length;P++){var W=O[T=$[P]];W.sort((function(t,e){var n=b[t.id],r=b[e.id];return n<r?-1:n>r?1:0}));for(var U=0,j=W;U<j.length;U++){(o=j[U])instanceof n&&r.internalContainerRefs.push(o),r.layers.push(o)}}r.layersByDepth=O,B=Object.keys(_).map((function(t){return parseInt(t,10)})).sort(Oi);for(var V=r.inputs.slice(),K=[],q=0,G=B;q<G.length;q++)for(var H=0,J=_[T=G[q]];H<J.length;H++){var Z;if(null!=(o=(Z=J[H]).outboundLayer)){for(var Y=0,X=Z.inputTensors;Y<X.length;Y++){I=X[Y];if(-1===V.indexOf(I))throw new ki("Graph disconnected: cannot obtain value for tensor "+I+' at layer "'+o.name+'". The following previous layers were accessed without issue: '+K)}for(var Q=0,tt=Z.outputTensors;Q<tt.length;Q++){I=tt[Q];V.push(I)}K.push(o.name)}}r.nodesByDepth=_;for(var et=r.layers.map((function(t){return t.name})),nt=function(t){var e=et.filter((function(e){return e===t})).length;if(1!==e)throw new ki('The name "'+t+'" is used '+e+" times in the model. All layer names should be unique. Layer names: "+JSON.stringify(et))},rt=0,it=et;rt<it.length;rt++){nt(it[rt])}return r.outboundNodes=[],r.inboundNodes=[],new ks({outboundLayer:r,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:r.inputs,outputTensors:r.outputs,inputMasks:r.inputs.map((function(t){return null})),outputMasks:r.outputs.map((function(t){return null})),inputShapes:r.inputs.map((function(t){return t.shape})),outputShapes:r.outputs.map((function(t){return t.shape}))}),r.built=!0,r._refCount=1,r}return fi(n,t),n.prototype.assertNotDisposed=function(){if(0===this._refCount)throw new Error("Container '"+this.name+"' is already disposed.")},n.prototype.dispose=function(){this.assertNotDisposed();var t={refCountAfterDispose:null,numDisposedVariables:0};if(0==--this._refCount){for(var e=0,n=this.layers;e<n.length;e++){var r=n[e];t.numDisposedVariables+=r.dispose().numDisposedVariables}for(var i=0,a=this.internalContainerRefs;i<a.length;i++){var s=a[i];t.numDisposedVariables+=s.dispose().numDisposedVariables}}return t.refCountAfterDispose=this._refCount,t},Object.defineProperty(n.prototype,"trainable",{get:function(){return this.trainable_},set:function(t){this.layers.forEach((function(e){e._trainableWeights.forEach((function(e){return e.trainable=t}))})),this.trainable_=t},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"trainableWeights",{get:function(){if(this._trainableWeights.length>0)throw new Si("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];for(var t=[],e=0,n=this.layers;e<n.length;e++){var r=n[e];t=t.concat(r.trainableWeights)}return t},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"nonTrainableWeights",{get:function(){for(var t=[],e=0,n=this.layers;e<n.length;e++){var r=n[e];t.push.apply(t,r.nonTrainableWeights)}if(!this.trainable){for(var i=[],a=0,s=this.layers;a<s.length;a++){r=s[a];i.push.apply(i,r.trainableWeights)}return i.concat(t)}return t},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"weights",{get:function(){return this.trainableWeights.concat(this.nonTrainableWeights)},enumerable:!0,configurable:!0}),n.prototype.loadWeights=function(t,e){void 0===e&&(e=!0);for(var n={},r=0,i=0,a=this.layers;i<a.length;i++)for(var s=0,o=a[i].weights;s<o.length;s++){var u=o[s];if(null!=n[u.originalName])throw new Si("Duplicate weight name: "+u.originalName);n[u.originalName]=u,r++}var l=[];for(var c in t){var h=c;if(null==n[c]){var p=c.split("/");h=p.slice(0,-2).concat([p[p.length-1]]).join("/")}if(null!=n[h])l.push([n[h],t[c]]);else if(e)throw new Si("Provided weight data has no target variable: "+c);delete n[h]}if(e){var d=[];for(var f in n)d.push(f);if(d.length>0)throw new Si(d.length+" of "+r+" weights are not set: "+d)}ys(l)},n.prototype.updatedConfig=function(){var t=this.getConfig(),e={};return e.className=this.getClassName(),e.config=t,e.kerasVersion="tfjs-layers 3.9.0",e.backend="TensorFlow.js",e},n.prototype.toJSON=function(t,e){void 0===e&&(e=!0);var n=mo(this.updatedConfig());return e?JSON.stringify(n):n},n.prototype.call=function(t,n){var r=this;return e.tidy((function(){t=Ti(t);for(var e=new vo,i=0;i<r.inputs.length;++i)e.add(r.inputs[i],t[i]);return ko(r.outputs,e,n)}))},n.prototype.computeMask=function(t,n){var r=this;return e.tidy((function(){var e;return t=Ti(t),e=null==n?zi(null,t.length):Ti(n),r.runInternalGraph(t,e)[1]}))},n.prototype.computeOutputShape=function(t){var e=cs(t);if(e.length!==this.inputLayers.length)throw new Si("Invalid inputShape argument "+t+": model has "+this.inputLayers.length+" tensor inputs.");for(var n={},r=0;r<e.length;r++){var i=this.inputLayers[r],a=e[r];n[N=i.name+"_0_0"]=a}var s=Object.keys(this.nodesByDepth).map((function(t){return parseInt(t,10)})).sort(Oi);if(s.length>1)for(var o=0,u=s;o<u.length;o++)for(var l=u[o],c=0,h=this.nodesByDepth[l];c<h.length;c++){var p=h[c];i=p.outboundLayer;if(-1===this.inputLayers.map((function(t){return t.id})).indexOf(i.id)){for(var d=[],f=0;f<p.inboundLayers.length;f++){var g=p.inboundLayers[f],m=p.nodeIndices[f],y=p.tensorIndices[f],v=n[N=g.name+"_"+m+"_"+y];d.push(v)}var b=cs(i.computeOutputShape(Ci(d))),w=i.inboundNodes.indexOf(p);for(f=0;f<b.length;f++){n[N=i.name+"_"+w+"_"+f]=b[f]}}}var k=[],S=[];for(r=0;r<this.outputLayers.length;r++){i=this.outputLayers[r],w=this.outputLayersNodeIndices[r],y=this.outputLayersTensorIndices[r];var N=i.name+"_"+w+"_"+y;S.push(N)}for(r=0;r<S.length;r++){var x=S[r];Ii(x in n),k.push(n[x])}return Ci(k)},n.prototype.runInternalGraph=function(t,e){null==e&&(e=zi(null,t.length));for(var n={},r=0;r<this.inputs.length;++r){var i=this.inputs[r],a=t[r],s=e[r];n[i.id]=[a,s]}for(var o=0,u=Object.keys(this.nodesByDepth).map((function(t){return parseInt(t,10)})).sort(Oi);o<u.length;o++)for(var l=u[o],c=0,h=this.nodesByDepth[l];c<h.length;c++){for(var p=h[c],d=p.outboundLayer,f=p.inputTensors,g=p.outputTensors,m=new Array,y=0,v=f;y<v.length;y++){(i=v[y]).id in n&&m.push(n[i.id])}if(m.length===f.length){var b={},w=void 0,k=void 0,S=void 0,N=void 0;if(null!=p.callArgs&&(b=p.callArgs),1===m.length){var x=m[0],z=x[0],I=x[1];null==b.mask&&(b.mask=I),S=Ti(d.call(z,b)),N=Ti(d.computeMask(z,I)),w=[z],k=[I]}else w=m.map((function(t){return t[0]})),k=m.map((function(t){return t[1]})),null==b.mask&&(b.mask=k),S=Ti(d.call(w,b)),N=Ti(d.computeMask(w,k));if(d.activityRegularizer)throw new Ni("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(r=0;r<g.length;++r){i=g[r],a=S[r],s=N[r];n[i.id]=[a,s]}}}for(var A=[],C=[],T=[],E=0,F=this.outputs;E<F.length;E++){Ii((i=F[E]).id in n,"Could not compute output "+i.name+" : "+i.id);var D=n[i.id],L=D[0];s=D[1];T.push(L.shape),A.push(L),C.push(s)}return[A,C,T]},n.prototype.buildNodeConversionMap=function(t){for(var e,r={},i=0,a=this.layers;i<a.length;i++){var s=a[i];e=s instanceof n?1:0;for(var o=0;o<s.inboundNodes.length;o++){var u=n.nodeKey(s,o);this.containerNodes.has(u)&&(r[u]=e,e+=1)}}return r},n.prototype.getLayer=function(t,e){if(null!=e){if(this.layers.length<=e)throw new Si("Was asked to retrieve layer at index "+e+", but model only has "+this.layers.length+" layer(s).");return this.layers[e]}if(null==t)throw new Si("Provide either a layer name or layer index");for(var n=0,r=this.layers;n<r.length;n++){var i=r[n];if(i.name===t)return i}throw new Si("No such layer: "+t)},n.prototype.calculateLosses=function(){var t=this;return e.tidy((function(){for(var e=[],r=0,i=t.layers;r<i.length;r++)for(var a=i[r],s=0;s<a.inboundNodes.length;++s){var o=n.nodeKey(a,s);t.containerNodes.has(o)&&e.push.apply(e,a.calculateLosses())}return e}))},n.prototype.getConfig=function(){for(var t={name:this.name},e=this.buildNodeConversionMap(this.layers),r=[],i=0,a=this.layers;i<a.length;i++){for(var s=(w=a[i]).getClassName(),o=w.getConfig(),u=[],l=0;l<w.inboundNodes.length;l++){var c=w.inboundNodes[l],h=n.nodeKey(w,l),p={};if(this.containerNodes.has(h)){if(c.callArgs)try{JSON.stringify(c.callArgs),p=c.callArgs}catch(t){console.warn("Layer "+w.name+" was passed non-serializable keyword arguments: "+c.callArgs+". They will not be included in the serialized model (and thus will be missing at deserialization time)."),p={}}if(c.inboundLayers.length>0){for(var d=[],f=0;f<c.inboundLayers.length;f++){var g=c.inboundLayers[f],m=c.nodeIndices[f],y=c.tensorIndices[f];null==(S=e[n.nodeKey(g,m)])&&(S=0),d.push([g.name,S,y,p])}u.push(d)}}}var v={};v.name=w.name,v.className=s,v.config=o,v.inboundNodes=u,r.push(v)}t.layers=r;var b=[];for(f=0;f<this.inputLayers.length;f++){var w=this.inputLayers[f];m=this.inputLayersNodeIndices[f],h=n.nodeKey(w,m);if(this.containerNodes.has(h)){null==(S=e[h])&&(S=0);y=this.inputLayersTensorIndices[f];b.push([w.name,S,y])}}t.inputLayers=b;var k=[];for(f=0;f<this.outputLayers.length;f++){w=this.outputLayers[f],m=this.outputLayersNodeIndices[f],h=n.nodeKey(w,m);if(this.containerNodes.has(h)){var S;null==(S=e[h])&&(S=0);y=this.outputLayersTensorIndices[f];k.push([w.name,S,y])}}return t.outputLayers=k,t},n.fromConfig=function(t,e,n,r){void 0===r&&(r=!1);var i={},a={};function s(t,e){t.name in a?a[t.name].push(e):a[t.name]=[e]}function o(t,e){for(var n,r=[],a=0,o=e;a<o.length;a++){var u=o[a],l=u[0],c=u[1],h=u[2];if(n=null==u[3]?{}:u[3],!(l in i))return void s(t,e);var p=i[l];if(p.inboundNodes.length<=c)return void s(t,e);var d=p.inboundNodes[c];r.push(d.outputTensors[h])}r.length>0&&t.apply(Ci(r),n)}function u(t){var n=t.name,a=Bs(t,null!=e.customObjects?e.customObjects:{});a.setFastWeightInitDuringBuild(r),i[n]=a,t.inboundNodes.forEach((function(t){if(!(t instanceof Array))throw new Si("Corrupted configuration, expected array for nodeData: "+t);s(a,t)}))}for(var l=e.name,c=e.layers,h=0,p=c;h<p.length;h++){u(g=p[h])}for(;!Bi(a);)for(var d=0,f=c;d<f.length;d++){var g=f[d];if((T=i[g.name]).name in a){var m=a[T.name];delete a[T.name];for(var y=0,v=m;y<v.length;y++){o(T,v[y])}}}for(var b=[],w=[],k=0,S=e.inputLayers;k<S.length;k++){var N=(g=S[k])[0],x=g[1],z=g[2];Ii(N in i);var I=(T=i[N]).inboundNodes[x].outputTensors;b.push(I[z])}for(var A=0,C=e.outputLayers;A<C.length;A++){N=(g=C[A])[0],x=g[1],z=g[2];Ii(N in i);var T;I=(T=i[N]).inboundNodes[x].outputTensors;w.push(I[z])}return new t({inputs:b,outputs:w,name:l})},Object.defineProperty(n.prototype,"stateful",{get:function(){if(this._stateful)throw new Si("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(var t=0,e=this.layers;t<e.length;t++){if(e[t].stateful)return!0}return!1},enumerable:!0,configurable:!0}),n.prototype.resetStates=function(){var t=this;e.tidy((function(){t.layers.forEach((function(t){t.stateful&&t.resetStates()}))}))},n}(Ns);function Io(t,e){return function(t,e,n){var r=e.length;if(null==t||Array.isArray(t)&&0===t.length)return e.map((function(t){return null}));if(1===r)return Array.isArray(t)&&1===t.length?t:"object"==typeof t&&e[0]in t?[t[e[0]]]:[t];if(Array.isArray(t)){if(t.length!==r)throw new Error("Provided "+n+" is an array of "+t.length+" element(s), but the model has "+r+" outputs. Make sure a set of weights is provided for each model output.");return t}if("object"==typeof t&&Object.keys(t).length>0&&"object"==typeof t[Object.keys(t)[0]]){var i=[];return e.forEach((function(e){e in t?i.push(t[e]):i.push(null)})),i}throw new Error("The model has multiple ("+r+") outputs, so "+n+" must be either an array with "+r+" elements or an object with "+e+" keys. Provided "+n+" not understood: "+JSON.stringify(t))}(t,e,"classWeight")}function Ao(t,n,r,i){return yi(this,void 0,void 0,(function(){var a,s,o,u,l;return vi(this,(function(c){switch(c.label){case 0:if(null!=n||null!=i)throw new Error("Support sampleWeight is not implemented yet");return null==r?[3,2]:(a=e.tidy((function(){if(1===t.shape.length)return e.clone(t);if(2===t.shape.length){if(t.shape[1]>1){return e.argMax(t,1)}if(1===t.shape[1])return e.reshape(t,[t.shape[0]]);throw new Error("Encountered unexpected last-dimension size ("+t.shape[1]+") during handling of class weights. The size is expected to be >= 1.")}throw new Error("Unexpected rank of target (y) tensor ("+t.rank+") during handling of class weights. The rank is expected to be 1 or 2.")})),u=(o=Array).from,[4,a.data()]);case 1:return s=u.apply(o,[c.sent()]),e.dispose(a),l=[],s.forEach((function(t){if(null==r[t])throw new Error("classWeight must contain all classes in the training data. The class "+t+" exists in the data but not in classWeight");l.push(r[t])})),[2,e.tensor1d(l,"float32")];case 2:return[2,null]}}))}))}function Co(t,n){return e.mul(t,n)}function To(t,n){var r,i,a=n;r=a.xs,i=a.ys,e.util.assert(null!=r&&null!=i,(function(){return"A Dataset iterator for fitDataset() is expected to generate objects of the form `{xs: xVal, ys: yVal}`, where the two values may be `tf.Tensor`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates "+n}));var s=Eo("input",t.inputNames,r),o=Eo("output",t.outputNames,i),u=s[0].shape[0];e.util.assert(s.length===t.inputs.length,(function(){return"LayersModel has "+t.inputs.length+" inputs, but the dataset provides "+s.length+" inputs.  (Expected input keys: "+JSON.stringify(t.inputNames)+")"})),e.util.assert(o.length===t.outputs.length,(function(){return"LayersModel has "+t.outputs.length+" outputs, but the dataset provides "+o.length+" outputs.  (Expected output keys: "+JSON.stringify(t.outputNames)+")"}));for(var l=function(n){e.util.assert(s[n].shape[0]===u,(function(){return"Batch size mismatch: input "+t.inputNames[n]+" has "+s[n].shape[0]+"; expected  "+u+" based on input "+t.inputNames[0]+"."}))},c=0;c<s.length;c++)l(c);for(var h=function(n){e.util.assert(o[n].shape[0]===u,(function(){return"Batch size mismatch: output "+t.outputNames[n]+" has "+o[n].shape[0]+"; expected  "+u+" based on input "+t.inputNames[0]+"."}))},p=0;p<o.length;p++)h(p);return{xs:s,ys:o}}function Eo(t,n,r){if(r instanceof e.Tensor)return[r];if(Array.isArray(r))return e.util.assert(r.length===n.length,(function(){return"Received an array of "+r.length+" Tensors, but expected "+n.length+" to match the "+t+" keys "+n+"."})),r;for(var i=[],a=0,s=n;a<s.length;a++){var o=s[a];if(null==r[o])throw new Si("The feature data generated by the dataset lacks the required "+t+" key '"+o+"'.");i.push(r[o])}return i}function Fo(t,n,r){return yi(this,void 0,void 0,(function(){var i,a,s,o,u,l,c,h,p,d,f,g,m,y,v,b,w,k,S,N,x,z,I,A,C,T,E,F,D,L,_,R,O,M;return vi(this,(function(B){switch(B.label){case 0:if(i=null!=r.batchesPerEpoch,e.util.assert(null!=t.optimizer,(function(){return"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."})),e.util.assert(null!=r,(function(){return"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."})),e.util.assert(null!=r.epochs&&r.epochs>0&&Number.isInteger(r.epochs),(function(){return"For fitDataset(), config.epochs is expected to be a positive integer, but got "+r.epochs})),e.util.assert(!i||r.batchesPerEpoch>0&&Number.isInteger(r.batchesPerEpoch),(function(){return"For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got "+r.batchesPerEpoch})),e.util.assert(null==r.validationSplit,(function(){return"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."})),t.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");t.isTraining=!0,B.label=1;case 1:return B.trys.push([1,,26,27]),a=null!=r.validationData,s=void 0,o=void 0,a&&(Do(r.validationData)?e.util.assert(null==r.validationBatches||r.validationBatches>0&&Number.isInteger(r.validationBatches),(function(){return"For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got "+r.validationBatches})):(u=function(t){if(3===t.length)throw new Ni("Validation with sample weights is not implemented yet.");return{xs:t[0],ys:t[1]}}(r.validationData),s=u.xs,o=u.ys)),l=t.makeTrainFunction(),c=t.getDedupedMetricsNames(),h=void 0,h=a?c.slice().concat(c.map((function(t){return"val_"+t}))):c.slice(),p=Rs(r.callbacks,r.yieldEvery),d=null==r.verbose?1:r.verbose,f=Ms(p,d,r.epochs,null,null,function(t,e){var n=null;null!=e.batchesPerEpoch?n=e.batchesPerEpoch:Number.isFinite(t.size)&&(n=t.size);return n}(n,r),null,a,h),g=f.callbackList,m=f.history,g.setModel(t),t.history=m,[4,g.onTrainBegin()];case 2:return B.sent(),t.stopTraining_=!1,y=null==r.initialEpoch?0:r.initialEpoch,[4,n.iterator()];case 3:v=B.sent(),B.label=4;case 4:return y<r.epochs?(b={},[4,g.onEpochBegin(y)]):[3,23];case 5:return B.sent(),w=0,k=0,i?[3,7]:[4,n.iterator()];case 6:v=B.sent(),B.label=7;case 7:return!i||w<r.batchesPerEpoch?[4,v.next()]:[3,21];case 8:return S=B.sent(),i&&S.done?(console.warn("You provided `batchesPerEpoch` as "+r.batchesPerEpoch+", but your dataset iterator ran out of data after "+w+" batches; interrupting training. Make sure that your dataset can generate at least `batchesPerEpoch * epochs` batches (in this case, "+r.batchesPerEpoch*r.epochs+" batches). You may need to use the repeat() function when building your dataset."),[3,21]):null==S.value?[3,15]:(N=To(t,S.value),x=N.xs,z=N.ys,(I={}).batch=k,I.size=x[0].shape[0],[4,g.onBatchBegin(k,I)]);case 9:if(B.sent(),A=[],null==r.classWeight)return[3,13];C=Io(r.classWeight,t.outputNames),M=0,B.label=10;case 10:return M<C.length?(E=(T=A).push,[4,Ao(z[M],null,C[M])]):[3,13];case 11:E.apply(T,[B.sent()]),B.label=12;case 12:return++M,[3,10];case 13:for(F=x.concat(z).concat(A),D=l(F),e.dispose(F),M=0;M<c.length;++M)L=c[M],_=D[M],I[L]=_,e.keep(_);return[4,g.onBatchEnd(k,I)];case 14:B.sent(),Ts(I),k++,w++,B.label=15;case 15:return(i?w>=r.batchesPerEpoch:S.done)?a?(R=void 0,Do(r.validationData)?(O=Ti,[4,t.evaluateDataset(r.validationData,{batches:r.validationBatches})]):[3,17]):[3,19]:[3,20];case 16:return R=O.apply(void 0,[B.sent()]),[3,18];case 17:R=Ti(t.evaluate(s,o,{batchSize:null==r.validationBatchSize?32:r.validationBatchSize,verbose:0})),B.label=18;case 18:for(M=0;M<t.metricsNames.length;++M)b["val_"+t.metricsNames[M]]=R[M];B.label=19;case 19:return[3,21];case 20:return t.stopTraining_?[3,21]:[3,7];case 21:return[4,g.onEpochEnd(y,b)];case 22:return B.sent(),y++,t.stopTraining_?[3,23]:[3,4];case 23:return[4,g.onTrainEnd()];case 24:return B.sent(),[4,t.history.syncData()];case 25:return B.sent(),[2,t.history];case 26:return t.isTraining=!1,[7];case 27:return[2]}}))}))}function Do(t){return"function"==typeof t.iterator}function Lo(t,n,r){return yi(this,void 0,void 0,(function(){var i,a,s,o,u,l,c,h,p,d;return vi(this,(function(f){switch(f.label){case 0:if(i=null!=(r=r||{}).batches,a=t.testFunction,s=[],r.verbose>0)throw new Ni("Verbose mode is not implemented yet.");return e.util.assert(!i||r.batches>0&&Number.isInteger(r.batches),(function(){return"Test loop expects `batches` to be a positive integer, but received "+JSON.stringify(r.batches)})),"function"!=typeof n.next?[3,1]:(u=n,[3,3]);case 1:return[4,n.iterator()];case 2:u=f.sent(),f.label=3;case 3:o=u,l=0,c=0,h=function(){var n;return vi(this,(function(u){switch(u.label){case 0:return[4,o.next()];case 1:return n=u.sent(),s=e.tidy((function(){if(n.value){var r=To(t,n.value),i=r.xs,o=r.ys,u=i.concat(o),h=e.tidy((function(){return a(u)}));if(e.dispose(u),0===c)for(var p=0;p<h.length;++p)s.push(e.scalar(0));var d=u[0].shape[0],f=function(t){var n=h[t],r=s[t];s[t]=e.tidy((function(){return e.add(s[t],e.mul(d,n))})),c>0&&e.dispose(r)};for(p=0;p<h.length;++p)f(p);e.dispose(h),l+=d,++c}return s})),n.done?(i&&console.warn("Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least `batches` batches (in this case, "+r.batches+" batches). You may need to use the repeat() function when building your dataset."),[2,"break"]):[2]}}))},f.label=4;case 4:return!i||c<r.batches?[5,h()]:[3,6];case 5:return"break"===f.sent()?[3,6]:[3,4];case 6:for(p=0;p<s.length;++p)d=s[p],s[p]=e.div(s[p],l),e.dispose(d);return[2,Ci(s)]}}))}))}function _o(t){e.util.assert(t>0&&Number.isInteger(t),(function(){return"batchSize is required to be a positive integer, but got "+t}))}function Ro(t,e,n){return null==t?[null]:Array.isArray(t)?t.map((function(t){return Sa(t,e,n-e)})):Sa(t,e,n-e)}function Oo(t,n){return e.tidy((function(){return null==t?null:Array.isArray(t)?t.map((function(t){return Oo(t,n)})):Ea(t,"int32"===n.dtype?n:e.cast(n,"int32"))}))}function Mo(t,e){for(var n=[],r=0,i=null;r<t;)(i=r+e)>=t&&(i=t),n.push([r,i]),r=i;return n}function Bo(t,n,r,i,a,s,o,u,l,c,h,p,d,f,g){return yi(this,void 0,void 0,(function(){var m,y,v,b,w,k,S,N;return vi(this,(function(x){switch(x.label){case 0:if(null==a&&(a=32),null==s&&(s=1),null==h&&(h=!0),null==d&&(d=0),m=!1,null!=l&&null!=c&&(m=!0),null!=g&&(m=!0,null==f))throw new Si("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");return null!=(y=t.checkNumSamples(r,a,f,"steps_per_epoch"))&&(v=ba(0,y)),null==o&&(o=1),b=Ms(u,o,s,d,y,f,a,m,p),w=b.callbackList,k=b.history,w.setModel(t),t.history=k,[4,w.onTrainBegin()];case 1:x.sent(),t.stopTraining_=!1,S=function(s){var o,u,p,d,g;return vi(this,(function(b){switch(b.label){case 0:return[4,w.onEpochBegin(s)];case 1:if(b.sent(),o={},null==f)return[3,2];throw new Ni("stepsPerEpoch mode is not implemented yet.");case 2:if("batch"===h)throw new Ni("batch shuffling is not implemneted yet");h&&e.util.shuffle(v),u=e.tensor1d(v),p=Mo(y,a),d=function(s){var h;return vi(this,(function(d){switch(d.label){case 0:return h={},[4,w.onBatchBegin(s,h)];case 1:return d.sent(),e.tidy((function(){var d=p[s][0],f=p[s][1],g=Sa(u,d,f-d);h.batch=s,h.size=f-d;for(var y=Oo(r,g),v=n(y),b=0;b<i.length;++b){var w=i[b],k=v[b];h[w]=k,e.keep(k)}if(s===p.length-1&&m){var S=t.testLoop(l,c,a);for(b=0;b<i.length;++b){w=i[b],k=S[b];e.keep(k),o["val_"+w]=k}}})),[4,w.onBatchEnd(s,h)];case 2:return d.sent(),Ts(h),t.stopTraining_?[2,"break"]:[2]}}))},g=0,b.label=3;case 3:return g<p.length?[5,d(g)]:[3,6];case 4:if("break"===b.sent())return[3,6];b.label=5;case 5:return++g,[3,3];case 6:u.dispose(),b.label=7;case 7:return[4,w.onEpochEnd(s,o)];case 8:return b.sent(),t.stopTraining_?[2,"break"]:[2]}}))},N=d,x.label=2;case 2:return N<s?[5,S(N)]:[3,5];case 3:if("break"===x.sent())return[3,5];x.label=4;case 4:return++N,[3,2];case 5:return[4,w.onTrainEnd()];case 6:return x.sent(),[4,t.history.syncData()];case 7:return x.sent(),[2,t.history]}}))}))}function Po(t,n,r,i){return void 0===i&&(i={}),yi(this,void 0,void 0,(function(){var a,s,o,u,l,c,h,p,d,f,g,m,y,v,b,w,k,S,N,x;return vi(this,(function(z){switch(z.label){case 0:if(t.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");t.isTraining=!0,z.label=1;case 1:return z.trys.push([1,,7,8]),_o(p=null==i.batchSize?32:i.batchSize),!1,[4,t.standardizeUserData(n,r,i.sampleWeight,i.classWeight,false,p)];case 2:if(d=z.sent(),a=d[0],s=d[1],h=d[2],f=!1,g=void 0,!(null!=i.validationData&&i.validationData.length>0))return[3,4];if(f=!0,2!==i.validationData.length)throw 3===i.validationData.length?new Ni("validationData including sample weights is not supported yet."):new Si("When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; "+i.validationData+" is invalid.");return o=i.validationData[0],u=i.validationData[1],!0,[4,t.standardizeUserData(o,u,null,null,true,p)];case 3:return m=z.sent(),l=m[0],c=m[1],g=l.concat(c),[3,5];case 4:null!=i.validationSplit&&i.validationSplit>0&&i.validationSplit<1?(f=!0,y=Math.floor(a[0].shape[0]*(1-i.validationSplit)),v=a[0].shape[0],l=Ro(a,y,v),a=Ro(a,0,y),c=Ro(s,y,v),s=Ro(s,0,y),g=l.concat(c)):null!=i.validationSteps&&(f=!0),z.label=5;case 5:return b=a.concat(s).concat(h),t.checkTrainableWeightsConsistency(),w=t.makeTrainFunction(),k=t.getDedupedMetricsNames(),S=void 0,N=void 0,f?(t.makeTestFunction(),S=t.testFunction,N=k.slice().concat(k.map((function(t){return"val_"+t})))):(S=null,g=[],N=k.slice()),x=Rs(i.callbacks,i.yieldEvery),[4,Bo(t,w,b,k,p,i.epochs,i.verbose,x,S,g,i.shuffle,N,i.initialEpoch,null,null)];case 6:return[2,z.sent()];case 7:return t.isTraining=!1,Wo(a,n),Wo(s,r),Wo(l,o),Wo(c,u),null!=h&&e.dispose(h),[7];case 8:return[2]}}))}))}function $o(t){var n=[];t instanceof e.Tensor&&(t=[t]);for(var r=0;r<t.length;++r){var i=t[r];if(1===i.rank)n.push(ka(i,1));else{if(0===i.rank)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");n.push(i)}}return n}function Wo(t,n){if(null!=t){var r=[];if(n instanceof e.Tensor)r.push(n.id);else if(Array.isArray(n))n.forEach((function(t){return r.push(t.id)}));else if(null!=n)for(var i in n){var a=n[i];r.push(a.id)}var s=[];if(t instanceof e.Tensor)-1===r.indexOf(t.id)&&s.push(t);else if(Array.isArray(t))t.forEach((function(t){-1===r.indexOf(t.id)&&s.push(t)}));else if(null!=t)for(var o in t){var u=t[o];-1===r.indexOf(u.id)&&s.push(u)}s.forEach((function(t){t.isDisposed||t.dispose()}))}}function Uo(t){return Array.isArray(t)}function jo(t){return!function(t){return t instanceof e.Tensor}(t)&&!Uo(t)}function Vo(t,e,n,r,i){if(void 0===r&&(r=!0),void 0===i&&(i=""),null==e||0===e.length){if(null!=t){var a=!1;if(Uo(t)&&t.length>0)a=!0;else if(jo(t)){for(var s in t)if(t.hasOwnProperty(s)){a=!0;break}}else a=!0;if(a)throw new Si("Error when checking model "+i+" expected no data, but got "+t)}return[]}if(null==t)return e.map((function(t){return null}));var o;if(jo(t)){t=t,o=[];for(var u=0,l=e;u<l.length;u++){var c=l[u];if(null==t[c])throw new Si('No data provided for "'+c+'". Need data for each key in: '+e);o.push(t[c])}}else if(Uo(t)){if((t=t).length!==e.length)throw new Si("Error when checking model "+i+": the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see "+e.length+" Tensor(s), but instead got the following list of Tensor(s): "+t);o=t}else{if(t=t,e.length>1)throw new Si("The model "+i+" expects "+e.length+" Tensor(s), but only received one Tensor. Found: Tensor with shape "+t.shape);o=[t]}if(o=$o(o),null!=n)for(var h=0;h<e.length;++h)if(null!=n[h]){var p=o[h];if(p.shape.length!==n[h].length)throw new Si("Error when checking "+i+": expected "+e[h]+" to have "+n[h].length+" dimension(s). but got array with shape "+p.shape);for(var d=0;d<n[h].length;++d)if(0!==d||r){var f=p.shape[d],g=n[h][d];if(null!=g&&g>=0&&f!==g)throw new Si(i+" expected a batch of elements where each example has shape ["+n[h].slice(1,n[h].length)+"] (i.e.,tensor shape [*,"+n[h].slice(1,n[h].length)+"]) but the "+i+" received an input with "+p.shape[0]+" examples, each with shape ["+p.shape.slice(1,p.shape.length)+"] (tensor shape ["+p.shape+"])")}}return o}function Ko(t,e,n,r,i){var a;if(void 0===r&&(r=!0),void 0===i&&(i=""),Array.isArray(t)){if(t.length!==e.length)throw new Si("Error when checking model "+i+": the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see "+e.length+" Tensor(s), but instead got "+t.length+" Tensors(s).");a=t}else{if(e.length>1)throw new Si("The model expects "+e.length+" "+i+" Tensors, but only received one Tensor. Found: array with shape "+JSON.stringify(t.shape)+".");a=[t]}if(null!=n)for(var s=0;s<e.length;++s)if(null!=n[s]){var o=a[s];if(o.shape.length!==n[s].length)throw new Si("Error when checking "+i+": expected "+e[s]+" to have "+n[s].length+" dimension(s), but got array with shape "+JSON.stringify(o.shape));for(var u=0;u<n[s].length;++u)if(0!==u||r){var l=o.shape[u],c=n[s][u];if(null!=c&&c!==l)throw new Si("Error when checking "+i+": expected "+e[s]+" to have shape "+JSON.stringify(n[s])+" but got array with shape "+JSON.stringify(o.shape)+".")}}}var qo=function(t){function n(e){var n=t.call(this,e)||this;return n.isTraining=!1,n}return fi(n,t),n.prototype.summary=function(t,e,n){if(void 0===n&&(n=console.log),!this.built)throw new Si("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");lo(this,t,e,n)},n.prototype.compile=function(t){var n=this;if(null==t.loss&&(t.loss=[]),this.loss=t.loss,"string"==typeof t.optimizer)this.optimizer_=function(t){var n={Adagrad:function(){return e.train.adagrad(.01)},Adadelta:function(){return e.train.adadelta(1,.95,bi())},Adam:function(){return e.train.adam(.001,.9,.999,bi())},Adamax:function(){return e.train.adamax(.002,.9,.999,bi(),0)},RMSProp:function(){return e.train.rmsprop(.001,.9,0,bi())},SGD:function(){return e.train.sgd(.01)}};if(n.adagrad=n.Adagrad,n.adadelta=n.Adadelta,n.adam=n.Adam,n.adamax=n.Adamax,n.rmsprop=n.RMSProp,n.sgd=n.SGD,t in n)return n[t]();throw new Si("Unknown Optimizer "+t)}(t.optimizer),this.isOptimizerOwned=!0;else{if(!(t.optimizer instanceof e.Optimizer))throw new Si("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=t.optimizer,this.isOptimizerOwned=!1}var r=[];if(Array.isArray(t.loss)||"string"==typeof t.loss||"function"==typeof t.loss)if(Array.isArray(t.loss)){if(t.loss.length!==this.outputs.length)throw new Si("When passing an Array as loss, it should have one entry per model output. The model has "+this.outputs.length+" output(s), but you passed loss="+t.loss+".");var i=t.loss;r=i.map((function(t){return Hs(t)}))}else{var a=Hs(t.loss);this.outputs.forEach((function(t){r.push(a)}))}else{for(var s in t.loss=t.loss,t.loss)if(-1===this.outputNames.indexOf(s))throw new Si('Unknown entry in loss dictionary: "'+s+'". Only expected the following keys: '+this.outputNames);for(var o=0,u=this.outputNames;o<u.length;o++){var l=u[o];null==t.loss[l]&&console.warn('Output "'+l+'" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to '+l+" during training"),r.push(Hs(t.loss[l]))}}this.lossFunctions=r,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(var c=0;c<this.outputs.length;++c){var h=this.internalOutputShapes[c],p=this.outputNames[c];this.feedOutputNames.push(p),this.feedOutputShapes.push(h),this.feedLossFns.push(this.lossFunctions[c])}var d=[];this.metrics=t.metrics,this.metricsNames=["loss"],this.metricsTensors=[],ha("loss",(function(){for(var t=0;t<n.outputs.length;++t)if(-1===d.indexOf(t)){var e=n.lossFunctions[t];n.outputs.length>1&&(n.metricsTensors.push([e,t]),n.metricsNames.push(n.outputNames[t]+"_loss"))}}));var f=function(t,e){if(null==t||Array.isArray(t)&&0===t.length)return e.map((function(t){return[]}));var n;if("string"==typeof t||"function"==typeof t)n=[t];else{if(!Array.isArray(t)&&"object"!=typeof t)throw new TypeError("Type of metrics argument not understood. Expected an string,function, Array, or Object, found: "+t);n=t}if(Array.isArray(n))return e.map((function(t){return n}));for(var r=[],i=0,a=e;i<a.length;i++){var s=a[i],o=n.hasOwnProperty(s)?n[s]:[];Array.isArray(o)||(o=[o]),r.push(o)}return r}(t.metrics,this.outputNames);ha("metric",(function(){for(var t=function(t){if(-1!==d.indexOf(t))return"continue";!function(e){for(var r,i,a,s=function(e){if("string"==typeof e&&-1!==["accuracy","acc","crossentropy","ce"].indexOf(e)){var s=n.internalOutputShapes[t];1===s[s.length-1]||n.lossFunctions[t]===Ks?-1!==["accuracy","acc"].indexOf(e)?i=Js:-1!==["crossentropy","ce"].indexOf(e)&&(i=to):n.lossFunctions[t]===Vs?-1!==["accuracy","acc"].indexOf(e)?i=eo:-1!==["crossentropy","ce"].indexOf(e)&&(i=ro):-1!==["accuracy","acc"].indexOf(e)?i=Zs:-1!==["crossentropy","ce"].indexOf(e)&&(i=no);var o=void 0;-1!==["accuracy","acc"].indexOf(e)?o="acc":-1!==["crossentropy","ce"].indexOf(e)&&(o="ce"),a=i,r=""+o}else{var u=function(t){if("string"==typeof t&&t in io)return io[t];if("string"!=typeof t&&null!=t)return t;throw new Si("Unknown metric "+t)}(e);a=u,r=""+ao(e)}var l;ha(r,(function(){l=a})),function(t,e,r){n.outputNames.length>1&&(e=n.outputNames[t]+"_"+e),n.metricsNames.push(e),n.metricsTensors.push([r,t])}(t,r,l)},o=0,u=e;o<u.length;o++){s(u[o])}}(f[t])},e=0;e<n.outputs.length;++e)t(e)})),this.collectedTrainableWeights=this.trainableWeights},n.prototype.checkTrainableWeightsConsistency=function(){null!=this.collectedTrainableWeights&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")},n.prototype.evaluate=function(t,e,n){void 0===n&&(n={});var r=null==n.batchSize?32:n.batchSize;_o(r);var i=this.standardizeUserDataXY(t,e,!0,r);try{var a=i[0].concat(i[1]);this.makeTestFunction();var s=this.testFunction;return Ci(this.testLoop(s,a,r,n.verbose,n.steps))}finally{Wo(i[0],t),Wo(i[1],e)}},n.prototype.evaluateDataset=function(t,e){return yi(this,void 0,void 0,(function(){return vi(this,(function(n){return this.makeTestFunction(),[2,Lo(this,t,e)]}))}))},n.prototype.checkNumSamples=function(t,e,n,r){var i;if(void 0===r&&(r="steps"),null!=n){if(i=null,null!=e)throw new Si("If "+r+" is set, batchSize must be null or undefined.Got batchSize = "+e)}else{if(null==t)throw new Si("Either the input data should have a defined shape, or "+r+" shoud be specified.");i=Array.isArray(t)?t[0].shape[0]:t.shape[0]}return i},n.prototype.execute=function(t,n){if(Array.isArray(n)&&0===n.length)throw new Si("`outputs` is an empty Array, which is not allowed.");var r=Array.isArray(n),i=r?n:[n],a=this.retrieveSymbolicTensors(i),s=new vo;if(t instanceof e.Tensor&&(t=[t]),Array.isArray(t)){if(t.length!==this.inputs.length)throw new Si("The number of inputs provided ("+t.length+") does not match the number of inputs of this model ("+this.inputs.length+").");for(var o=0;o<this.inputs.length;++o)s.add(this.inputs[o],t[o])}else for(var u=0,l=this.inputs;u<l.length;u++){var c=l[u],h=t[c.name];if(null==h)throw new Si("No value is provided for the model's input "+c.name);s.add(c,h)}var p=ko(a,s);return r?p:p[0]},n.prototype.retrieveSymbolicTensors=function(t){for(var e=zi(null,t.length),n=t.length,r=0,i=this.layers;r<i.length;r++){for(var a=i[r],s=Array.isArray(a.output)?a.output:[a.output],o=s.map((function(t){return t.name})),u=0;u<t.length;++u){var l=o.indexOf(t[u]);if(-1!==l&&(e[u]=s[l],n--),0===n)break}if(0===n)break}if(n>0){var c=[];throw e.forEach((function(e,n){null==e&&c.push(t[n])})),new Si("Cannot find SymbolicTensors for output name(s): "+JSON.stringify(c))}return e},n.prototype.predictLoop=function(t,n,r){var i=this;return void 0===n&&(n=32),void 0===r&&(r=!1),e.tidy((function(){var a=i.checkNumSamples(t);if(r)throw new Ni("Verbose predictLoop() is not implemented yet.");for(var s=Mo(a,n),o=i.outputs.map((function(t){return[]})),u=function(n){e.tidy((function(){var e=s[n][0],r=s[n][1],a=Ro(t,e,r),o=[];if(Array.isArray(a))for(var u=0;u<a.length;++u)o.push({key:i.inputs[u],value:a[u]});else o.push({key:i.inputs[0],value:a});var l=new vo(o);return ko(i.outputs,l)})).forEach((function(t,e){return o[e].push(t)}))},l=0;l<s.length;++l)u(l);return Ci(o.map((function(t){return e.concat(t,0)})))}))},n.prototype.predict=function(t,e){void 0===e&&(e={});var n=$o(t);Ko(n,this.inputNames,this.feedInputShapes,!1);try{var r=null==e.batchSize?32:e.batchSize;return _o(r),this.predictLoop(n,r)}finally{Wo(n,t)}},n.prototype.predictOnBatch=function(t){Ko(t,this.inputNames,this.feedInputShapes,!0);var e=(Array.isArray(t)?t[0]:t).shape[0];return this.predictLoop(t,e)},n.prototype.standardizeUserDataXY=function(t,n,r,i){if(null==this.optimizer_)throw new ki("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");for(var a=[],s=0;s<this.feedOutputShapes.length;++s){var o=this.feedOutputShapes[s];this.feedLossFns[s]===Vs?a.push(o.slice(0,o.length-1).concat([1])):a.push(o)}if(function(t,n,r){var i=Mi(t.map((function(t){return t.shape[0]})));i.sort();var a=Mi(n.map((function(t){return t.shape[0]})));if(a.sort(),i.length>1)throw new Si("All input Tensors (x) should have the same number of samples. Got array shapes: "+JSON.stringify(t.map((function(t){return t.shape}))));if(a.length>1)throw new Si("All target Tensors (y) should have the same number of samples. Got array shapes: "+JSON.stringify(n.map((function(t){return t.shape}))));if(i.length>0&&a.length>0&&!e.util.arraysEqual(i,a))throw new Si("Input Tensors should have the same number of samples as target Tensors. Found "+i[0]+" input sample(s) and "+a[0]+" target sample(s).")}(t=Vo(t,this.feedInputNames,this.feedInputShapes,!1,"input"),n=Vo(n,this.feedOutputNames,a,!1,"target")),function(t,e,n){for(var r=[$s,Ks,js],i=0;i<t.length;++i){var a=t[i],s=e[i],o=n[i];if(null!=s){if(s===js&&1===a.shape[a.shape.length-1])throw new Si("You are passing a target array of shape "+a.shape+" while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].");if(-1!==r.indexOf(s))for(var u=a.shape.slice(1),l=o.slice(1),c=0;c<u.length;++c){var h=u[c],p=l[c];if(null!=p&&h!==p)throw new Si("A target Tensor with shape "+a.shape+" was passed for an output of shape "+o+", while using a loss function that expects targets to have the same shape as the output.")}}}}(n,this.feedLossFns,this.feedOutputShapes),this.stateful&&null!=i&&i>0&&t[0].shape[0]%i!=0)throw new Si("In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size "+i+". Found: "+t[0].shape[0]+" sample(s).");return[t,n]},n.prototype.standardizeUserData=function(t,e,n,r,i,a){return void 0===i&&(i=!0),yi(this,void 0,void 0,(function(){var s,o,u,l,c,h,p,d;return vi(this,(function(f){switch(f.label){case 0:if(s=this.standardizeUserDataXY(t,e,i,a),o=s[0],u=s[1],null!=n)throw new Error("sample weight is not supported yet.");if(l=null,null==r)return[3,4];c=Io(r,this.outputNames),l=[],h=0,f.label=1;case 1:return h<c.length?(d=(p=l).push,[4,Ao(u[h],null,c[h])]):[3,4];case 2:d.apply(p,[f.sent()]),f.label=3;case 3:return++h,[3,1];case 4:return[2,[o,u,l]]}}))}))},n.prototype.testLoop=function(t,n,r,i,a){var s=this;return void 0===i&&(i=0),e.tidy((function(){var o=s.checkNumSamples(n,r,a,"steps"),u=[];if(i>0)throw new Ni("Verbose mode is not implemented yet.");if(null!=a)throw new Ni("steps mode in testLoop() is not implemented yet");for(var l=Mo(o,r),c=e.tensor1d(ba(0,o)),h=0;h<l.length;++h){var p=l[h][0],d=l[h][1],f=Sa(c,p,d-p),g=Oo(n,f),m=t(g);if(0===h)for(var y=0;y<m.length;++y)u.push(e.scalar(0));for(y=0;y<m.length;++y){var v=m[y];u[y]=e.add(u[y],e.mul(d-p,v))}}for(y=0;y<u.length;++y)u[y]=e.div(u[y],o);return u}))},n.prototype.getDedupedMetricsNames=function(){for(var t=this.metricsNames,e=[],n=0;n<t.length;++n){var r=t[n],i=r;if(Ai(t,r)>1)i+="_"+Ai(t.slice(0,n),r);e.push(i)}return e},n.prototype.makeTrainFunction=function(){var t=this;return function(n){var r=[],i=n.slice(0,t.inputs.length),a=n.slice(t.inputs.length,t.inputs.length+t.outputs.length),s=n.slice(t.inputs.length+t.outputs.length,t.inputs.length+2*t.outputs.length),o=[],u=t.collectedTrainableWeights.map((function(t){return t.read()}));return[t.optimizer_.minimize((function(){for(var n=[],u=0;u<t.inputs.length;++u)n.push({key:t.inputs[u],value:i[u]});var l,c=new vo(n),h=ko(t.outputs,c,{training:!0});for(u=0;u<t.lossFunctions.length;++u){var p=(0,t.lossFunctions[u])(a[u],h[u]);null!=s[u]&&(p=Co(p,s[u]));var d=e.mean(p);r.push(d),l=0===u?p:e.add(l,p)}for(u=0;u<t.metricsTensors.length;++u){var f=void 0;if(t.outputs.length>1&&u<t.outputs.length)f=r[u];else{var g=t.metricsTensors[u][0],m=t.metricsTensors[u][1];f=e.mean(g(a[m],h[m]))}e.keep(f),o.push(f)}return l=e.mean(l),t.calculateLosses().forEach((function(t){l=e.add(l,t)})),l}),!0,u)].concat(o)}},n.prototype.makeTestFunction=function(){var t=this;this.testFunction=function(n){return e.tidy((function(){for(var r,i=[],a=n.slice(0,t.inputs.length),s=n.slice(t.inputs.length,t.inputs.length+t.outputs.length),o=[],u=0;u<t.inputs.length;++u)o.push({key:t.inputs[u],value:a[u]});var l=new vo(o),c=ko(t.outputs,l);for(u=0;u<t.lossFunctions.length;++u){var h=t.lossFunctions[u],p=e.mean(h(s[u],c[u]));r=0===u?p:e.add(r,p),i.push(r)}for(u=0;u<t.metricsTensors.length;++u){var d=t.metricsTensors[u][0],f=t.metricsTensors[u][1],g=e.mean(d(s[f],c[f]));i.push(g)}return i}))}},n.prototype.fit=function(t,e,n){return void 0===n&&(n={}),yi(this,void 0,void 0,(function(){return vi(this,(function(r){return[2,Po(this,t,e,n)]}))}))},n.prototype.fitDataset=function(t,e){return yi(this,void 0,void 0,(function(){return vi(this,(function(n){return[2,Fo(this,t,e)]}))}))},n.prototype.trainOnBatch=function(t,n){return yi(this,void 0,void 0,(function(){var r,i,a,s,o,u,l,c,h;return vi(this,(function(p){switch(p.label){case 0:return[4,this.standardizeUserData(t,n)];case 1:r=p.sent(),i=r[0],a=r[1],s=this.makeTrainFunction(),o=s(i.concat(a)),u=[],l=0,c=o,p.label=2;case 2:return l<c.length?[4,c[l].data()]:[3,5];case 3:h=p.sent(),u.push(h[0]),p.label=4;case 4:return l++,[3,2];case 5:return e.dispose(o),[2,Ci(u)]}}))}))},n.prototype.getNamedWeights=function(t){for(var e=[],n=null!=t&&t.trainableOnly,r=n?this.trainableWeights:this.weights,i=this.getWeights(n),a=0;a<r.length;++a)n&&!r[a].trainable||e.push({name:r[a].originalName,tensor:i[a]});return e},Object.defineProperty(n.prototype,"stopTraining",{get:function(){return this.stopTraining_},set:function(t){this.stopTraining_=t},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"optimizer",{get:function(){return this.optimizer_},set:function(t){this.optimizer_!==t&&(this.optimizer_=t,this.isOptimizerOwned=!1)},enumerable:!0,configurable:!0}),n.prototype.dispose=function(){var n=t.prototype.dispose.call(this);if(0===n.refCountAfterDispose&&null!=this.optimizer&&this.isOptimizerOwned){var r=e.memory().numTensors;this.optimizer_.dispose(),n.numDisposedVariables+=r-e.memory().numTensors}return n},n.prototype.getLossIdentifiers=function(){var t;if("string"==typeof this.loss)t=Ei(this.loss);else if(Array.isArray(this.loss)){for(var e=0,n=this.loss;e<n.length;e++){if("string"!=typeof n[e])throw new Error("Serialization of non-string loss is not supported.")}t=this.loss.map((function(t){return Ei(t)}))}else{var r=Object.keys(this.loss);t={};for(var i=this.loss,a=0,s=r;a<s.length;a++){var o=s[a];if("string"!=typeof i[o])throw new Error("Serialization of non-string loss is not supported.");t[o]=Ei(i[o])}}return t},n.prototype.getMetricIdentifiers=function(){if("string"==typeof this.metrics||"function"==typeof this.metrics)return[Ei(ao(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map((function(t){return Ei(ao(t))}));var t={};for(var e in this.metrics)t[e]=Ei(ao(this.metrics[e]));return t},n.prototype.getTrainingConfig=function(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}},n.prototype.loadTrainingConfig=function(t){if(null!=t.weighted_metrics)throw new Error("Loading weight_metrics is not supported yet.");if(null!=t.loss_weights)throw new Error("Loading loss_weights is not supported yet.");if(null!=t.sample_weight_mode)throw new Error("Loading sample_weight_mode is not supported yet.");var e,n,r=Bs(go(t.optimizer_config));if("string"==typeof t.loss)e=Fi(t.loss);else if(Array.isArray(t.loss))e=t.loss.map((function(t){return Fi(t)}));else if(null!=t.loss)for(var i in e={},t.loss)e[i]=Fi(t.loss[i]);if(Array.isArray(t.metrics))n=t.metrics.map((function(t){return Fi(t)}));else if(null!=t.metrics)for(var i in n={},t.metrics)n[i]=Fi(t.metrics[i]);this.compile({loss:e,metrics:n,optimizer:r})},n.prototype.save=function(t,n){return yi(this,void 0,void 0,(function(){var r,i,a,s,o,u,l,c,h,p,d;return vi(this,(function(f){switch(f.label){case 0:if("string"==typeof t){if(0===(r=e.io.getSaveHandlers(t)).length)throw new Si("Cannot find any save handlers for URL '"+t+"'");if(r.length>1)throw new Si("Found more than one ("+r.length+") save handlers for URL '"+t+"'");t=r[0]}if(null==t.save)throw new Si("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return[4,e.io.encodeWeights(this.getNamedWeights(n))];case 1:return i=f.sent(),!1,null,a=this.toJSON(null,false),s={modelTopology:a,format:"layers-model",generatedBy:"TensorFlow.js tfjs-layers v3.9.0",convertedBy:null},null!=n&&n.includeOptimizer&&null!=this.optimizer?(s.trainingConfig=this.getTrainingConfig(),o="optimizer",p=(h=e.io).encodeWeights,[4,this.optimizer.getWeights()]):[3,4];case 2:return[4,p.apply(h,[f.sent(),o])];case 3:u=f.sent(),l=u.data,c=u.specs,(d=i.specs).push.apply(d,c),i.data=e.io.concatenateArrayBuffers([i.data,l]),f.label=4;case 4:return null!=this.userDefinedMetadata&&(!0,oo(this.userDefinedMetadata,this.name,true),s.userDefinedMetadata=this.userDefinedMetadata),s.weightData=i.data,s.weightSpecs=i.specs,[2,t.save(s)]}}))}))},n.prototype.setUserDefinedMetadata=function(t){oo(t,this.name),this.userDefinedMetadata=t},n.prototype.getUserDefinedMetadata=function(){return this.userDefinedMetadata},n.className="Model",n}(zo);e.serialization.registerClass(qo);var Go=function(t){function e(){return null!==t&&t.apply(this,arguments)||this}return fi(e,t),e.className="Functional",e}(qo);function Ho(t,n,r){return yi(this,void 0,void 0,(function(){var i,a,s,o,u,l,c,h,p;return vi(this,(function(d){switch(d.label){case 0:if(null==r&&(r={}),null==t.load)throw new Si("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");return[4,t.load()];case 1:if(i=d.sent(),null!=(a=i.modelTopology).model_config&&(a=a.model_config),s=null==r.strict||r.strict,o=null!=i.weightData&&null!=i.weightSpecs&&s,u=Bs(go(a),n,o),null!=(l=i.trainingConfig)&&u.loadTrainingConfig(l),null!=i.userDefinedMetadata&&u.setUserDefinedMetadata(i.userDefinedMetadata),null==i.weightData)return[3,4];if(null==i.weightSpecs)throw new Si("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");return c=function(t,n){var r=e.io.decodeWeights(t,n),i={},a=[];return n.forEach((function(t){"optimizer"===t.group?a.push({name:t.name,tensor:r[t.name]}):i[t.name]=r[t.name]})),{modelWeights:i,optimizerWeights:a}}(i.weightData,i.weightSpecs),h=c.modelWeights,p=c.optimizerWeights,u.loadWeights(h,s),null!=u.optimizer&&p.length>0?[4,u.optimizer.setWeights(p)]:[3,3];case 2:d.sent(),d.label=3;case 3:e.dispose(h),e.dispose(p.map((function(t){return t.tensor}))),d.label=4;case 4:return[2,u]}}))}))}e.serialization.registerClass(Go);var Jo=function(t){function n(e){var n=t.call(this,{inputs:[],outputs:[]})||this;if(e=e||{},n.trainable=!0,n.built=!1,n.name=null!=e.name?e.name:us("sequential_"),null!=e.layers)for(var r=0,i=e.layers;r<i.length;r++){var a=i[r];n.add(a)}return n}return fi(n,t),n.prototype.checkShape=function(t){if(t.inboundNodes[0].outputTensors[0].shape.some((function(t){return t<0})))throw new Si("Negative dimension size caused by adding layer "+t.name+" with input shape ["+t.inboundNodes[0].inputTensors[0].shape+"]")},n.prototype.add=function(t){var e,r=t instanceof n||t instanceof qo;if(r){if(1!==(e=t).outputs.length)throw new Si("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==e.inputs.length)throw new Si("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===t.inboundNodes.length){if(null==t.batchInputShape)throw new Si("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");var i=As({batchShape:t.batchInputShape,dtype:t.dtype,name:t.name+"_input"});t.apply(i)}if(r)this.outputs=e.outputs,this.inputs=e.inputs;else{if(1!==t.inboundNodes.length)throw new Si("A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer "+t.name+" which has "+t.inboundNodes.length+" pre-existing inbound connections.");if(1!==t.inboundNodes[0].outputTensors.length)throw new Si("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[t.inboundNodes[0].outputTensors[0]],this.inputs=xs(this.outputs[0])}this.inboundNodes=[],new ks({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:zi(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map((function(t){return t.shape})),outputShapes:this.outputs[0].shape})}else{var a=t.apply(this.outputs[0]);if(Array.isArray(a))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[a],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(t),this.built=!1},n.prototype.pop=function(){if(0===this.layers.length)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{var t=this.layers.length-1;this.layers[t].outboundNodes=[],this.outputs=[this.layers[t].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}},n.prototype.call=function(t,e){return null==this.model&&this.build(),this.model.call(t,e)},n.prototype.build=function(t){if(ps(t),0===this.inputs.length||0===this.outputs.length)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new qo({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0},n.prototype.countParams=function(){return this.built||this.build(),t.prototype.countParams.call(this)},n.prototype.summary=function(e,n,r){void 0===r&&(r=console.log),this.built||this.build(),t.prototype.summary.call(this,e,n,r)},n.prototype.setWeights=function(t){null==this.model&&this.build(),this.model.setWeights(t)},n.prototype.evaluate=function(t,e,n){if(void 0===n&&(n={}),!this.built)throw new ki("The model needs to be compiled before being used.");return this.model.evaluate(t,e,n)},n.prototype.evaluateDataset=function(t,e){return yi(this,void 0,void 0,(function(){return vi(this,(function(n){if(!this.built)throw new ki("The model needs to be compiled before being used.");return[2,this.model.evaluateDataset(t,e)]}))}))},n.prototype.predict=function(t,e){return void 0===e&&(e={}),null==this.model&&this.build(),this.model.predict(t,e)},n.prototype.predictOnBatch=function(t){return null==this.model&&this.build(),this.model.predictOnBatch(t)},n.prototype.compile=function(t){this.build(),this.model.compile(t),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames},Object.defineProperty(n.prototype,"optimizer",{get:function(){return null==this.model?void 0:this.model.optimizer},set:function(t){this.model.optimizer=t},enumerable:!0,configurable:!0}),n.prototype.fit=function(t,e,n){return void 0===n&&(n={}),yi(this,void 0,void 0,(function(){return vi(this,(function(r){if(!this.built)throw new ki("The model needs to be compiled before being used.");return[2,this.model.fit(t,e,n)]}))}))},n.prototype.fitDataset=function(t,e){return yi(this,void 0,void 0,(function(){return vi(this,(function(n){if(!this.built)throw new ki("The model needs to be compiled before being used.");return[2,this.model.fitDataset(t,e)]}))}))},n.prototype.trainOnBatch=function(t,e){return yi(this,void 0,void 0,(function(){return vi(this,(function(n){return[2,this.model.trainOnBatch(t,e)]}))}))},n.fromConfig=function(t,r,i,a){var s;void 0===a&&(a=!1);var o={};if(r instanceof Array){if(null==r[0].className||"Merge"===r[0].className)throw new Si("Legacy serialization format not supported yet.");s=r}else e.util.assert(null!=r.layers,(function(){return"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."})),s=r.layers,delete r.layers,o=r;var u=new t(o);if(!(u instanceof n))throw new Ni("Sequential.fromConfig called on non-Sequential input: "+u);for(var l=0,c=s;l<c.length;l++){var h=Bs(c[l],undefined,a);a&&h.setFastWeightInitDuringBuild(!0),u.add(h)}return u},Object.defineProperty(n.prototype,"stopTraining",{get:function(){if(null==this.model)throw new Si("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining},set:function(t){if(null==this.model)throw new Si("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=t},enumerable:!0,configurable:!0}),n.prototype.getConfig=function(){for(var t=[],e=0,n=this.layers;e<n.length;e++){var r=n[e],i={};i.className=r.getClassName(),i.config=r.getConfig(),t.push(i)}return{name:this.name,layers:t}},n.className="Sequential",n}(qo);function Zo(t){return As(t)}e.serialization.registerClass(Jo);var Yo=function(t){function e(){return null!==t&&t.apply(this,arguments)||this}return fi(e,t),e.prototype.getConfig=function(){return{}},e}(e.serialization.Serializable),Xo=function(t){function n(){return null!==t&&t.apply(this,arguments)||this}return fi(n,t),n.prototype.apply=function(t,n){return void 0===n&&(n=1),function(t,n){if(void 0===n&&(n=1),1!==n)throw new Ni("Support for alpha values other than 1 ("+n+") is not implemented yet.");return e.elu(t)}(t,n)},n.className="elu",n}(Yo);e.serialization.registerClass(Xo);var Qo=function(t){function n(){return null!==t&&t.apply(this,arguments)||this}return fi(n,t),n.prototype.apply=function(t){return e.selu(t)},n.className="selu",n}(Yo);e.serialization.registerClass(Qo);var tu=function(t){function n(){return null!==t&&t.apply(this,arguments)||this}return fi(n,t),n.prototype.apply=function(t){return e.relu(t)},n.className="relu",n}(Yo);e.serialization.registerClass(tu);var eu=function(t){function n(){return null!==t&&t.apply(this,arguments)||this}return fi(n,t),n.prototype.apply=function(t){return e.tidy((function(){return e.minimum(6,e.relu(t))}))},n.className="relu6",n}(Yo);e.serialization.registerClass(eu);var nu=function(t){function e(){return null!==t&&t.apply(this,arguments)||this}return fi(e,t),e.prototype.apply=function(t){return t},e.className="linear",e}(Yo);e.serialization.registerClass(nu);var ru=function(t){function n(){return null!==t&&t.apply(this,arguments)||this}return fi(n,t),n.prototype.apply=function(t){return e.sigmoid(t)},n.className="sigmoid",n}(Yo);e.serialization.registerClass(ru);var iu=function(t){function n(){return null!==t&&t.apply(this,arguments)||this}return fi(n,t),n.prototype.apply=function(t){return function(t){return e.tidy((function(){var n=e.add(.5,e.mul(.2,t));return e.clipByValue(n,0,1)}))}(t)},n.className="hardSigmoid",n}(Yo);e.serialization.registerClass(iu);var au=function(t){function n(){return null!==t&&t.apply(this,arguments)||this}return fi(n,t),n.prototype.apply=function(t){return e.softplus(t)},n.className="softplus",n}(Yo);e.serialization.registerClass(au);var su=function(t){function n(){return null!==t&&t.apply(this,arguments)||this}return fi(n,t),n.prototype.apply=function(t){return function(t){return e.tidy((function(){return e.div(t,e.add(e.abs(t),1))}))}(t)},n.className="softsign",n}(Yo);e.serialization.registerClass(su);var ou=function(t){function n(){return null!==t&&t.apply(this,arguments)||this}return fi(n,t),n.prototype.apply=function(t){return e.tanh(t)},n.className="tanh",n}(Yo);e.serialization.registerClass(ou);var uu=function(t){function n(){return null!==t&&t.apply(this,arguments)||this}return fi(n,t),n.prototype.apply=function(t,n){return void 0===n&&(n=-1),e.softmax(t,n)},n.className="softmax",n}(Yo);e.serialization.registerClass(uu);var lu=function(t){function n(){return null!==t&&t.apply(this,arguments)||this}return fi(n,t),n.prototype.apply=function(t,n){return void 0===n&&(n=-1),e.logSoftmax(t,n)},n.className="logSoftmax",n}(Yo);e.serialization.registerClass(lu);var cu=function(t){function n(){return null!==t&&t.apply(this,arguments)||this}return fi(n,t),n.prototype.apply=function(t,n){return void 0===n&&(n=1),e.tidy((function(){return e.mul(e.sigmoid(e.mul(t,n)),t)}))},n.className="swish",n}(Yo);e.serialization.registerClass(cu);var hu=function(t){function n(){return null!==t&&t.apply(this,arguments)||this}return fi(n,t),n.prototype.apply=function(t){return e.tidy((function(){return e.mul(t,e.tanh(e.softplus(t)))}))},n.className="mish",n}(Yo);function pu(t){return t.getClassName()}function du(t,n){return void 0===n&&(n={}),Ri(t,e.serialization.SerializationMap.getMap().classNameMap,n,"activation")}function fu(t){var e;return null==t?du(e={className:"linear",config:{}}):"string"==typeof t?((e={}).className=t,e.config={},du(e)):t instanceof Yo?t:du(t)}function gu(t){if(null!=t&&"object"!=typeof t)throw new Error("Argument to L1L2 regularizer's constructor is expected to be an object, but received: "+t)}e.serialization.registerClass(hu);var mu=function(t){function e(){return null!==t&&t.apply(this,arguments)||this}return fi(e,t),e}(e.serialization.Serializable),yu=function(t){function n(e){var n=t.call(this)||this;return gu(e),n.l1=null==e||null==e.l1?.01:e.l1,n.l2=null==e||null==e.l2?.01:e.l2,n.hasL1=0!==n.l1,n.hasL2=0!==n.l2,n}return fi(n,t),n.prototype.apply=function(t){var n=this;return e.tidy((function(){var r=e.zeros([1]);return n.hasL1&&(r=e.add(r,e.sum(e.mul(n.l1,e.abs(t))))),n.hasL2&&(r=e.add(r,e.sum(e.mul(n.l2,Fa(t))))),e.reshape(r,[])}))},n.prototype.getConfig=function(){return{l1:this.l1,l2:this.l2}},n.fromConfig=function(t,e){return new t({l1:e.l1,l2:e.l2})},n.className="L1L2",n}(mu);e.serialization.registerClass(yu);var vu={l1l2:"L1L2"};function bu(t){return Li(t)}function wu(t,n){return void 0===n&&(n={}),Ri(t,e.serialization.SerializationMap.getMap().classNameMap,n,"regularizer")}function ku(t){return null==t?null:"string"==typeof t?wu({className:t in vu?vu[t]:t,config:{}}):t instanceof mu?t:wu(t)}var Su=function(t){function n(e){var n=t.call(this,null==e?{}:e)||this;return n.supportsMasking=!0,null!=e&&(n.maxValue=e.maxValue),n}return fi(n,t),n.prototype.call=function(t,n){t=hs(t);var r=e.relu(t);return null!=this.maxValue&&(r=e.clipByValue(r,0,this.maxValue)),r},n.prototype.computeOutputShape=function(t){return t},n.prototype.getConfig=function(){var e={maxValue:this.maxValue},n=t.prototype.getConfig.call(this);return Object.assign(e,n),e},n.className="ReLU",n}(Ns);e.serialization.registerClass(Su);var Nu=function(t){function n(e){var n=t.call(this,null==e?{}:e)||this;return n.DEFAULT_ALPHA=.3,null==e&&(e={}),n.alpha=null==e.alpha?n.DEFAULT_ALPHA:e.alpha,n}return fi(n,t),n.prototype.call=function(t,n){var r=hs(t);return e.leakyRelu(r,this.alpha)},n.prototype.computeOutputShape=function(t){return t},n.prototype.getConfig=function(){var e={alpha:this.alpha},n=t.prototype.getConfig.call(this);return Object.assign(e,n),e},n.className="LeakyReLU",n}(Ns);e.serialization.registerClass(Nu);var xu=function(t){function n(e){var n=t.call(this,null==e?{}:e)||this;if(n.DEFAULT_ALPHA_INITIALIZER="zeros",null==e&&(e={}),n.supportsMasking=!0,n.alphaInitializer=rs(e.alphaInitializer||n.DEFAULT_ALPHA_INITIALIZER),n.alphaRegularizer=ku(e.alphaRegularizer),n.alphaConstraint=Qi(e.alphaConstraint),null==e.sharedAxes)n.sharedAxes=null;else if(Array.isArray(e.sharedAxes))n.sharedAxes=e.sharedAxes;else{if("number"!=typeof e.sharedAxes)throw new Si("Expected sharedAxes to be a number or an array of numbers, but got "+e.sharedAxes);n.sharedAxes=[e.sharedAxes]}return n}return fi(n,t),n.prototype.build=function(t){var e=(t=ps(t)).slice(1);if(null!=this.sharedAxes)for(var n=0,r=this.sharedAxes;n<r.length;n++){e[(a=r[n])-1]=1}this.alpha=this.addWeight("alpha",e,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);var i={};if(null!=this.sharedAxes)for(var a=1;a<t.length;++a)i[a]=t[a];this.inputSpec=[new vs({ndim:t.length,axes:i})],this.built=!0},n.prototype.call=function(t,n){return t=hs(t),e.prelu(t,this.alpha.read())},n.prototype.getConfig=function(){var e={alphaInitializer:ns(this.alphaInitializer),alphaRegularizer:bu(this.alphaRegularizer),alphaConstraint:Yi(this.alphaConstraint),sharedAxes:this.sharedAxes},n=t.prototype.getConfig.call(this);return Object.assign(e,n),e},n.className="PReLU",n}(Ns);e.serialization.registerClass(xu);var zu=function(t){function n(e){var n=t.call(this,null==e?{}:e)||this;if(n.DEFAULT_ALPHA=1,null==e&&(e={}),null!=e.alpha&&e.alpha!==n.DEFAULT_ALPHA)throw new Ni("Non-default alpha value ("+e.alpha+") is not supported by the ELU layer yet.");return n.alpha=null==e.alpha?n.DEFAULT_ALPHA:e.alpha,n}return fi(n,t),n.prototype.call=function(t,n){var r=hs(t);return e.elu(r)},n.prototype.computeOutputShape=function(t){return t},n.prototype.getConfig=function(){var e={alpha:this.alpha},n=t.prototype.getConfig.call(this);return Object.assign(e,n),e},n.className="ELU",n}(Ns);e.serialization.registerClass(zu);var Iu=function(t){function n(e){var n=t.call(this,null==e?{}:e)||this;return n.DEFAULT_THETA=1,null==e&&(e={}),n.theta=null==e.theta?n.DEFAULT_THETA:e.theta,n}return fi(n,t),n.prototype.call=function(t,n){var r=hs(t);return e.mul(r,e.cast(e.greater(r,this.theta),"float32"))},n.prototype.computeOutputShape=function(t){return t},n.prototype.getConfig=function(){var e={theta:this.theta},n=t.prototype.getConfig.call(this);return Object.assign(e,n),e},n.className="ThresholdedReLU",n}(Ns);e.serialization.registerClass(Iu);var Au=function(t){function e(e){var n=t.call(this,null==e?{}:e)||this;return n.DEFAULT_AXIS=1,null==e&&(e={}),n.softmax=(new uu).apply,n.axis=null==e.axis?n.DEFAULT_AXIS:e.axis,n}return fi(e,t),e.prototype.call=function(t,e){var n=hs(t);return this.softmax(n,this.axis)},e.prototype.computeOutputShape=function(t){return t},e.prototype.getConfig=function(){var e={axis:this.axis},n=t.prototype.getConfig.call(this);return Object.assign(e,n),e},e.className="Softmax",e}(Ns);function Cu(t,e,n){if("number"==typeof t)return zi(t,e);if(t.length!==e)throw new Si("The "+n+" argument must be an integer or tuple of "+e+" integers. Received: "+t.length+" elements.");for(var r=0;r<e;++r){var i=t[r];if((a=i)!==parseInt(a.toString(),10))throw new Si("The "+n+" argument must be an integer or tuple of "+e+" integers. Received: "+JSON.stringify(t)+" including a non-integer number "+i)}return t;var a}function Tu(t,e,n,r,i){return void 0===i&&(i=1),null==t?t:(a="same"===n?t:t-(e+(e-1)*(i-1))+1,Math.floor((a+r-1)/r));var a}function Eu(t,e,n,r){if(null==t)return null;if("valid"===r)t=t*e+va([n-e,0]);else{if("same"!==r)throw new Si("Unsupport padding mode: "+r+".");t*=e}return t}function Fu(t,n){return e.tidy((function(){return oa(n),"channelsFirst"===n?e.transpose(t,[0,2,3,1]):t}))}function Du(t,n){return e.tidy((function(){return oa(n),"channelsFirst"===n?e.transpose(t,[0,2,3,4,1]):t}))}function Lu(t,n,r,i,a,s,o,u){return void 0===i&&(i=[1,1]),void 0===a&&(a="valid"),void 0===u&&(u=null),e.tidy((function(){if(null==s&&(s="channelsLast"),oa(s),3!==t.rank&&4!==t.rank)throw new Si("conv2dWithBiasActivation expects input to be of rank 3 or 4, but received "+t.rank+".");if(3!==n.rank&&4!==n.rank)throw new Si("conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received "+t.rank+".");var l=Fu(t,s);if("causal"===a)throw new Ni("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=e.fused.conv2d({x:l,filter:n,strides:i,pad:"same"===a?"same":"valid",dilations:o,dataFormat:"NHWC",bias:r,activation:u}),"channelsFirst"===s&&(l=e.transpose(l,[0,3,1,2])),l}))}e.serialization.registerClass(Au);var _u=function(t){function e(n,r){var i=t.call(this,r)||this;if(i.bias=null,i.DEFAULT_KERNEL_INITIALIZER="glorotNormal",i.DEFAULT_BIAS_INITIALIZER="zeros",e.verifyArgs(r),i.rank=n,Wi(i.rank,"rank"),1!==i.rank&&2!==i.rank&&3!==i.rank)throw new Ni("Convolution layer for rank other than 1, 2, or 3 ("+i.rank+") is not implemented yet.");if(i.kernelSize=Cu(r.kernelSize,n,"kernelSize"),i.strides=Cu(null==r.strides?1:r.strides,n,"strides"),i.padding=null==r.padding?"valid":r.padding,ua(i.padding),i.dataFormat=null==r.dataFormat?"channelsLast":r.dataFormat,oa(i.dataFormat),i.activation=fu(r.activation),i.useBias=null==r.useBias||r.useBias,i.biasInitializer=rs(r.biasInitializer||i.DEFAULT_BIAS_INITIALIZER),i.biasConstraint=Qi(r.biasConstraint),i.biasRegularizer=ku(r.biasRegularizer),i.activityRegularizer=ku(r.activityRegularizer),i.dilationRate=Cu(null==r.dilationRate?1:r.dilationRate,n,"dilationRate"),1===i.rank&&Array.isArray(i.dilationRate)&&1!==i.dilationRate.length)throw new Si("dilationRate must be a number or an array of a single number for 1D convolution, but received "+JSON.stringify(i.dilationRate));if(2===i.rank){if("number"==typeof i.dilationRate)i.dilationRate=[i.dilationRate,i.dilationRate];else if(2!==i.dilationRate.length)throw new Si("dilationRate must be a number or array of two numbers for 2D convolution, but received "+JSON.stringify(i.dilationRate))}else if(3===i.rank)if("number"==typeof i.dilationRate)i.dilationRate=[i.dilationRate,i.dilationRate,i.dilationRate];else if(3!==i.dilationRate.length)throw new Si("dilationRate must be a number or array of three numbers for 3D convolution, but received "+JSON.stringify(i.dilationRate));return i}return fi(e,t),e.verifyArgs=function(t){if(Ii("kernelSize"in t,"required key 'kernelSize' not in config"),"number"!=typeof t.kernelSize&&!$i(t.kernelSize,"number",1,3))throw new Si("BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received "+JSON.stringify(t.kernelSize)+".")},e.prototype.getConfig=function(){var e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:pu(this.activation),useBias:this.useBias,biasInitializer:ns(this.biasInitializer),biasRegularizer:bu(this.biasRegularizer),activityRegularizer:bu(this.activityRegularizer),biasConstraint:Yi(this.biasConstraint)},n=t.prototype.getConfig.call(this);return Object.assign(e,n),e},e}(Ns),Ru=function(t){function n(e,r){var i=t.call(this,e,r)||this;return i.kernel=null,n.verifyArgs(r),i.filters=r.filters,Wi(i.filters,"filters"),i.kernelInitializer=rs(r.kernelInitializer||i.DEFAULT_KERNEL_INITIALIZER),i.kernelConstraint=Qi(r.kernelConstraint),i.kernelRegularizer=ku(r.kernelRegularizer),i}return fi(n,t),n.prototype.build=function(t){var e;t=ps(t);var n="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[n])throw new Si("The channel dimension of the input should be defined. Found "+t[n]);var r=t[n],i=this.kernelSize.concat([r,this.filters]);this.kernel=this.addWeight("kernel",i,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:(e={},e[n]=r,e)}],this.built=!0},n.prototype.call=function(t,n){var r=this;return e.tidy((function(){var n;t=hs(t);var i,a,s,o,u,l,c,h=null==r.bias?null:r.bias.read(),p=ji(r.activation.getClassName());if(null!=p&&2===r.rank)n=Lu(t,r.kernel.read(),h,r.strides,r.padding,r.dataFormat,r.dilationRate,p);else{if(1===r.rank)i=t,a=r.kernel.read(),s=h,o=r.strides[0],u=r.padding,l=r.dataFormat,c=r.dilationRate[0],void 0===o&&(o=1),void 0===u&&(u="valid"),void 0===c&&(c=1),n=e.tidy((function(){if(null==l&&(l="channelsLast"),oa(l),3!==i.shape.length)throw new Si("The input of a conv1dWithBias operation should be 3, but is "+i.shape.length+" instead.");if(3!==a.shape.length)throw new Si("The kernel for a conv1dWithBias operation should be 3, but is "+a.shape.length+" instead");if(null!=s&&1!==s.shape.length)throw new Si("The bias for a conv1dWithBias operation should be 1, but is "+a.shape.length+" instead");if("channelsFirst"===l&&(i=e.transpose(i,[0,2,1])),"causal"===u)throw new Ni("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");var t=e.conv1d(i,a,o,"same"===u?"same":"valid","NWC",c);return null!=s&&(t=La(t,s)),t}));else if(2===r.rank)n=Lu(t,r.kernel.read(),h,r.strides,r.padding,r.dataFormat,r.dilationRate);else{if(3!==r.rank)throw new Ni("convolutions greater than 3D are not implemented yet.");n=function(t,n,r,i,a,s,o){return void 0===i&&(i=[1,1,1]),void 0===a&&(a="valid"),e.tidy((function(){if(null==s&&(s="channelsLast"),oa(s),4!==t.rank&&5!==t.rank)throw new Si("conv3dWithBias expects input to be of rank 4 or 5, but received "+t.rank+".");if(4!==n.rank&&5!==n.rank)throw new Si("conv3dWithBias expects kernel to be of rank 4 or 5, but received "+t.rank+".");var u=Du(t,s);if("causal"===a)throw new Ni("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return u=e.conv3d(u,n,i,"same"===a?"same":"valid","NDHWC",o),null!=r&&(u=La(u,r)),"channelsFirst"===s&&(u=e.transpose(u,[0,4,1,2,3])),u}))}(t,r.kernel.read(),h,r.strides,r.padding,r.dataFormat,r.dilationRate)}null!=r.activation&&(n=r.activation.apply(n))}return n}))},n.prototype.computeOutputShape=function(t){t=ps(t);for(var e=[],n="channelsLast"===this.dataFormat?t.slice(1,t.length-1):t.slice(2),r=0;r<n.length;++r){var i=Tu(n[r],this.kernelSize[r],this.padding,this.strides[r],"number"==typeof this.dilationRate?this.dilationRate:this.dilationRate[r]);e.push(i)}var a=[t[0]];return"channelsLast"===this.dataFormat?(a=a.concat(e)).push(this.filters):(a.push(this.filters),a=a.concat(e)),a},n.prototype.getConfig=function(){var e={filters:this.filters,kernelInitializer:ns(this.kernelInitializer),kernelRegularizer:bu(this.kernelRegularizer),kernelConstraint:Yi(this.kernelConstraint)},n=t.prototype.getConfig.call(this);return Object.assign(e,n),e},n.verifyArgs=function(t){if(!("filters"in t)||"number"!=typeof t.filters||t.filters<1)throw new Si("Convolution layer expected config.filters to be a 'number' > 0 but got "+JSON.stringify(t.filters))},n}(_u),Ou=function(t){function e(n){var r=t.call(this,2,n)||this;return e.verifyArgs(n),r}return fi(e,t),e.prototype.getConfig=function(){var e=t.prototype.getConfig.call(this);return delete e.rank,e},e.verifyArgs=function(t){if("number"!=typeof t.kernelSize&&!$i(t.kernelSize,"number",1,2))throw new Si("Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received "+JSON.stringify(t.kernelSize)+".")},e.className="Conv2D",e}(Ru);e.serialization.registerClass(Ou);var Mu=function(t){function e(n){var r=t.call(this,3,n)||this;return e.verifyArgs(n),r}return fi(e,t),e.prototype.getConfig=function(){var e=t.prototype.getConfig.call(this);return delete e.rank,e},e.verifyArgs=function(t){if("number"!=typeof t.kernelSize&&(!Array.isArray(t.kernelSize)||1!==t.kernelSize.length&&3!==t.kernelSize.length))throw new Si("Conv3D expects config.kernelSize to be number or [number, number, number], but received "+JSON.stringify(t.kernelSize)+".")},e.className="Conv3D",e}(Ru);e.serialization.registerClass(Mu);var Bu=function(t){function n(e){var n=t.call(this,e)||this;if(n.inputSpec=[new vs({ndim:4})],"same"!==n.padding&&"valid"!==n.padding)throw new Si("Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode "+n.padding);return n}return fi(n,t),n.prototype.build=function(t){var e;if(4!==(t=ps(t)).length)throw new Si("Input should have rank 4; Received input shape: "+JSON.stringify(t));var n="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[n])throw new Si("The channel dimension of the inputs should be defined. Found `None`.");var r=t[n],i=this.kernelSize.concat([this.filters,r]);this.kernel=this.addWeight("kernel",i,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new vs({ndim:4,axes:(e={},e[n]=r,e)})],this.built=!0},n.prototype.call=function(t,n){var r=this;return e.tidy((function(){var n=hs(t);if(4!==n.shape.length)throw new Si("Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-"+n.shape.length);var i,a,s=n.shape,o=s[0];"channelsFirst"===r.dataFormat?(i=2,a=3):(i=1,a=2);var u=s[i],l=s[a],c=r.kernelSize[0],h=r.kernelSize[1],p=r.strides[0],d=r.strides[1],f=[o,Eu(u,p,c,r.padding),Eu(l,d,h,r.padding),r.filters];"channelsLast"!==r.dataFormat&&(n=e.transpose(n,[0,2,3,1]));var g=e.conv2dTranspose(n,r.kernel.read(),f,r.strides,r.padding);return"channelsLast"!==r.dataFormat&&(g=e.transpose(g,[0,3,1,2])),null!=r.bias&&(g=La(g,r.bias.read(),r.dataFormat)),null!=r.activation&&(g=r.activation.apply(g)),g}))},n.prototype.computeOutputShape=function(t){var e,n,r,i=(t=ps(t)).slice();"channelsFirst"===this.dataFormat?(e=1,n=2,r=3):(e=3,n=1,r=2);var a=this.kernelSize[0],s=this.kernelSize[1],o=this.strides[0],u=this.strides[1];return i[e]=this.filters,i[n]=Eu(i[n],o,a,this.padding),i[r]=Eu(i[r],u,s,this.padding),i},n.prototype.getConfig=function(){var e=t.prototype.getConfig.call(this);return delete e.dilationRate,e},n.className="Conv2DTranspose",n}(Ou);e.serialization.registerClass(Bu);var Pu=function(t){function n(e){var n=t.call(this,e)||this;if(n.inputSpec=[new vs({ndim:5})],"same"!==n.padding&&"valid"!==n.padding)throw new Si("Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode "+n.padding);return n}return fi(n,t),n.prototype.build=function(t){var e;if(5!==(t=ps(t)).length)throw new Si("Input should have rank 5; Received input shape: "+JSON.stringify(t));var n="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[n])throw new Si("The channel dimension of the inputs should be defined. Found `None`.");var r=t[n],i=this.kernelSize.concat([this.filters,r]);this.kernel=this.addWeight("kernel",i,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new vs({ndim:5,axes:(e={},e[n]=r,e)})],this.built=!0},n.prototype.call=function(t,n){var r=this;return e.tidy((function(){var n=hs(t);if(5!==n.shape.length)throw new Si("Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-"+n.shape.length);var i,a,s,o=n.shape,u=o[0];"channelsFirst"===r.dataFormat?(s=2,i=3,a=4):(s=1,i=2,a=3);var l=o[s],c=o[i],h=o[a],p=r.kernelSize[0],d=r.kernelSize[1],f=r.kernelSize[2],g=r.strides[0],m=r.strides[1],y=r.strides[2],v=[u,Eu(l,g,p,r.padding),Eu(c,m,d,r.padding),Eu(h,y,f,r.padding),r.filters];"channelsLast"!==r.dataFormat&&(n=e.transpose(n,[0,2,3,4,1]));var b=e.conv3dTranspose(n,r.kernel.read(),v,r.strides,r.padding);return"channelsLast"!==r.dataFormat&&(b=e.transpose(b,[0,4,1,2,3])),null!==r.bias&&(b=La(b,r.bias.read(),r.dataFormat)),null!==r.activation&&(b=r.activation.apply(b)),b}))},n.prototype.computeOutputShape=function(t){var e,n,r,i,a=(t=ps(t)).slice();"channelsFirst"===this.dataFormat?(e=1,n=2,r=3,i=4):(e=4,n=1,r=2,i=3);var s=this.kernelSize[0],o=this.kernelSize[1],u=this.kernelSize[2],l=this.strides[0],c=this.strides[1],h=this.strides[2];return a[e]=this.filters,a[n]=Eu(a[n],l,s,this.padding),a[r]=Eu(a[r],c,o,this.padding),a[i]=Eu(a[i],h,u,this.padding),a},n.prototype.getConfig=function(){var e=t.prototype.getConfig.call(this);return delete e.dilationRate,e},n.className="Conv3DTranspose",n}(Mu);e.serialization.registerClass(Pu);var $u=function(t){function e(e){return t.call(this,2,e)||this}return fi(e,t),e.className="SeparableConv2D",e}(function(t){function n(e,n){var r=t.call(this,e,n)||this;if(r.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",r.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",r.depthwiseKernel=null,r.pointwiseKernel=null,null==n.filters)throw new Si("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=n.kernelInitializer||null!=n.kernelRegularizer||null!=n.kernelConstraint)throw new Si("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=n.padding&&"same"!==n.padding&&"valid"!==n.padding)throw new Si("SeparableConv"+r.rank+"D supports only padding modes: 'same' and 'valid', but received "+JSON.stringify(n.padding));return r.depthMultiplier=null==n.depthMultiplier?1:n.depthMultiplier,r.depthwiseInitializer=rs(n.depthwiseInitializer||r.DEFAULT_DEPTHWISE_INITIALIZER),r.depthwiseRegularizer=ku(n.depthwiseRegularizer),r.depthwiseConstraint=Qi(n.depthwiseConstraint),r.pointwiseInitializer=rs(n.depthwiseInitializer||r.DEFAULT_POINTWISE_INITIALIZER),r.pointwiseRegularizer=ku(n.pointwiseRegularizer),r.pointwiseConstraint=Qi(n.pointwiseConstraint),r}return fi(n,t),n.prototype.build=function(t){var e;if((t=ps(t)).length<this.rank+2)throw new Si("Inputs to SeparableConv"+this.rank+"D should have rank "+(this.rank+2)+", but received input shape: "+JSON.stringify(t));var n="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[n]||t[n]<0)throw new Si("The channel dimension of the inputs should be defined, but found "+JSON.stringify(t[n]));for(var r=t[n],i=this.kernelSize.concat([r,this.depthMultiplier]),a=[],s=0;s<this.rank;++s)a.push(1);a.push(r*this.depthMultiplier,this.filters);var o=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",i,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,o,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",a,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,o,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,o,this.biasConstraint):this.bias=null,this.inputSpec=[new vs({ndim:this.rank+2,axes:(e={},e[n]=r,e)})],this.built=!0},n.prototype.call=function(t,n){var r=this;return e.tidy((function(){var n;if(t=hs(t),1===r.rank)throw new Ni("1D separable convolution is not implemented yet.");return 2===r.rank&&("channelsFirst"===r.dataFormat&&(t=e.transpose(t,[0,2,3,1])),n=e.separableConv2d(t,r.depthwiseKernel.read(),r.pointwiseKernel.read(),r.strides,r.padding,r.dilationRate,"NHWC")),r.useBias&&(n=La(n,r.bias.read(),r.dataFormat)),null!=r.activation&&(n=r.activation.apply(n)),"channelsFirst"===r.dataFormat&&(n=e.transpose(n,[0,3,1,2])),n}))},n.prototype.getConfig=function(){var e=t.prototype.getConfig.call(this);return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=ns(this.depthwiseInitializer),e.pointwiseInitializer=ns(this.pointwiseInitializer),e.depthwiseRegularizer=bu(this.depthwiseRegularizer),e.pointwiseRegularizer=bu(this.pointwiseRegularizer),e.depthwiseConstraint=Yi(this.depthwiseConstraint),e.pointwiseConstraint=Yi(this.pointwiseConstraint),e},n.className="SeparableConv",n}(Ru));e.serialization.registerClass($u);var Wu=function(t){function e(n){var r=t.call(this,1,n)||this;return e.verifyArgs(n),r.inputSpec=[{ndim:3}],r}return fi(e,t),e.prototype.getConfig=function(){var e=t.prototype.getConfig.call(this);return delete e.rank,delete e.dataFormat,e},e.verifyArgs=function(t){if("number"!=typeof t.kernelSize&&!$i(t.kernelSize,"number",1,1))throw new Si("Conv1D expects config.kernelSize to be number or number[] with length 1, but received "+JSON.stringify(t.kernelSize)+".")},e.className="Conv1D",e}(Ru);e.serialization.registerClass(Wu);var Uu=function(t){function n(e){var n=t.call(this,e)||this;return"number"==typeof e.cropping?n.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:"number"==typeof e.cropping[0]?n.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:n.cropping=e.cropping,n.dataFormat=void 0===e.dataFormat?"channelsLast":e.dataFormat,n.inputSpec=[{ndim:4}],n}return fi(n,t),n.prototype.computeOutputShape=function(t){return"channelsFirst"===this.dataFormat?[t[0],t[1],t[2]-this.cropping[0][0]-this.cropping[0][1],t[3]-this.cropping[1][0]-this.cropping[1][1]]:[t[0],t[1]-this.cropping[0][0]-this.cropping[0][1],t[2]-this.cropping[1][0]-this.cropping[1][1],t[3]]},n.prototype.call=function(t,n){var r=this;return e.tidy((function(){if(t=hs(t),"channelsLast"===r.dataFormat){var e=xa(t,r.cropping[0][0],t.shape[1]-r.cropping[0][0]-r.cropping[0][1],2);return xa(e,r.cropping[1][0],t.shape[2]-r.cropping[1][1]-r.cropping[1][0],3)}e=xa(t,r.cropping[0][0],t.shape[2]-r.cropping[0][0]-r.cropping[0][1],3);return xa(e,r.cropping[1][0],t.shape[3]-r.cropping[1][1]-r.cropping[1][0],4)}))},n.prototype.getConfig=function(){var e={cropping:this.cropping,dataFormat:this.dataFormat},n=t.prototype.getConfig.call(this);return Object.assign(e,n),e},n.className="Cropping2D",n}(Ns);e.serialization.registerClass(Uu);var ju=function(t){function n(e){var n,r=t.call(this,e)||this;return r.DEFAULT_SIZE=[2,2],r.inputSpec=[{ndim:4}],r.size=null==e.size?r.DEFAULT_SIZE:e.size,r.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,oa(r.dataFormat),r.interpolation=null==e.interpolation?"nearest":e.interpolation,n=r.interpolation,Pi(na,"InterpolationFormat",n),r}return fi(n,t),n.prototype.computeOutputShape=function(t){if("channelsFirst"===this.dataFormat){var e=null==t[2]?null:this.size[0]*t[2],n=null==t[3]?null:this.size[1]*t[3];return[t[0],t[1],e,n]}e=null==t[1]?null:this.size[0]*t[1],n=null==t[2]?null:this.size[1]*t[2];return[t[0],e,n,t[3]]},n.prototype.call=function(t,n){var r=this;return e.tidy((function(){var n=hs(t),i=n.shape;if("channelsFirst"===r.dataFormat){n=e.transpose(n,[0,2,3,1]);var a=r.size[0]*i[2],s=r.size[1]*i[3],o="nearest"===r.interpolation?e.image.resizeNearestNeighbor(n,[a,s]):e.image.resizeBilinear(n,[a,s]);return e.transpose(o,[0,3,1,2])}a=r.size[0]*i[1],s=r.size[1]*i[2];return"nearest"===r.interpolation?e.image.resizeNearestNeighbor(n,[a,s]):e.image.resizeBilinear(n,[a,s])}))},n.prototype.getConfig=function(){var e={size:this.size,dataFormat:this.dataFormat},n=t.prototype.getConfig.call(this);return Object.assign(e,n),e},n.className="UpSampling2D",n}(Ns);e.serialization.registerClass(ju);var Vu=function(t){function n(e){var n=t.call(this,2,e)||this;return n.depthwiseKernel=null,n.depthMultiplier=null==e.depthMultiplier?1:e.depthMultiplier,n.depthwiseInitializer=rs(e.depthwiseInitializer||n.DEFAULT_KERNEL_INITIALIZER),n.depthwiseConstraint=Qi(e.depthwiseConstraint),n.depthwiseRegularizer=ku(e.depthwiseRegularizer),n}return fi(n,t),n.prototype.build=function(t){if((t=ps(t)).length<4)throw new Si("Inputs to DepthwiseConv2D should have rank 4. Received input shape: "+JSON.stringify(t)+".");var e="channelsFirst"===this.dataFormat?1:3;if(null==t[e]||t[e]<0)throw new Si("The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not ("+t[e]+").");var n=t[e],r=[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",r,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0},n.prototype.call=function(t,n){var r=this;return e.tidy((function(){t=hs(t);var n,i,a,s,o,u,l=(n=t,i=r.depthwiseKernel.read(),a=r.strides,s=r.padding,o=r.dataFormat,u=null,void 0===a&&(a=[1,1]),void 0===s&&(s="valid"),e.tidy((function(){null==o&&(o="channelsLast"),oa(o);var t=Fu(n,o);if(4!==n.rank)throw new Si("Input for depthwiseConv2d is required to be 4-D, but is instead "+n.rank+"-D");if(4!==i.rank)throw new Si("depthwiseKernel is required to be 4-D, but is instead "+i.rank+"-D");return t=e.depthwiseConv2d(t,i,a,"same"===s?"same":"valid","NHWC",u),"channelsFirst"===o&&(t=e.transpose(t,[0,3,1,2])),t})));return r.useBias&&(l=La(l,r.bias.read(),r.dataFormat)),null!=r.activation&&(l=r.activation.apply(l)),l}))},n.prototype.computeOutputShape=function(t){t=ps(t);var e="channelsFirst"===this.dataFormat?t[2]:t[1],n="channelsFirst"===this.dataFormat?t[3]:t[2],r="channelsFirst"===this.dataFormat?t[1]*this.depthMultiplier:t[3]*this.depthMultiplier,i=Tu(e,this.kernelSize[0],this.padding,this.strides[0]),a=Tu(n,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[t[0],r,i,a]:[t[0],i,a,r]},n.prototype.getConfig=function(){var e=t.prototype.getConfig.call(this);return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=ns(this.depthwiseInitializer),e.depthwiseRegularizer=bu(this.depthwiseRegularizer),e.depthwiseConstraint=Yi(this.depthwiseRegularizer),e},n.className="DepthwiseConv2D",n}(_u);function Ku(t,e,n,r){if(Array.isArray(t)){if(null!=e||null!=n)throw new Si("When inputs is an array, neither initialState or constants should be provided");null!=r&&(n=t.slice(t.length-r,t.length),t=t.slice(0,t.length-r)),t.length>1&&(e=t.slice(1,t.length)),t=t[0]}function i(t){return null==t||Array.isArray(t)?t:[t]}return{inputs:t,initialState:e=i(e),constants:n=i(n)}}function qu(t,n,r,i,a,s,o,u){return void 0===i&&(i=!1),void 0===o&&(o=!1),void 0===u&&(u=!1),e.tidy((function(){var l=n.shape.length;if(l<3)throw new Si("Input should be at least 3D, but is "+l+"D.");var c=[1,0].concat(ba(2,l));if(n=e.transpose(n,c),null!=s)throw new Ni("The rnn() functoin of the deeplearn.js backend does not support constants yet.");o&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),null!=a&&((a=e.cast(e.cast(a,"bool"),"float32")).rank===l-1&&(a=e.expandDims(a,-1)),a=e.transpose(a,c)),i&&(n=e.reverse(n,0),null!=a&&(a=e.reverse(a,0)));var h,p,d=[],f=r,g=n.shape[0],m=e.unstack(n);null!=a&&(p=e.unstack(a));for(var y,v=function(n){var r=m[n],i=e.tidy((function(){return t(r,f)}));if(null==a)h=i[0],f=i[1];else{var s=e.tidy((function(){var t=p[n],r=e.sub(e.onesLike(t),t);return{output:e.add(e.mul(i[0],t),e.mul(f[0],r)),newStates:f.map((function(n,a){return e.add(e.mul(i[1][a],t),e.mul(n,r))}))}}));h=s.output,f=s.newStates}u&&d.push(h)},b=0;b<g;++b)v(b);if(u){y=e.stack(d,1)}return[h,y,f]}))}e.serialization.registerClass(Vu);var Gu=function(t){function n(e){var n,r=t.call(this,e)||this;if(null==e.cell)throw new Si("cell property is missing for the constructor of RNN.");if(null==(n=Array.isArray(e.cell)?new el({cells:e.cell}):e.cell).stateSize)throw new Si("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");return r.cell=n,r.returnSequences=null!=e.returnSequences&&e.returnSequences,r.returnState=null!=e.returnState&&e.returnState,r.goBackwards=null!=e.goBackwards&&e.goBackwards,r._stateful=null!=e.stateful&&e.stateful,r.unroll=null!=e.unroll&&e.unroll,r.supportsMasking=!0,r.inputSpec=[new vs({ndim:3})],r.stateSpec=null,r.states_=null,r.numConstants=null,r.keptStates=[],r}return fi(n,t),n.prototype.getStates=function(){return null==this.states_?ba(0,Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1).map((function(t){return null})):this.states_},n.prototype.setStates=function(t){this.states_=t},n.prototype.computeOutputShape=function(t){ls(t)&&(t=t[0]),t=t;var e=this.cell.stateSize;Array.isArray(e)||(e=[e]);var n,r=e[0];if(n=this.returnSequences?[t[0],t[1],r]:[t[0],r],this.returnState){for(var i=[],a=0,s=e;a<s.length;a++){var o=s[a];i.push([t[0],o])}return[n].concat(i)}return n},n.prototype.computeMask=function(t,n){var r=this;return e.tidy((function(){Array.isArray(n)&&(n=n[0]);var t=r.returnSequences?n:null;if(r.returnState){var e=r.states.map((function(t){return null}));return[t].concat(e)}return t}))},Object.defineProperty(n.prototype,"states",{get:function(){if(null==this.states_){for(var t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,e=[],n=0;n<t;++n)e.push(null);return e}return this.states_},set:function(t){this.states_=t},enumerable:!0,configurable:!0}),n.prototype.build=function(t){if(null!=this.numConstants)throw new Ni("Constants support is not implemented in RNN yet.");ls(t)&&(t=t[0]),t=t;var n=this.stateful?t[0]:null,r=t.slice(2);this.inputSpec[0]=new vs({shape:[n,null].concat(r)});var i,a=[t[0]].concat(t.slice(2));if(this.cell.build(a),i=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!e.util.arraysEqual(this.stateSpec.map((function(t){return t.shape[t.shape.length-1]})),i))throw new Si("An initialState was passed that is not compatible with cell.stateSize. Received stateSpec="+this.stateSpec+"; However cell.stateSize is "+this.cell.stateSize)}else this.stateSpec=i.map((function(t){return new vs({shape:[null,t]})}));this.stateful&&this.resetStates()},n.prototype.resetStates=function(t,n){var r=this;void 0===n&&(n=!1),e.tidy((function(){if(!r.stateful)throw new wi("Cannot call resetStates() on an RNN Layer that is not stateful.");var i=r.inputSpec[0].shape[0];if(null==i)throw new Si("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==r.states_)Array.isArray(r.cell.stateSize)?r.states_=r.cell.stateSize.map((function(t){return e.zeros([i,t])})):r.states_=[e.zeros([i,r.cell.stateSize])];else if(null==t)e.dispose(r.states_),null!=r.keptStates&&(e.dispose(r.keptStates),r.keptStates=[]),Array.isArray(r.cell.stateSize)?r.states_=r.cell.stateSize.map((function(t){return e.zeros([i,t])})):r.states_[0]=e.zeros([i,r.cell.stateSize]);else{if(Array.isArray(t)||(t=[t]),t.length!==r.states_.length)throw new Si("Layer "+r.name+" expects "+r.states_.length+" state(s), but it received "+t.length+" state value(s). Input received: "+t);!0===n?r.keptStates.push(r.states_.slice()):e.dispose(r.states_);for(var a=0;a<r.states_.length;++a){var s=t[a],o=Array.isArray(r.cell.stateSize)?r.cell.stateSize[a]:r.cell.stateSize,u=[i,o];if(!e.util.arraysEqual(s.shape,u))throw new Si("State "+a+" is incompatible with layer "+r.name+": expected shape="+u+", received shape="+s.shape);r.states_[a]=s}}r.states_=r.states_.map((function(t){return e.keep(t.clone())}))}))},n.prototype.apply=function(e,n){var r=null==n?null:n.initialState,i=null==n?null:n.constants;null==n&&(n={});var a=Ku(e,r,i,this.numConstants);e=a.inputs,r=a.initialState,i=a.constants;var s=[],o=[];if(null!=r){n.initialState=r,s=s.concat(r),this.stateSpec=[];for(var u=0,l=r;u<l.length;u++){var c=l[u];this.stateSpec.push(new vs({shape:c.shape}))}o=o.concat(this.stateSpec)}if(null!=i&&(n.constants=i,s=s.concat(i),this.numConstants=i.length),s[0]instanceof bs){var h=[e].concat(s),p=this.inputSpec.concat(o),d=this.inputSpec;this.inputSpec=p;var f=t.prototype.apply.call(this,h,n);return this.inputSpec=d,f}return t.prototype.apply.call(this,e,n)},n.prototype.call=function(t,n){var r=this;return e.tidy((function(){var e=null==n?null:n.mask,i=null==n?null:n.training,a=null==n?null:n.initialState;t=hs(t),null==a&&(a=r.stateful?r.states_:r.getInitialState(t));var s=Array.isArray(r.cell.stateSize)?r.cell.stateSize.length:1;if(a.length!==s)throw new Si("RNN Layer has "+s+" state(s) but was passed "+a.length+" initial state(s).");r.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");var o={training:i},u=qu((function(t,e){var n=r.cell.call([t].concat(e),o);return[n[0],n.slice(1)]}),t,a,r.goBackwards,e,null,r.unroll,r.returnSequences),l=u[0],c=u[1],h=u[2];r.stateful&&r.resetStates(h,i);var p=r.returnSequences?c:l;return r.returnState?[p].concat(h):p}))},n.prototype.getInitialState=function(t){var n=this;return e.tidy((function(){var r=e.zeros(t.shape);return r=ka(r=e.sum(r,[1,2])),Array.isArray(n.cell.stateSize)?n.cell.stateSize.map((function(t){return t>1?Aa(r,[1,t]):r})):n.cell.stateSize>1?[Aa(r,[1,n.cell.stateSize])]:[r]}))},Object.defineProperty(n.prototype,"trainableWeights",{get:function(){return this.trainable?this.cell.trainableWeights:[]},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"nonTrainableWeights",{get:function(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights},enumerable:!0,configurable:!0}),n.prototype.setFastWeightInitDuringBuild=function(e){t.prototype.setFastWeightInitDuringBuild.call(this,e),null!=this.cell&&this.cell.setFastWeightInitDuringBuild(e)},n.prototype.getConfig=function(){var e=t.prototype.getConfig.call(this),r={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(r.numConstants=this.numConstants);var i=this.cell.getConfig();return this.getClassName()===n.className&&(r.cell={className:this.cell.getClassName(),config:i}),mi({},i,e,r)},n.fromConfig=function(t,e,n){void 0===n&&(n={});var r=Bs(e.cell,n);return new t(Object.assign(e,{cell:r}))},n.className="RNN",n}(Ns);e.serialization.registerClass(Gu);var Hu=function(t){function e(){return null!==t&&t.apply(this,arguments)||this}return fi(e,t),e}(Ns),Ju=function(t){function n(e){var n=t.call(this,e)||this;return n.DEFAULT_ACTIVATION="tanh",n.DEFAULT_KERNEL_INITIALIZER="glorotNormal",n.DEFAULT_RECURRENT_INITIALIZER="orthogonal",n.DEFAULT_BIAS_INITIALIZER="zeros",n.units=e.units,Wi(n.units,"units"),n.activation=fu(null==e.activation?n.DEFAULT_ACTIVATION:e.activation),n.useBias=null==e.useBias||e.useBias,n.kernelInitializer=rs(e.kernelInitializer||n.DEFAULT_KERNEL_INITIALIZER),n.recurrentInitializer=rs(e.recurrentInitializer||n.DEFAULT_RECURRENT_INITIALIZER),n.biasInitializer=rs(e.biasInitializer||n.DEFAULT_BIAS_INITIALIZER),n.kernelRegularizer=ku(e.kernelRegularizer),n.recurrentRegularizer=ku(e.recurrentRegularizer),n.biasRegularizer=ku(e.biasRegularizer),n.kernelConstraint=Qi(e.kernelConstraint),n.recurrentConstraint=Qi(e.recurrentConstraint),n.biasConstraint=Qi(e.biasConstraint),n.dropout=ya([1,va([0,null==e.dropout?0:e.dropout])]),n.recurrentDropout=ya([1,va([0,null==e.recurrentDropout?0:e.recurrentDropout])]),n.stateSize=n.units,n.dropoutMask=null,n.recurrentDropoutMask=null,n}return fi(n,t),n.prototype.build=function(t){t=ps(t),this.kernel=this.addWeight("kernel",[t[t.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0},n.prototype.call=function(t,n){var r=this;return e.tidy((function(){if(2!==(t=t).length)throw new Si("SimpleRNNCell expects 2 input Tensors, got "+t.length+".");var i=t[1];t=t[0];var a,s=null!=n.training&&n.training;0<r.dropout&&r.dropout<1&&null==r.dropoutMask&&(r.dropoutMask=nl({ones:function(){return e.onesLike(t)},rate:r.dropout,training:s})),0<r.recurrentDropout&&r.recurrentDropout<1&&null==r.recurrentDropoutMask&&(r.recurrentDropoutMask=nl({ones:function(){return e.onesLike(i)},rate:r.recurrentDropout,training:s}));var o=r.dropoutMask,u=r.recurrentDropoutMask;a=Ta(null!=o?e.mul(t,o):t,r.kernel.read()),null!=r.bias&&(a=La(a,r.bias.read())),null!=u&&(i=e.mul(i,u));var l=e.add(a,Ta(i,r.recurrentKernel.read()));return null!=r.activation&&(l=r.activation.apply(l)),[l,l]}))},n.prototype.getConfig=function(){var e=t.prototype.getConfig.call(this),n={units:this.units,activation:pu(this.activation),useBias:this.useBias,kernelInitializer:ns(this.kernelInitializer),recurrentInitializer:ns(this.recurrentInitializer),biasInitializer:ns(this.biasInitializer),kernelRegularizer:bu(this.kernelRegularizer),recurrentRegularizer:bu(this.recurrentRegularizer),biasRegularizer:bu(this.biasRegularizer),activityRegularizer:bu(this.activityRegularizer),kernelConstraint:Yi(this.kernelConstraint),recurrentConstraint:Yi(this.recurrentConstraint),biasConstraint:Yi(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return mi({},e,n)},n.className="SimpleRNNCell",n}(Hu);e.serialization.registerClass(Ju);var Zu=function(t){function n(e){return e.cell=new Ju(e),t.call(this,e)||this}return fi(n,t),n.prototype.call=function(n,r){var i=this;return e.tidy((function(){null!=i.cell.dropoutMask&&(e.dispose(i.cell.dropoutMask),i.cell.dropoutMask=null),null!=i.cell.recurrentDropoutMask&&(e.dispose(i.cell.recurrentDropoutMask),i.cell.recurrentDropoutMask=null);var a=null==r?null:r.mask,s=null==r?null:r.training,o=null==r?null:r.initialState;return t.prototype.call.call(i,n,{mask:a,training:s,initialState:o})}))},n.fromConfig=function(t,e){return new t(e)},n.className="SimpleRNN",n}(Gu);e.serialization.registerClass(Zu);var Yu=function(t){function n(e){var n=t.call(this,e)||this;if(n.DEFAULT_ACTIVATION="tanh",n.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",n.DEFAULT_KERNEL_INITIALIZER="glorotNormal",n.DEFAULT_RECURRENT_INITIALIZER="orthogonal",n.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new Si("GRUCell does not support reset_after parameter set to true.");return n.units=e.units,Wi(n.units,"units"),n.activation=fu(void 0===e.activation?n.DEFAULT_ACTIVATION:e.activation),n.recurrentActivation=fu(void 0===e.recurrentActivation?n.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),n.useBias=null==e.useBias||e.useBias,n.kernelInitializer=rs(e.kernelInitializer||n.DEFAULT_KERNEL_INITIALIZER),n.recurrentInitializer=rs(e.recurrentInitializer||n.DEFAULT_RECURRENT_INITIALIZER),n.biasInitializer=rs(e.biasInitializer||n.DEFAULT_BIAS_INITIALIZER),n.kernelRegularizer=ku(e.kernelRegularizer),n.recurrentRegularizer=ku(e.recurrentRegularizer),n.biasRegularizer=ku(e.biasRegularizer),n.kernelConstraint=Qi(e.kernelConstraint),n.recurrentConstraint=Qi(e.recurrentConstraint),n.biasConstraint=Qi(e.biasConstraint),n.dropout=ya([1,va([0,null==e.dropout?0:e.dropout])]),n.recurrentDropout=ya([1,va([0,null==e.recurrentDropout?0:e.recurrentDropout])]),n.implementation=e.implementation,n.stateSize=n.units,n.dropoutMask=null,n.recurrentDropoutMask=null,n}return fi(n,t),n.prototype.build=function(t){var e=(t=ps(t))[t.length-1];this.kernel=this.addWeight("kernel",[e,3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0},n.prototype.call=function(t,n){var r=this;return e.tidy((function(){if(2!==(t=t).length)throw new Si("GRUCell expects 2 input Tensors (inputs, h, c), got "+t.length+".");var i=null!=n.training&&n.training,a=t[1];t=t[0],0<r.dropout&&r.dropout<1&&null==r.dropoutMask&&(r.dropoutMask=nl({ones:function(){return e.onesLike(t)},rate:r.dropout,training:i,count:3})),0<r.recurrentDropout&&r.recurrentDropout<1&&null==r.recurrentDropoutMask&&(r.recurrentDropoutMask=nl({ones:function(){return e.onesLike(a)},rate:r.recurrentDropout,training:i,count:3}));var s,o,u,l=r.dropoutMask,c=r.recurrentDropoutMask;0<r.dropout&&r.dropout<1&&(t=e.mul(t,l[0]));var h=Ta(t,r.kernel.read());r.useBias&&(h=La(h,r.bias.read())),0<r.recurrentDropout&&r.recurrentDropout<1&&(a=e.mul(a,c[0]));var p=r.recurrentKernel.read(),d=e.split(p,[2*r.units,r.units],p.rank-1),f=d[0],g=d[1],m=Ta(a,f),y=e.split(h,3,h.rank-1),v=y[0],b=y[1],w=y[2],k=e.split(m,2,m.rank-1),S=k[0],N=k[1];s=r.recurrentActivation.apply(e.add(v,S)),o=r.recurrentActivation.apply(e.add(b,N));var x=Ta(e.mul(o,a),g);u=r.activation.apply(e.add(w,x));var z=e.add(e.mul(s,a),e.mul(e.add(1,e.neg(s)),u));return[z,z]}))},n.prototype.getConfig=function(){var e=t.prototype.getConfig.call(this),n={units:this.units,activation:pu(this.activation),recurrentActivation:pu(this.recurrentActivation),useBias:this.useBias,kernelInitializer:ns(this.kernelInitializer),recurrentInitializer:ns(this.recurrentInitializer),biasInitializer:ns(this.biasInitializer),kernelRegularizer:bu(this.kernelRegularizer),recurrentRegularizer:bu(this.recurrentRegularizer),biasRegularizer:bu(this.biasRegularizer),activityRegularizer:bu(this.activityRegularizer),kernelConstraint:Yi(this.kernelConstraint),recurrentConstraint:Yi(this.recurrentConstraint),biasConstraint:Yi(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return mi({},e,n)},n.className="GRUCell",n}(Hu);e.serialization.registerClass(Yu);var Xu=function(t){function n(e){return 0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new Yu(e),t.call(this,e)||this}return fi(n,t),n.prototype.call=function(n,r){var i=this;return e.tidy((function(){null!=i.cell.dropoutMask&&(e.dispose(i.cell.dropoutMask),i.cell.dropoutMask=null),null!=i.cell.recurrentDropoutMask&&(e.dispose(i.cell.recurrentDropoutMask),i.cell.recurrentDropoutMask=null);var a=null==r?null:r.mask,s=null==r?null:r.training,o=null==r?null:r.initialState;return t.prototype.call.call(i,n,{mask:a,training:s,initialState:o})}))},n.fromConfig=function(t,e){return 0===e.implmentation&&(e.implementation=1),new t(e)},n.className="GRU",n}(Gu);e.serialization.registerClass(Xu);var Qu=function(t){function n(e){var n=t.call(this,e)||this;return n.DEFAULT_ACTIVATION="tanh",n.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",n.DEFAULT_KERNEL_INITIALIZER="glorotNormal",n.DEFAULT_RECURRENT_INITIALIZER="orthogonal",n.DEFAULT_BIAS_INITIALIZER="zeros",n.units=e.units,Wi(n.units,"units"),n.activation=fu(void 0===e.activation?n.DEFAULT_ACTIVATION:e.activation),n.recurrentActivation=fu(void 0===e.recurrentActivation?n.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),n.useBias=null==e.useBias||e.useBias,n.kernelInitializer=rs(e.kernelInitializer||n.DEFAULT_KERNEL_INITIALIZER),n.recurrentInitializer=rs(e.recurrentInitializer||n.DEFAULT_RECURRENT_INITIALIZER),n.biasInitializer=rs(e.biasInitializer||n.DEFAULT_BIAS_INITIALIZER),n.unitForgetBias=e.unitForgetBias,n.kernelRegularizer=ku(e.kernelRegularizer),n.recurrentRegularizer=ku(e.recurrentRegularizer),n.biasRegularizer=ku(e.biasRegularizer),n.kernelConstraint=Qi(e.kernelConstraint),n.recurrentConstraint=Qi(e.recurrentConstraint),n.biasConstraint=Qi(e.biasConstraint),n.dropout=ya([1,va([0,null==e.dropout?0:e.dropout])]),n.recurrentDropout=ya([1,va([0,null==e.recurrentDropout?0:e.recurrentDropout])]),n.implementation=e.implementation,n.stateSize=[n.units,n.units],n.dropoutMask=null,n.recurrentDropoutMask=null,n}return fi(n,t),n.prototype.build=function(t){var e,n,r=(t=ps(t))[t.length-1];if(this.kernel=this.addWeight("kernel",[r,4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){var i=this.biasInitializer,a=this.units;n=new((e=function(t){function e(){return null!==t&&t.apply(this,arguments)||this}return fi(e,t),e.prototype.apply=function(t,e){var n=i.apply([a]),r=(new $a).apply([a]),s=i.apply([2*a]);return Ia(Ia(n,r),s)},e}(Ba)).className="CustomInit",e)}else n=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,n,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0},n.prototype.call=function(t,n){var r=this;return e.tidy((function(){var i=null!=n.training&&n.training;if(3!==(t=t).length)throw new Si("LSTMCell expects 3 input Tensors (inputs, h, c), got "+t.length+".");var a=t[1],s=t[2];t=t[0],0<r.dropout&&r.dropout<1&&null==r.dropoutMask&&(r.dropoutMask=nl({ones:function(){return e.onesLike(t)},rate:r.dropout,training:i,count:4})),0<r.recurrentDropout&&r.recurrentDropout<1&&null==r.recurrentDropoutMask&&(r.recurrentDropoutMask=nl({ones:function(){return e.onesLike(a)},rate:r.recurrentDropout,training:i,count:4}));var o,u,l,c,h=r.dropoutMask,p=r.recurrentDropoutMask;0<r.dropout&&r.dropout<1&&(t=e.mul(t,h[0]));var d=Ta(t,r.kernel.read());0<r.recurrentDropout&&r.recurrentDropout<1&&(a=e.mul(a,p[0])),d=e.add(d,Ta(a,r.recurrentKernel.read())),r.useBias&&(d=La(d,r.bias.read()));var f=e.split(d,4,d.rank-1),g=f[0],m=f[1],y=f[2],v=f[3];o=r.recurrentActivation.apply(g),u=r.recurrentActivation.apply(m),l=e.add(e.mul(u,s),e.mul(o,r.activation.apply(y))),c=r.recurrentActivation.apply(v);var b=e.mul(c,r.activation.apply(l));return[b,b,l]}))},n.prototype.getConfig=function(){var e=t.prototype.getConfig.call(this),n={units:this.units,activation:pu(this.activation),recurrentActivation:pu(this.recurrentActivation),useBias:this.useBias,kernelInitializer:ns(this.kernelInitializer),recurrentInitializer:ns(this.recurrentInitializer),biasInitializer:ns(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:bu(this.kernelRegularizer),recurrentRegularizer:bu(this.recurrentRegularizer),biasRegularizer:bu(this.biasRegularizer),activityRegularizer:bu(this.activityRegularizer),kernelConstraint:Yi(this.kernelConstraint),recurrentConstraint:Yi(this.recurrentConstraint),biasConstraint:Yi(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return mi({},e,n)},n.className="LSTMCell",n}(Hu);e.serialization.registerClass(Qu);var tl=function(t){function n(e){return 0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new Qu(e),t.call(this,e)||this}return fi(n,t),n.prototype.call=function(n,r){var i=this;return e.tidy((function(){null!=i.cell.dropoutMask&&(e.dispose(i.cell.dropoutMask),i.cell.dropoutMask=null),null!=i.cell.recurrentDropoutMask&&(e.dispose(i.cell.recurrentDropoutMask),i.cell.recurrentDropoutMask=null);var a=null==r?null:r.mask,s=null==r?null:r.training,o=null==r?null:r.initialState;return t.prototype.call.call(i,n,{mask:a,training:s,initialState:o})}))},n.fromConfig=function(t,e){return 0===e.implmentation&&(e.implementation=1),new t(e)},n.className="LSTM",n}(Gu);e.serialization.registerClass(tl);var el=function(t){function n(e){var n=t.call(this,e)||this;return n.cells=e.cells,n}return fi(n,t),Object.defineProperty(n.prototype,"stateSize",{get:function(){for(var t=[],e=0,n=this.cells.slice().reverse();e<n.length;e++){var r=n[e];Array.isArray(r.stateSize)?t.push.apply(t,r.stateSize):t.push(r.stateSize)}return t},enumerable:!0,configurable:!0}),n.prototype.call=function(t,n){var r=this;return e.tidy((function(){for(var e=(t=t).slice(1),i=[],a=0,s=r.cells.slice().reverse();a<s.length;a++){var o=s[a];Array.isArray(o.stateSize)?i.push(e.splice(0,o.stateSize.length)):i.push(e.splice(0,1))}i.reverse();for(var u,l=[],c=0;c<r.cells.length;++c){o=r.cells[c];e=i[c],u=0===c?[t[0]].concat(e):[u[0]].concat(e),u=o.call(u,n),l.push(u.slice(1))}e=[];for(var h=0,p=l.slice().reverse();h<p.length;h++){var d=p[h];e.push.apply(e,d)}return[u[0]].concat(e)}))},n.prototype.build=function(t){var e;ls(t)&&(t=t[0]),t=t,this.cells.forEach((function(n,r){ha("RNNCell_"+r,(function(){n.build(t),e=Array.isArray(n.stateSize)?n.stateSize[0]:n.stateSize,t=[t[0],e]}))})),this.built=!0},n.prototype.getConfig=function(){var e=t.prototype.getConfig.call(this),n=this.cells.map((function(t){return{className:t.getClassName(),config:t.getConfig()}}));return mi({},e,{cells:n})},n.fromConfig=function(t,e,n){void 0===n&&(n={});for(var r=[],i=0,a=e.cells;i<a.length;i++){var s=a[i];r.push(Bs(s,n))}return new t({cells:r})},Object.defineProperty(n.prototype,"trainableWeights",{get:function(){if(!this.trainable)return[];for(var t=[],e=0,n=this.cells;e<n.length;e++){var r=n[e];t.push.apply(t,r.trainableWeights)}return t},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"nonTrainableWeights",{get:function(){for(var t=[],e=0,n=this.cells;e<n.length;e++){var r=n[e];t.push.apply(t,r.nonTrainableWeights)}if(!this.trainable){for(var i=[],a=0,s=this.cells;a<s.length;a++){r=s[a];i.push.apply(i,r.trainableWeights)}return i.concat(t)}return t},enumerable:!0,configurable:!0}),n.prototype.getWeights=function(){for(var t=[],e=0,n=this.cells;e<n.length;e++){var r=n[e];t.push.apply(t,r.weights)}return ms(t)},n.prototype.setWeights=function(t){for(var e=[],n=0,r=this.cells;n<r.length;n++)for(var i=r[n],a=i.weights.length,s=t.splice(a),o=0;o<i.weights.length;++o)e.push([i.weights[o],s[o]]);ys(e)},n.className="StackedRNNCells",n}(Hu);function nl(t){var n=t.ones,r=t.rate,i=t.training,a=void 0!==i&&i,s=t.count,o=void 0===s?1:s,u=function(){return _a(n(),r)},l=function(){return Ra(u,n,a)};return!o||o<=1?e.keep(l().clone()):Array(o).fill(void 0).map(l).map((function(t){return e.keep(t.clone())}))}e.serialization.registerClass(el);!function(t){function e(){return null!==t&&t.apply(this,arguments)||this}fi(e,t)}(Hu);var rl=function(t){function n(e){var n=this;if(e.unroll)throw new Ni("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new Ni("It is not possible at the moment to stack convolutional cells.");return(n=t.call(this,e)||this).inputSpec=[new vs({ndim:5})],n}return fi(n,t),n.prototype.call=function(n,r){var i=this;return e.tidy((function(){if(null!=i.cell.dropoutMask&&(e.dispose(i.cell.dropoutMask),i.cell.dropoutMask=null),null!=i.cell.recurrentDropoutMask&&(e.dispose(i.cell.recurrentDropoutMask),i.cell.recurrentDropoutMask=null),r&&r.constants)throw new Si("ConvRNN2D cell does not support constants");var a=null==r?null:r.mask,s=null==r?null:r.training,o=null==r?null:r.initialState;return t.prototype.call.call(i,n,{mask:a,training:s,initialState:o})}))},n.prototype.computeOutputShape=function(t){var e=this.computeSingleOutputShape(t);return this.returnSequences||(e=[e[0]].concat(e.slice(2))),this.returnState&&(e=[e].concat(Array(2).fill([t[0]].concat(e.slice(-3))))),e},n.prototype.getInitialState=function(t){var n=this;return e.tidy((function(){var r=n.cell.stateSize,i=t.shape,a=n.computeSingleOutputShape(i),s=[a[0]].concat(a.slice(2)),o=e.zeros(s);return Array.isArray(r)?Array(r.length).fill(o):[o]}))},n.prototype.resetStates=function(t,n){var r=this;void 0===n&&(n=!1),e.tidy((function(){if(!r.stateful)throw new wi("Cannot call resetStates() on an RNN Layer that is not stateful.");var i=r.inputSpec[0].shape,a=r.computeSingleOutputShape(i),s=[a[0]].concat(a.slice(2));if(null==i[0])throw new Si("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==r.getStates())Array.isArray(r.cell.stateSize)?r.states_=r.cell.stateSize.map((function(){return e.zeros(s)})):r.states_=[e.zeros(s)];else if(null==t)e.dispose(r.states_),null!=r.keptStates&&(e.dispose(r.keptStates),r.keptStates=[]),Array.isArray(r.cell.stateSize)?r.states_=r.cell.stateSize.map((function(){return e.zeros(s)})):r.states_[0]=e.zeros(s);else{if(Array.isArray(t)||(t=[t]),t.length!==r.states_.length)throw new Si("Layer "+r.name+" expects "+r.states_.length+" state(s), but it received "+t.length+" state value(s). Input received: "+t);n?r.keptStates.push(r.states_.slice()):e.dispose(r.states_);for(var o=0;o<r.states_.length;++o){var u=t[o],l=s;if(!e.util.arraysEqual(u.shape,l))throw new Si("State "+o+" is incompatible with layer "+r.name+": expected shape="+l+", received shape="+u.shape);r.states_[o]=u}}r.states_=r.states_.map((function(t){return e.keep(t.clone())}))}))},n.prototype.computeSingleOutputShape=function(t){var e=this.cell,n=e.dataFormat,r=e.filters,i=e.kernelSize,a=e.padding,s=e.strides,o=e.dilationRate,u="channelsFirst"===n,l=t[u?3:2],c=t[u?4:3],h=Tu(l,i[0],a,s[0],o[0]),p=Tu(c,i[1],a,s[1],o[1]);return t.slice(0,2).concat(u?[r,h,p]:[h,p,r])},n.className="ConvRNN2D",n}(Gu),il=function(t){function n(e){var n=this,r=e.filters,i=e.kernelSize,a=e.strides,s=e.padding,o=e.dataFormat,u=e.dilationRate;return(n=t.call(this,mi({},e,{units:r}))||this).filters=r,Wi(n.filters,"filters"),n.kernelSize=Cu(i,2,"kernelSize"),n.kernelSize.forEach((function(t){return Wi(t,"kernelSize")})),n.strides=Cu(a||1,2,"strides"),n.strides.forEach((function(t){return Wi(t,"strides")})),n.padding=s||"valid",ua(n.padding),n.dataFormat=o||"channelsLast",oa(n.dataFormat),n.dilationRate=Cu(u||1,2,"dilationRate"),n.dilationRate.forEach((function(t){return Wi(t,"dilationRate")})),n}return fi(n,t),n.prototype.build=function(t){var n;t=ps(t);var r="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[r])throw new Si("The channel dimension of the input should be defined. Found "+t[r]);var i=t[r],a=this.kernelSize.concat([i,4*this.filters]);this.kernel=this.addWeight("kernel",a,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);var s=this.kernelSize.concat([this.filters,4*this.filters]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",s,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){var o=void 0;if(this.unitForgetBias){var u=this.biasInitializer,l=this.filters;o=new((n=function(t){function n(){return null!==t&&t.apply(this,arguments)||this}return fi(n,t),n.prototype.apply=function(t,n){return za([u.apply([l]),e.ones([l]),u.apply([2*l])])},n}(Ba)).className="CustomInit",n)}else o=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.filters],null,o,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0},n.prototype.call=function(t,n){var r=this;return e.tidy((function(){if(3!==t.length)throw new Si("ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got "+t.length+".");var i=n.training||!1,a=t[0],s=t[1],o=t[2];0<r.dropout&&r.dropout<1&&null==r.dropoutMask&&(r.dropoutMask=nl({ones:function(){return e.onesLike(a)},rate:r.dropout,training:i,count:4}));var u=r.dropoutMask,l=function(t,n,r){return n&&n[r]?e.mul(n[r],t):t},c=l(a,u,0),h=l(a,u,1),p=l(a,u,2),d=l(a,u,3);0<r.recurrentDropout&&r.recurrentDropout<1&&null==r.recurrentDropoutMask&&(r.recurrentDropoutMask=nl({ones:function(){return e.onesLike(s)},rate:r.recurrentDropout,training:i,count:4}));var f=r.recurrentDropoutMask,g=l(s,f,0),m=l(s,f,1),y=l(s,f,2),v=l(s,f,3),b=e.split(r.kernel.read(),4,3),w=b[0],k=b[1],S=b[2],N=b[3],x=r.useBias?e.split(r.bias.read(),4):[null,null,null,null],z=x[0],I=x[1],A=x[2],C=x[3];c=r.inputConv(c,w,z,r.padding),h=r.inputConv(h,k,I,r.padding),p=r.inputConv(p,S,A,r.padding),d=r.inputConv(d,N,C,r.padding);var T=e.split(r.recurrentKernel.read(),4,3),E=T[0],F=T[1],D=T[2],L=T[3];g=r.recurrentConv(g,E),m=r.recurrentConv(m,F),y=r.recurrentConv(y,D),v=r.recurrentConv(v,L);var _=r.recurrentActivation.apply(e.add(c,g)),R=r.recurrentActivation.apply(e.add(h,m)),O=e.add(e.mul(R,o),e.mul(_,r.activation.apply(e.add(p,y)))),M=e.mul(r.recurrentActivation.apply(e.add(d,v)),r.activation.apply(O));return[M,M,O]}))},n.prototype.getConfig=function(){var e=t.prototype.getConfig.call(this),n=(e.units,function(t,e){var n={};for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&e.indexOf(r)<0&&(n[r]=t[r]);if(null!=t&&"function"==typeof Object.getOwnPropertySymbols){var i=0;for(r=Object.getOwnPropertySymbols(t);i<r.length;i++)e.indexOf(r[i])<0&&Object.prototype.propertyIsEnumerable.call(t,r[i])&&(n[r[i]]=t[r[i]])}return n}(e,["units"])),r={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return mi({},n,r)},n.prototype.inputConv=function(t,n,r,i){var a=e.conv2d(t,n,this.strides,i||"valid","channelsFirst"===this.dataFormat?"NCHW":"NHWC",this.dilationRate);return r?La(a,r,this.dataFormat):a},n.prototype.recurrentConv=function(t,n){return e.conv2d(t,n,1,"same","channelsFirst"===this.dataFormat?"NCHW":"NHWC")},n.className="ConvLSTM2DCell",n}(Qu);e.serialization.registerClass(il);var al=function(t){function e(e){var n=new il(e);return t.call(this,mi({},e,{cell:n}))||this}return fi(e,t),e.fromConfig=function(t,e){return new t(e)},e.className="ConvLSTM2D",e}(rl);e.serialization.registerClass(al);var sl=function(t){function n(e){var n=t.call(this,e)||this;return n.rate=Math.max(Math.min(e.rate,1),0),n.noiseShape=e.noiseShape,n.seed=e.seed,n.supportsMasking=!0,n}return fi(n,t),n.prototype.getNoiseShape=function(t){if(null==this.noiseShape)return this.noiseShape;for(var e=t.shape,n=[],r=0;r<this.noiseShape.length;++r)n.push(null==this.noiseShape[r]?e[r]:this.noiseShape[r]);return n},n.prototype.call=function(t,n){var r=this;return e.tidy((function(){r.invokeCallHook(t,n);var e=hs(t);if(0<r.rate&&r.rate<1){var i=null!=n.training&&n.training,a=r.getNoiseShape(e);return Ra((function(){return _a(e,r.rate,a,r.seed)}),(function(){return e}),i)}return t}))},n.prototype.getConfig=function(){var e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},n=t.prototype.getConfig.call(this);return Object.assign(e,n),e},n.prototype.dispose=function(){return t.prototype.dispose.call(this)},n.className="Dropout",n}(Ns);e.serialization.registerClass(sl);var ol=function(t){function e(e){var n=t.call(this,e)||this;return n.inputSpec=[{ndim:3}],n}return fi(e,t),e.prototype.getNoiseShape=function(t){var e=t.shape;return[e[0],1,e[2]]},e.className="SpatialDropout1D",e}(sl);e.serialization.registerClass(ol);var ul=function(t){function n(e){var n=t.call(this,e)||this;if(n.activation=null,n.useBias=!0,n.kernel=null,n.bias=null,n.DEFAULT_KERNEL_INITIALIZER="glorotNormal",n.DEFAULT_BIAS_INITIALIZER="zeros",null==e.batchInputShape&&null==e.inputShape&&null!=e.inputDim){var r=null;null!=e.batchSize&&(r=e.batchSize),n.batchInputShape=[r,e.inputDim]}return n.units=e.units,Wi(n.units,"units"),n.activation=fu(e.activation),null!=e.useBias&&(n.useBias=e.useBias),n.kernelInitializer=rs(e.kernelInitializer||n.DEFAULT_KERNEL_INITIALIZER),n.biasInitializer=rs(e.biasInitializer||n.DEFAULT_BIAS_INITIALIZER),n.kernelConstraint=Qi(e.kernelConstraint),n.biasConstraint=Qi(e.biasConstraint),n.kernelRegularizer=ku(e.kernelRegularizer),n.biasRegularizer=ku(e.biasRegularizer),n.activityRegularizer=ku(e.activityRegularizer),n.supportsMasking=!0,n.inputSpec=[{minNDim:2}],n}return fi(n,t),n.prototype.build=function(t){var e,n=(t=ps(t))[t.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[n,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:(e={},e[-1]=n,e)}],this.built=!0},n.prototype.computeOutputShape=function(t){var e=(t=ps(t)).slice();return e[e.length-1]=this.units,e},n.prototype.call=function(t,n){var r=this;return e.tidy((function(){r.invokeCallHook(t,n);var e,i=hs(t),a=ji(r.activation.getClassName());return null!=a?e=Ta(i,r.kernel.read(),a,r.bias?r.bias.read():null):(e=Ta(i,r.kernel.read()),null!=r.bias&&(e=La(e,r.bias.read())),null!=r.activation&&(e=r.activation.apply(e))),e}))},n.prototype.getConfig=function(){var e={units:this.units,activation:pu(this.activation),useBias:this.useBias,kernelInitializer:ns(this.kernelInitializer),biasInitializer:ns(this.biasInitializer),kernelRegularizer:bu(this.kernelRegularizer),biasRegularizer:bu(this.biasRegularizer),activityRegularizer:bu(this.activityRegularizer),kernelConstraint:Yi(this.kernelConstraint),biasConstraint:Yi(this.biasConstraint)},n=t.prototype.getConfig.call(this);return Object.assign(e,n),e},n.className="Dense",n}(Ns);e.serialization.registerClass(ul);var ll=function(t){function n(e){var n=this;return e=e||{},(n=t.call(this,e)||this).inputSpec=[{minNDim:3}],n.dataFormat=e.dataFormat,n}return fi(n,t),n.prototype.computeOutputShape=function(t){for(var e=0,n=(t=ps(t)).slice(1);e<n.length;e++){if(null==n[e])throw new Si('The shape of the input to "Flatten" is not fully defined (got '+t.slice(1)+'). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.')}return[t[0],ma(t,1)]},n.prototype.call=function(t,n){var r=this;return e.tidy((function(){r.invokeCallHook(t,n);var i=hs(t);if("channelsFirst"===r.dataFormat&&i.rank>1){for(var a=[0],s=2;s<i.rank;++s)a.push(s);a.push(1),i=e.transpose(i,a)}return function(t){if(t.rank<=1)throw new Si("batchFlatten requires a minimum rank of 2. Got rank: "+t.rank+".");var n=[t.shape[0],ma(t.shape,1)];return e.reshape(t,n)}(i)}))},n.prototype.getConfig=function(){var e={};null!=this.dataFormat&&(e.dataFormat=this.dataFormat);var n=t.prototype.getConfig.call(this);return Object.assign(e,n),e},n.className="Flatten",n}(Ns);e.serialization.registerClass(ll);var cl=function(t){function n(e){var n=t.call(this,e)||this;return n.supportsMasking=!0,n.activation=fu(e.activation),n}return fi(n,t),n.prototype.call=function(t,n){var r=this;return e.tidy((function(){r.invokeCallHook(t,n);var e=hs(t);return r.activation.apply(e)}))},n.prototype.getConfig=function(){var e={activation:pu(this.activation)},n=t.prototype.getConfig.call(this);return Object.assign(e,n),e},n.className="Activation",n}(Ns);e.serialization.registerClass(cl);var hl=function(t){function n(e){var n=t.call(this,e)||this;return n.n=e.n,n.inputSpec=[{ndim:2}],n}return fi(n,t),n.prototype.computeOutputShape=function(t){return[t[0],this.n,t[1]]},n.prototype.call=function(t,n){var r=this;return e.tidy((function(){return t=hs(t),n=t,i=r.n,e.tidy((function(){if(2!==n.shape.length)throw new Si("repeat() expects a rank-2 tensor, but received a rank-"+n.shape.length+" tensor.");return Aa(ka(n,1),[1,i,1])}));var n,i}))},n.prototype.getConfig=function(){var e={n:this.n},n=t.prototype.getConfig.call(this);return Object.assign(e,n),e},n.className="RepeatVector",n}(Ns);e.serialization.registerClass(hl);var pl=function(t){function n(e){var n=t.call(this,e)||this;n.targetShape=e.targetShape;for(var r=0;r<n.targetShape.length;++r)n.isUnknown(n.targetShape[r])&&(n.targetShape[r]=null);return n}return fi(n,t),n.prototype.isUnknown=function(t){return t<0||null==t},n.prototype.fixUnknownDimension=function(t,e){for(var n="Total size of new array must be unchanged.",r=e.slice(),i=1,a=null,s=0;s<r.length;++s){var o=r[s];if(this.isUnknown(o)){if(null!==a)throw new Si("Can only specifiy one unknown dimension.");a=s}else i*=o}var u=ma(t);if(null!==a){if(0===i||u%i!=0)throw new Si(n);r[a]=u/i}else if(u!==i)throw new Si(n);return r},n.prototype.computeOutputShape=function(t){for(var e=!1,n=0;n<t.length;++n)if(this.isUnknown(t[n])){e=!0;break}return e?t.slice(0,1).concat(this.targetShape):t.slice(0,1).concat(this.fixUnknownDimension(t.slice(1),this.targetShape))},n.prototype.call=function(t,n){var r=this;return e.tidy((function(){r.invokeCallHook(t,n);var i=hs(t),a=i.shape,s=a.slice(0,1).concat(r.fixUnknownDimension(a.slice(1),r.targetShape));return e.reshape(i,s)}))},n.prototype.getConfig=function(){var e={targetShape:this.targetShape},n=t.prototype.getConfig.call(this);return Object.assign(e,n),e},n.className="Reshape",n}(Ns);e.serialization.registerClass(pl);var dl=function(t){function n(n){var r=t.call(this,n)||this;if(null==n.dims)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(n.dims))throw new Error("Permute constructor requires `dims` to be an Array, but received "+n.dims+" instead.");var i=ba(1,n.dims.length+1);if(!e.util.arraysEqual(n.dims.slice().sort(),i))throw new Error("Invalid permutation `dims`: "+JSON.stringify(n.dims)+" `dims` must contain consecutive integers starting from 1.");return r.dims=n.dims,r.dimsIncludingBatch=[0].concat(r.dims),r.inputSpec=[new vs({ndim:r.dims.length+1})],r}return fi(n,t),n.prototype.computeOutputShape=function(t){var e=(t=ps(t)).slice();return this.dims.forEach((function(n,r){e[r+1]=t[n]})),e},n.prototype.call=function(t,n){return e.transpose(hs(t),this.dimsIncludingBatch)},n.prototype.getConfig=function(){var e={dims:this.dims},n=t.prototype.getConfig.call(this);return Object.assign(e,n),e},n.className="Permute",n}(Ns);e.serialization.registerClass(dl);var fl=function(t){function n(e){var n=t.call(this,null==e?{}:e)||this;return n.supportsMasking=!0,n.maskValue=null!=e?null==e.maskValue?0:e.maskValue:0,n}return fi(n,t),n.prototype.computeOutputShape=function(t){return t},n.prototype.getConfig=function(){var e=t.prototype.getConfig.call(this),n={maskValue:this.maskValue};return Object.assign(n,e),n},n.prototype.computeMask=function(t,n){var r=hs(t);return e.any(e.notEqual(r,this.maskValue),-1)},n.prototype.call=function(t,n){var r=this;return e.tidy((function(){r.invokeCallHook(t,n);var i=hs(t),a=e.any(e.notEqual(i,r.maskValue),-1,!0);return e.mul(i,e.cast(a,i.dtype))}))},n.className="Masking",n}(Ns);e.serialization.registerClass(fl);var gl=function(t){function n(e){var n=t.call(this,e)||this;if(n.embeddings=null,n.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==e.batchInputShape&&null==e.inputShape){var r=null;null!=e.batchSize&&(r=e.batchSize),null==e.inputLength?n.batchInputShape=[r,null]:n.batchInputShape=[r].concat(Ti(e.inputLength))}return n.inputDim=e.inputDim,Wi(n.inputDim,"inputDim"),n.outputDim=e.outputDim,Wi(n.outputDim,"outputDim"),n.embeddingsInitializer=rs(e.embeddingsInitializer||n.DEFAULT_EMBEDDINGS_INITIALIZER),n.embeddingsRegularizer=ku(e.embeddingsRegularizer),n.activityRegularizer=ku(e.activityRegularizer),n.embeddingsConstraint=Qi(e.embeddingsConstraint),n.maskZero=e.maskZero,n.supportsMasking=e.maskZero,n.inputLength=e.inputLength,n}return fi(n,t),n.prototype.build=function(t){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0},n.prototype.warnOnIncompatibleInputShape=function(t){},n.prototype.computeMask=function(t,n){var r=this;return e.tidy((function(){return r.maskZero?(t=hs(t),e.notEqual(t,e.zerosLike(t))):null}))},n.prototype.computeOutputShape=function(t){if(t=ps(t),null==this.inputLength)return t.concat([this.outputDim]);var e=Ti(this.inputLength);if(e.length!==t.length-1)throw new Si('"inputLength" is '+this.inputLength+", but received input shape has shape "+t);for(var n=0,r=0;r<e.length;++r){var i=e[r],a=t[r+1];if(null!=i&&null!=a&&i!==a)throw new Si('"inputLength" is '+this.inputLength+", but received input shape has shape "+t);null==i&&(e[n]=a),n++}return[t[0]].concat(e,[this.outputDim])},n.prototype.call=function(t,n){var r=this;return e.tidy((function(){r.invokeCallHook(t,n);var i=hs(t);"int32"!==i.dtype&&(i=wa(i,"int32"));var a=Ea(r.embeddings.read(),e.reshape(i,[i.size]));return e.reshape(a,ps(r.computeOutputShape(i.shape)))}))},n.prototype.getConfig=function(){var e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:ns(this.embeddingsInitializer),embeddingsRegularizer:bu(this.embeddingsRegularizer),activityRegularizer:bu(this.activityRegularizer),embeddingsConstraint:Yi(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},n=t.prototype.getConfig.call(this);return Object.assign(e,n),e},n.className="Embedding",n}(Ns);e.serialization.registerClass(gl);var ml=function(t){function n(e){var n=t.call(this,e||{})||this;return n.supportsMasking=!0,n}return fi(n,t),n.prototype.mergeFunction=function(t){throw new Ni},n.prototype.computeElementwiseOpOutputShape=function(t,e){if(null==t||null==e)return null;if(t.length<e.length)return this.computeElementwiseOpOutputShape(e,t);if(0===e.length)return t;for(var n=t.slice(0,t.length-e.length),r=0;r<e.length;++r){var i=t[t.length-e.length+r],a=e[r];if(null==i||null==a||i<0||a<0)n.push(null);else if(1===i)n.push(a);else if(1===a)n.push(i);else{if(i!==a)throw new Si("Operands could not be broadcast together with shapes "+JSON.stringify(t)+" "+JSON.stringify(e));n.push(i)}}return n},n.prototype.build=function(t){if(Array.isArray(t)&&!Array.isArray(t[0])&&(t=[ps(t)]),(t=t).length<2)throw new Si("A merge layer should be called on an Array of at least 2 inputs. Got "+t.length+" input(s).");for(var e=[],n=0,r=t;n<r.length;n++){null!=(s=r[n])&&null!==s[0]&&e.push(s[0])}if((e=Mi(e)).length>1)throw new Si("Can not merge tensors with different batch sizes. Got tensors with shapes: "+JSON.stringify(t)+".");for(var i=null==t[0]?null:t[0].slice(1),a=1;a<t.length;++a){var s=null==t[a]?null:t[a].slice(1);i=this.computeElementwiseOpOutputShape(i,s)}var o=t.map((function(t){return t.length}));-1===t.indexOf(null)&&1===Mi(o).length?this.reshapeRequired=!1:this.reshapeRequired=!0},n.prototype.call=function(t,n){var r=this;return e.tidy((function(){if(t=t,r.reshapeRequired){var n=[],i=t.map((function(t){return t.rank}));if(-1===i.indexOf(null)){for(var a=va(i),s=0,o=t;s<o.length;s++){for(var u=(d=o[s]).rank,l=0;l<a-u;++l)d=ka(d,1);n.push(d)}return r.mergeFunction(n)}for(var c=!1,h=0,p=t;h<p.length;h++){var d;if(null==(u=(d=p[h]).rank)){var f=d.shape,g=f[0],m=f.slice(1).concat([g]),y=e.reshape(d,[g].concat(ma(f.slice(1))));y=e.transpose(y,[1,0]),y=e.reshape(y,m),n.push(y),c=!0}else if(u>1){var v=ba(1,u).concat([0]);n.push(e.transpose(d,v)),c=!0}else n.push(d)}var b=r.mergeFunction(n),w=b.rank;if(c)if(null==w){var k=b.shape;m=[g=k[k.length-1]].concat(k.slice(0,k.length-1));b=e.reshape(e.transpose(e.reshape(b,[-1,g]),[1,0]),m)}else if(w>1){v=[w-1].concat(ba(0,w-1));b=e.transpose(b,v)}return b}return r.mergeFunction(t)}))},n.prototype.computeOutputShape=function(t){var e;e=null==(t=t)[0]?null:t[0].slice(1);for(var n=1;n<t.length;++n){var r=null==t[n]?null:t[n].slice(1);e=this.computeElementwiseOpOutputShape(e,r)}for(var i=[],a=0,s=t;a<s.length;a++){null!=(r=s[a])&&null!==r[0]&&i.push(r[0])}return e=1===(i=Mi(i)).length?i.concat(e):[null].concat(e)},n.prototype.computeMask=function(t,n){return e.tidy((function(){if(null==n)return null;if(!Array.isArray(n))throw new Si("`mask` should be an Array");if(!Array.isArray(t))throw new Si("`inputs` should be an Array");if(n.length!==t.length)throw new Si("The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths ("+t.length+" vs "+n.length+")");if(n.every((function(t){return null==t})))return null;for(var r=(n=n.map((function(t){return null==t?t:e.expandDims(t,0)})))[0],i=1;i<n.length-1;++i)r=e.logicalAnd(r,n[i]);return r}))},n}(Ns),yl=function(t){function n(e){return t.call(this,e)||this}return fi(n,t),n.prototype.mergeFunction=function(t){return e.tidy((function(){for(var n=t[0].clone(),r=1;r<t.length;++r)n=e.add(n,t[r]);return n}))},n.className="Add",n}(ml);e.serialization.registerClass(yl);var vl=function(t){function n(e){return t.call(this,e)||this}return fi(n,t),n.prototype.mergeFunction=function(t){return e.tidy((function(){for(var n=t[0].clone(),r=1;r<t.length;++r)n=e.mul(n,t[r]);return n}))},n.className="Multiply",n}(ml);e.serialization.registerClass(vl);var bl=function(t){function n(e){return t.call(this,e)||this}return fi(n,t),n.prototype.mergeFunction=function(t){return e.tidy((function(){for(var n=t[0].clone(),r=1;r<t.length;++r)n=e.add(n,t[r]);return e.mul(1/t.length,n)}))},n.className="Average",n}(ml);e.serialization.registerClass(bl);var wl=function(t){function n(e){return t.call(this,e)||this}return fi(n,t),n.prototype.mergeFunction=function(t){return e.tidy((function(){for(var n=t[0],r=1;r<t.length;++r)n=e.maximum(n,t[r]);return n}))},n.className="Maximum",n}(ml);e.serialization.registerClass(wl);var kl=function(t){function n(e){return t.call(this,e)||this}return fi(n,t),n.prototype.mergeFunction=function(t){return e.tidy((function(){for(var n=t[0],r=1;r<t.length;++r)n=e.minimum(n,t[r]);return n}))},n.className="Minimum",n}(ml);e.serialization.registerClass(kl);var Sl=function(t){function n(e){var n=t.call(this,e)||this;return n.DEFAULT_AXIS=-1,null==e&&(e={}),n.axis=null==e.axis?n.DEFAULT_AXIS:e.axis,n.supportsMasking=!0,n.reshapeRequired=!1,n}return fi(n,t),n.prototype.build=function(t){if(!Array.isArray(t)||!Array.isArray(t[0])||1===t.length)throw new Si("A `Concatenate` layer should be called on a list of at least 2 inputs");for(var n=!0,r=0,i=t=t;r<i.length;r++){if(null!=(h=i[r])){n=!1;break}}if(!n){for(var a=[],s=0;s<t.length;++s){var o=t[s].slice();o.splice(this.axis,1);for(var u=!1,l=0,c=a;l<c.length;l++){var h=c[l];if(e.util.arraysEqual(h,o)){u=!0;break}}u||a.push(o)}if(a.length>1)throw new Si("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(t))}},n.prototype.mergeFunction=function(t){var n=this;return e.tidy((function(){return za(t,n.axis)}))},n.prototype.computeOutputShape=function(t){if(!Array.isArray(t)||!Array.isArray(t[0]))throw new Si("A `Concatenate` layer should be called on a list of inputs.");for(var e=t,n=e[0].slice(),r=this.axis<0?n.length+this.axis:this.axis,i=0,a=e.slice(1);i<a.length;i++){var s=a[i];if(null==n[r]||null==s[r]){n[r]=null;break}n[r]+=s[r]}return n},n.prototype.computeMask=function(t,n){var r=this;if(null==n)return null;if(!Array.isArray(n))throw new Si("`mask` should be an array for Concatenate");if(!Array.isArray(t))throw new Si("`inputs` should be an array for Concatenate");if(n.length!==t.length)throw new Si("Mismatch in the length of mask ("+n.length+") and the legnth of inputs ("+t.length+")");return e.tidy((function(){var i=!0;if(n.forEach((function(t){null==t||(i=!1)})),i)return null;for(var a=[],s=0;s<t.length;++s)null==n[s]?a.push(e.cast(e.onesLike(t[s]),"bool")):n[s].rank<t[s].rank?a.push(e.expandDims(n[s],-1)):a.push(n[s]);var o=e.concat(a,r.axis);return e.all(o,-1,!1)}))},n.prototype.getConfig=function(){var e={axis:this.axis},n=t.prototype.getConfig.call(this);return Object.assign(e,n),e},n.className="Concatenate",n}(ml);function Nl(t,e){for(;t<0;)t+=e;return t}e.serialization.registerClass(Sl);var xl=function(t){function n(e){var n=t.call(this,e)||this;return n.axes=e.axes,n.normalize=null!=e.normalize&&e.normalize,n.supportsMasking=!0,n.reshapeRequired=!1,n}return fi(n,t),n.prototype.build=function(t){e.util.assert(Array.isArray(t)&&2===t.length&&Array.isArray(t[0])&&Array.isArray(t[1]),(function(){return"A `Dot` layer should be called on a list of exactly 2 inputs."}));var n=t[0],r=t[1];if(n.length>3||r.length>3)throw new Ni("Dot layer does not support tensors of 4D or higher rank yet.");var i=this.interpretAxes(n,r);if(n[i[0]]!==r[i[1]])throw new Si("Dimension incompatibility: "+n[i[0]]+" !== "+r[i[1]])},n.prototype.mergeFunction=function(t){if(2!==t.length)throw new Si("A `Dot` layer must be called on exactly 2 inputs, but received "+t.length+" input(s).");var n,r=t[0],i=t[1];return n=Array.isArray(this.axes)?this.axes.map((function(e,n){return Nl(e,t[n].shape.length)})):[Nl(this.axes,r.shape.length),Nl(this.axes,i.shape.length)],this.normalize&&(r=Ps(r,n[0]),i=Ps(i,n[1])),function(t,n,r){if(t.shape.length>3||n.shape.length>3)throw new Ni("batchDot is not implemented for tensors of 4D or higher rank yet");if(e.util.assert(t.shape.length>=2,(function(){return"batchDot requires the rank of x to be >= 2, but got "+t.shape.length})),e.util.assert(t.shape.length>=2,(function(){return"batchDot requires the rank of y to be >= 2, but got "+n.shape.length})),"number"==typeof r&&(r=[r,r]),"complex64"===t.dtype||"complex64"===n.dtype)throw new Ni("batchDot is not implemented for complex64-type Tensors yet.");var i=t.shape.length,a=n.shape.length;null==r&&(r=[i-1,a-2]);var s=r;return e.tidy((function(){var r,o;if(i>a){r=i-a;for(var u=[],l=0;l<r;++l)u.push(1);n=e.reshape(n,n.shape.concat(u))}else if(a>i){for(r=a-i,u=[],l=0;l<r;++l)u.push(1);t=e.reshape(t,t.shape.concat(u))}else r=0;if(2===t.shape.length&&2===n.shape.length)o=s[0]===s[1]?e.sum(e.mul(t,n),s[0]):e.sum(e.mul(e.transpose(t,[1,0]),n),s[1]);else{var c=s[0]!==t.shape.length-1,h=s[1]===n.shape.length-1;o=e.matMul(t,n,c,h)}if(r>0){var p=void 0,d=[];for(l=p=i>a?i+a-3:i-1;l<p+r;++l)d.push(l);o=e.squeeze(o,d)}return 1===o.shape.length&&(o=e.expandDims(o,1)),o}))}(r,i,n)},n.prototype.interpretAxes=function(t,e){return Array.isArray(this.axes)?this.axes:[Nl(this.axes,t.length),Nl(this.axes,e.length)]},n.prototype.computeOutputShape=function(t){e.util.assert(Array.isArray(t)&&2===t.length&&Array.isArray(t[0])&&Array.isArray(t[1]),(function(){return"A `Dot` layer should be called on a list of exactly 2 inputs."}));var n=t[0].slice(),r=t[1].slice();if(n.length>3||r.length>3)throw new Ni("Dot layer does not support tensors of 4D or higher rank yet.");var i=this.interpretAxes(n,r);n.splice(i[0],1),r.splice(i[1],1),r.splice(0,1);var a=n.concat(r);return 1===a.length&&a.push(1),a},n.prototype.computeMask=function(t,e){return null},n.prototype.getConfig=function(){var e={axes:this.axes,normalize:this.normalize},n=t.prototype.getConfig.call(this);return Object.assign(e,n),e},n.className="Dot",n}(ml);e.serialization.registerClass(xl);var zl=function(t){function n(e){var n=t.call(this,e)||this;return n.supportsMasking=!0,n.stddev=e.stddev,n}return fi(n,t),n.prototype.computeOutputShape=function(t){return t},n.prototype.getConfig=function(){var e=t.prototype.getConfig.call(this),n={stddev:this.stddev};return Object.assign(n,e),n},n.prototype.call=function(t,n){var r=this;return e.tidy((function(){r.invokeCallHook(t,n);var i=hs(t);return Ra((function(){return e.add(Ca(i.shape,0,r.stddev),i)}),(function(){return i}),n.training||!1)}))},n.className="GaussianNoise",n}(Ns);e.serialization.registerClass(zl);var Il=function(t){function n(e){var n=t.call(this,e)||this;return n.supportsMasking=!0,n.rate=e.rate,n}return fi(n,t),n.prototype.computeOutputShape=function(t){return t},n.prototype.getConfig=function(){var e=t.prototype.getConfig.call(this),n={rate:this.rate};return Object.assign(n,e),n},n.prototype.call=function(t,n){var r=this;return e.tidy((function(){r.invokeCallHook(t,n);var i=hs(t);if(r.rate>0&&r.rate<1){return Ra((function(){var t=Math.sqrt(r.rate/(1-r.rate));return e.mul(i,Ca(i.shape,1,t))}),(function(){return i}),n.training||!1)}return i}))},n.className="GaussianDropout",n}(Ns);e.serialization.registerClass(Il);var Al=function(t){function n(e){var n=t.call(this,e)||this;return n.supportsMasking=!0,n.rate=e.rate,n.noiseShape=e.noiseShape,n}return fi(n,t),n.prototype._getNoiseShape=function(t){return this.noiseShape||hs(t).shape},n.prototype.computeOutputShape=function(t){return t},n.prototype.getConfig=function(){var e=t.prototype.getConfig.call(this),n={rate:this.rate};return Object.assign(n,e),n},n.prototype.call=function(t,n){var r=this;return e.tidy((function(){if(r.rate<1&&r.rate>0){var i=r._getNoiseShape(t);return Ra((function(){var n=hs(t),a=-1.7580993408473766,s=e.greaterEqual(e.randomUniform(i),r.rate);s=wa(s,"float32");var o=Math.pow((1-r.rate)*(1+r.rate*Math.pow(a,2)),-.5),u=-o*a*r.rate,l=e.add(e.mul(n,s),e.mul(e.add(s,-1),a));return e.add(e.mul(l,o),u)}),(function(){return hs(t)}),n.training||!1)}return t}))},n.className="AlphaDropout",n}(Ns);function Cl(t,n,r,i,a,s){var o;if(void 0===s&&(s=.001),2===t.rank)o=e.batchNorm2d(t,n,r,i,a,s);else if(3===t.rank)o=e.batchNorm3d(t,n,r,i,a,s);else{if(4!==t.rank)throw new Ni("batchNormalization is not implemented for array of rank "+t.rank+" yet");o=e.batchNorm4d(t,n,r,i,a,s)}return o}function Tl(t,n,r,i,a){return void 0===a&&(a=.001),e.util.arraysEqual(i.slice().sort(),ba(0,t.rank-1))?function(t,n,r,i,a){return void 0===a&&(a=.001),e.tidy((function(){var s=e.moments(t,i),o=s.mean,u=s.variance;return[Cl(t,o,u,r,n,a),o,u]}))}(t,n,r,i,a):function(t,n,r,i,a){return void 0===a&&(a=.001),e.tidy((function(){for(var s=e.moments(t,i),o=s.mean,u=s.variance,l=[],c=0,h=ba(0,t.rank);c<h.length;c++){var p=h[c];-1!==i.indexOf(p)?l.push(1):l.push(t.shape[p])}var d=e.reshape(o,l),f=e.reshape(u,l),g=null==n?null:e.reshape(n,l),m=null==r?null:e.reshape(r,l);return[Cl(t,d,f,m,g,a),o,u]}))}(t,n,r,i,a)}e.serialization.registerClass(Al);var El=function(t){function n(e){var n=this;return null==e&&(e={}),(n=t.call(this,e)||this).supportsMasking=!0,n.axis=null==e.axis?-1:e.axis,n.momentum=null==e.momentum?.99:e.momentum,n.epsilon=null==e.epsilon?.001:e.epsilon,n.center=null==e.center||e.center,n.scale=null==e.scale||e.scale,n.betaInitializer=rs(e.betaInitializer||"zeros"),n.gammaInitializer=rs(e.gammaInitializer||"ones"),n.movingMeanInitializer=rs(e.movingMeanInitializer||"zeros"),n.movingVarianceInitializer=rs(e.movingVarianceInitializer||"ones"),n.betaConstraint=Qi(e.betaConstraint),n.gammaConstraint=Qi(e.gammaConstraint),n.betaRegularizer=ku(e.betaRegularizer),n.gammaRegularizer=ku(e.gammaRegularizer),n}return fi(n,t),n.prototype.build=function(t){var e;t=ps(t);var n=this.axis>=0?this.axis:this.axis+t.length,r=t[n];if(null==r)throw new Si("Axis "+n+" of input tensor should have a defined dimension but the layer received an input with shape "+JSON.stringify(t)+".");this.inputSpec=[new vs({ndim:t.length,axes:(e={},e[n]=r,e)})];var i=[r];this.scale&&(this.gamma=this.addWeight("gamma",i,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",i,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",i,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",i,null,this.movingVarianceInitializer,null,!1),this.built=!0},n.prototype.call=function(t,n){var r=this;return e.tidy((function(){var i=null!=n.training&&n.training,a=hs(t),s=a.shape,o=s.length,u=ba(0,o),l=r.axis>=0?r.axis:r.axis+o;u.splice(l,1);var c=zi(1,o);c[l]=s[l];var h=u.slice();h.sort();var p=!e.util.arraysEqual(h,ba(0,o).slice(0,o-1));if(!i)return function(){if(p){var t=e.reshape(r.movingMean.read(),c),n=e.reshape(r.movingVariance.read(),c),i=r.center?e.reshape(r.beta.read(),c):null,s=r.scale?e.reshape(r.gamma.read(),c):null;return Cl(a,t,n,i,s,r.epsilon)}return Cl(a,r.movingMean.read(),r.movingVariance.read(),null==r.beta?null:r.beta.read(),null==r.gamma?null:r.gamma.read(),r.epsilon)}();var d=Tl(a,r.gamma.read(),r.beta.read(),u,r.epsilon),f=d[0],g=d[1],m=d[2],y=function(t,n,r){e.tidy((function(){var i=1-r,a=t.read(),s=e.mul(e.sub(a,n),i);t.write(e.sub(a,s))}))};return y(r.movingMean,g,r.momentum),y(r.movingVariance,m,r.momentum),f}))},n.prototype.getConfig=function(){var e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:ns(this.betaInitializer),gammaInitializer:ns(this.gammaInitializer),movingMeanInitializer:ns(this.movingMeanInitializer),movingVarianceInitializer:ns(this.movingVarianceInitializer),betaRegularizer:bu(this.betaRegularizer),gammaRegularizer:bu(this.gammaRegularizer),betaConstraint:Yi(this.betaConstraint),gammaConstraint:Yi(this.gammaConstraint)},n=t.prototype.getConfig.call(this);return Object.assign(e,n),e},n.className="BatchNormalization",n}(Ns);e.serialization.registerClass(El);var Fl=function(t){function n(e){var n=this;if(null==e&&(e={}),(n=t.call(this,e)||this).axis=null==e.axis?-1:e.axis,"number"==typeof n.axis){if(!Number.isInteger(n.axis))throw new Error("Expected axis to be an integer, but received "+n.axis)}else{if(!Array.isArray(n.axis))throw new Error("Expected axis to be an integer or an array of integers, but received "+JSON.stringify(n.axis));for(var r=0,i=n.axis;r<i.length;r++){var a=i[r];if(!Number.isInteger(a))throw new Error("Expected axis to be an array of integers, but received "+JSON.stringify(n.axis))}}return n.epsilon=null==e.epsilon?.001:e.epsilon,n.center=null==e.center||e.center,n.scale=null==e.scale||e.scale,n.betaInitializer=rs(e.betaInitializer||"zeros"),n.gammaInitializer=rs(e.gammaInitializer||"ones"),n.betaRegularizer=ku(e.betaRegularizer),n.gammaRegularizer=ku(e.gammaRegularizer),n.supportsMasking=!0,n}return fi(n,t),n.prototype.build=function(t){var e=(t=ps(t)).length;"number"==typeof this.axis&&(this.axis=[this.axis]);for(var n=0;n<this.axis.length;++n)this.axis[n]<0&&(this.axis[n]+=e);for(var r=0,i=this.axis;r<i.length;r++){var a=i[r];if(a<0||a>=e)throw new Error("Invalid axis: "+a)}if(this.axis.length!==Mi(this.axis).length)throw new Error("Found duplicate axes in: "+this.axis);var s=this.axis.map((function(e){return t[e]}));this.scale?this.gamma=this.addWeight("gamma",s,"float32",this.gammaInitializer,this.gammaRegularizer,true):this.gamma=null,this.center?this.beta=this.addWeight("beta",s,"float32",this.betaInitializer,this.betaRegularizer,true):this.beta=null,this.built=!0},n.prototype.call=function(t,n){var r=this,i=hs(t),a=i.shape,s=a.length;return e.tidy((function(){for(var t=e.moments(i,r.axis,!0),n=t.mean,o=t.variance,u=zi(1,s),l=0,c=r.axis;l<c.length;l++){var h=c[l];u[h]=a[h]}for(var p=function(t){return null!=t&&t.shape.length!==s&&r.axis!==[s-1]?e.reshape(t,u):t},d=p(r.gamma.read()),f=p(r.beta.read()),g=[],m=[],y=0;y<s;++y)-1!==r.axis.indexOf(y)?(g.push(a[y]),m.push(1)):(g.push(1),m.push(a[y]));return n=e.tile(n,g),o=e.tile(o,g),d=e.tile(d,m),f=e.tile(f,m),Cl(i,n,o,f,d,r.epsilon)}))},n.prototype.getConfig=function(){var e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:ns(this.betaInitializer),gammaInitializer:ns(this.gammaInitializer),betaRegularizer:bu(this.betaRegularizer),gammaRegularizer:bu(this.gammaRegularizer)},n=t.prototype.getConfig.call(this);return Object.assign(e,n),e},n.className="LayerNormalization",n}(Ns);e.serialization.registerClass(Fl);var Dl=function(t){function n(e){var n=this;if(null==e&&(e={}),(n=t.call(this,e)||this).dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,null==e.padding)n.padding=[[1,1],[1,1]];else if("number"==typeof e.padding)n.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,2!==e.padding.length)throw new Si("ZeroPadding2D expects padding to be a length-2 array, but received a length-"+e.padding.length+" array.");var r=void 0,i=void 0;if("number"==typeof e.padding[0])r=[e.padding[0],e.padding[0]],i=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,2!==e.padding[0].length)throw new Si("ZeroPadding2D expects height padding to be a length-2 array, but received a length-"+e.padding[0].length+" array.");if(r=e.padding[0],2!==e.padding[1].length)throw new Si("ZeroPadding2D expects width padding to be a length-2 array, but received a length-"+e.padding[1].length+" array.");i=e.padding[1]}n.padding=[r,i]}return n.inputSpec=[new vs({ndim:4})],n}return fi(n,t),n.prototype.computeOutputShape=function(t){var e,n;return t=ps(t),"channelsFirst"===this.dataFormat?(e=null!=t[2]&&t[2]>=0?t[2]+this.padding[0][0]+this.padding[0][1]:null,n=null!=t[3]&&t[3]>=0?t[3]+this.padding[1][0]+this.padding[1][1]:null,[t[0],t[1],e,n]):(e=null!=t[1]&&t[1]>=0?t[1]+this.padding[0][0]+this.padding[0][1]:null,n=null!=t[2]&&t[2]>=0?t[2]+this.padding[1][0]+this.padding[1][1]:null,[t[0],e,n,t[3]])},n.prototype.call=function(t,n){var r=this;return e.tidy((function(){return n=hs(t),i=r.padding,a=r.dataFormat,e.tidy((function(){if(4!==n.rank)throw new Si("temporalPadding expects input tensor to be 4-D, but received a "+n.rank+"-D tensor.");if(null==i&&(i=[[1,1],[1,1]]),2!==i.length||2!==i[0].length||2!==i[1].length)throw new Si("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==a&&(a="channelsLast"),"channelsLast"!==a&&"channelsFirst"!==a)throw new Si("Unknown data format: "+a+". Supported data formats are 'channelsLast' and 'channelsFirst.");var t;return t="channelsFirst"===a?[[0,0],[0,0],i[0],i[1]]:[[0,0],i[0],i[1],[0,0]],e.pad(n,t)}));var n,i,a}))},n.prototype.getConfig=function(){var e={padding:this.padding,dataFormat:this.dataFormat},n=t.prototype.getConfig.call(this);return Object.assign(e,n),e},n.className="ZeroPadding2D",n}(Ns);function Ll(t,n,r,i,a,s){return e.tidy((function(){var o;oa(a),la(s),ua(i),null==r&&(r=[1,1]),null==i&&(i="valid"),null==a&&(a="channelsLast"),null==s&&(s="max"),t=Fu(t,a);var u="same"===i?"same":"valid";return o="max"===s?e.maxPool(t,n,r,u):e.avgPool(t,n,r,u),"channelsFirst"===a&&(o=e.transpose(o,[0,3,1,2])),o}))}function _l(t,n,r,i,a,s){return e.tidy((function(){var o;oa(a),la(s),ua(i),null==r&&(r=[1,1,1]),null==i&&(i="valid"),null==a&&(a="channelsLast"),null==s&&(s="max"),t=Du(t,a);var u="same"===i?"same":"valid";return o="max"===s?e.maxPool3d(t,n,r,u):e.avgPool3d(t,n,r,u),"channelsFirst"===a&&(o=e.transpose(o,[0,4,1,2,3])),o}))}e.serialization.registerClass(Dl);var Rl=function(t){function n(e){var n=this;if(null==e.poolSize&&(e.poolSize=2),n=t.call(this,e)||this,"number"==typeof e.poolSize)n.poolSize=[e.poolSize];else{if(!Array.isArray(e.poolSize)||1!==e.poolSize.length||"number"!=typeof e.poolSize[0])throw new Si("poolSize for 1D convolutional layer must be a number or an Array of a single number, but received "+JSON.stringify(e.poolSize));n.poolSize=e.poolSize}if(Wi(n.poolSize,"poolSize"),null==e.strides)n.strides=n.poolSize;else if("number"==typeof e.strides)n.strides=[e.strides];else{if(!Array.isArray(e.strides)||1!==e.strides.length||"number"!=typeof e.strides[0])throw new Si("strides for 1D convolutional layer must be a number or an Array of a single number, but received "+JSON.stringify(e.strides));n.strides=e.strides}return Wi(n.strides,"strides"),n.padding=null==e.padding?"valid":e.padding,ua(n.padding),n.inputSpec=[new vs({ndim:3})],n}return fi(n,t),n.prototype.computeOutputShape=function(t){var e=Tu((t=ps(t))[1],this.poolSize[0],this.padding,this.strides[0]);return[t[0],e,t[2]]},n.prototype.call=function(t,n){var r=this;return e.tidy((function(){r.invokeCallHook(t,n),t=ka(hs(t),2);var i=r.poolingFunction(hs(t),[r.poolSize[0],1],[r.strides[0],1],r.padding,"channelsLast");return e.squeeze(i,[2])}))},n.prototype.getConfig=function(){var e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},n=t.prototype.getConfig.call(this);return Object.assign(e,n),e},n}(Ns),Ol=function(t){function e(e){return t.call(this,e)||this}return fi(e,t),e.prototype.poolingFunction=function(t,e,n,r,i){return oa(i),ua(r),Ll(t,e,n,r,i,"max")},e.className="MaxPooling1D",e}(Rl);e.serialization.registerClass(Ol);var Ml=function(t){function e(e){return t.call(this,e)||this}return fi(e,t),e.prototype.poolingFunction=function(t,e,n,r,i){return oa(i),ua(r),Ll(t,e,n,r,i,"avg")},e.className="AveragePooling1D",e}(Rl);e.serialization.registerClass(Ml);var Bl=function(t){function n(e){var n=this;if(null==e.poolSize&&(e.poolSize=[2,2]),(n=t.call(this,e)||this).poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],null==e.strides)n.strides=n.poolSize;else if(Array.isArray(e.strides)){if(2!==e.strides.length)throw new Si("If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length "+e.strides.length+".");n.strides=e.strides}else n.strides=[e.strides,e.strides];return Wi(n.poolSize,"poolSize"),Wi(n.strides,"strides"),n.padding=null==e.padding?"valid":e.padding,n.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,oa(n.dataFormat),ua(n.padding),n.inputSpec=[new vs({ndim:4})],n}return fi(n,t),n.prototype.computeOutputShape=function(t){t=ps(t);var e="channelsFirst"===this.dataFormat?t[2]:t[1],n="channelsFirst"===this.dataFormat?t[3]:t[2];return e=Tu(e,this.poolSize[0],this.padding,this.strides[0]),n=Tu(n,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat?[t[0],t[1],e,n]:[t[0],e,n,t[3]]},n.prototype.call=function(t,n){var r=this;return e.tidy((function(){return r.invokeCallHook(t,n),r.poolingFunction(hs(t),r.poolSize,r.strides,r.padding,r.dataFormat)}))},n.prototype.getConfig=function(){var e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},n=t.prototype.getConfig.call(this);return Object.assign(e,n),e},n}(Ns),Pl=function(t){function e(e){return t.call(this,e)||this}return fi(e,t),e.prototype.poolingFunction=function(t,e,n,r,i){return oa(i),ua(r),Ll(t,e,n,r,i,"max")},e.className="MaxPooling2D",e}(Bl);e.serialization.registerClass(Pl);var $l=function(t){function e(e){return t.call(this,e)||this}return fi(e,t),e.prototype.poolingFunction=function(t,e,n,r,i){return oa(i),ua(r),Ll(t,e,n,r,i,"avg")},e.className="AveragePooling2D",e}(Bl);e.serialization.registerClass($l);var Wl=function(t){function n(e){var n=this;if(null==e.poolSize&&(e.poolSize=[2,2,2]),(n=t.call(this,e)||this).poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],null==e.strides)n.strides=n.poolSize;else if(Array.isArray(e.strides)){if(3!==e.strides.length)throw new Si("If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length "+e.strides.length+".");n.strides=e.strides}else n.strides=[e.strides,e.strides,e.strides];return Wi(n.poolSize,"poolSize"),Wi(n.strides,"strides"),n.padding=null==e.padding?"valid":e.padding,n.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,oa(n.dataFormat),ua(n.padding),n.inputSpec=[new vs({ndim:5})],n}return fi(n,t),n.prototype.computeOutputShape=function(t){t=ps(t);var e="channelsFirst"===this.dataFormat?t[2]:t[1],n="channelsFirst"===this.dataFormat?t[3]:t[2],r="channelsFirst"===this.dataFormat?t[4]:t[3];return e=Tu(e,this.poolSize[0],this.padding,this.strides[0]),n=Tu(n,this.poolSize[1],this.padding,this.strides[1]),r=Tu(r,this.poolSize[2],this.padding,this.strides[2]),"channelsFirst"===this.dataFormat?[t[0],t[1],e,n,r]:[t[0],e,n,r,t[4]]},n.prototype.call=function(t,n){var r=this;return e.tidy((function(){return r.invokeCallHook(t,n),r.poolingFunction(hs(t),r.poolSize,r.strides,r.padding,r.dataFormat)}))},n.prototype.getConfig=function(){var e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},n=t.prototype.getConfig.call(this);return Object.assign(e,n),e},n}(Ns),Ul=function(t){function e(e){return t.call(this,e)||this}return fi(e,t),e.prototype.poolingFunction=function(t,e,n,r,i){return oa(i),ua(r),_l(t,e,n,r,i,"max")},e.className="MaxPooling3D",e}(Wl);e.serialization.registerClass(Ul);var jl=function(t){function e(e){return t.call(this,e)||this}return fi(e,t),e.prototype.poolingFunction=function(t,e,n,r,i){return oa(i),ua(r),_l(t,e,n,r,i,"avg")},e.className="AveragePooling3D",e}(Wl);e.serialization.registerClass(jl);var Vl=function(t){function e(e){var n=t.call(this,e)||this;return n.inputSpec=[new vs({ndim:3})],n}return fi(e,t),e.prototype.computeOutputShape=function(t){return[t[0],t[2]]},e.prototype.call=function(t,e){throw new Ni},e}(Ns),Kl=function(t){function n(e){return t.call(this,e||{})||this}return fi(n,t),n.prototype.call=function(t,n){return e.tidy((function(){var n=hs(t);return e.mean(n,1)}))},n.className="GlobalAveragePooling1D",n}(Vl);e.serialization.registerClass(Kl);var ql=function(t){function n(e){return t.call(this,e||{})||this}return fi(n,t),n.prototype.call=function(t,n){return e.tidy((function(){var n=hs(t);return e.max(n,1)}))},n.className="GlobalMaxPooling1D",n}(Vl);e.serialization.registerClass(ql);var Gl=function(t){function e(e){var n=t.call(this,e)||this;return n.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,oa(n.dataFormat),n.inputSpec=[new vs({ndim:4})],n}return fi(e,t),e.prototype.computeOutputShape=function(t){return t=t,"channelsLast"===this.dataFormat?[t[0],t[3]]:[t[0],t[1]]},e.prototype.call=function(t,e){throw new Ni},e.prototype.getConfig=function(){var e={dataFormat:this.dataFormat},n=t.prototype.getConfig.call(this);return Object.assign(e,n),e},e}(Ns),Hl=function(t){function n(){return null!==t&&t.apply(this,arguments)||this}return fi(n,t),n.prototype.call=function(t,n){var r=this;return e.tidy((function(){var n=hs(t);return"channelsLast"===r.dataFormat?e.mean(n,[1,2]):e.mean(n,[2,3])}))},n.className="GlobalAveragePooling2D",n}(Gl);e.serialization.registerClass(Hl);var Jl=function(t){function n(){return null!==t&&t.apply(this,arguments)||this}return fi(n,t),n.prototype.call=function(t,n){var r=this;return e.tidy((function(){var n=hs(t);return"channelsLast"===r.dataFormat?e.max(n,[1,2]):e.max(n,[2,3])}))},n.className="GlobalMaxPooling2D",n}(Gl);e.serialization.registerClass(Jl);var Zl=function(t){function e(e){var n=t.call(this,e)||this;return n.layer=e.layer,n}return fi(e,t),e.prototype.build=function(t){this.built=!0},Object.defineProperty(e.prototype,"trainable",{get:function(){return null!=this.layer&&this.layer.trainable},set:function(t){null!=this.layer&&(this.layer.trainable=t)},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"trainableWeights",{get:function(){return this.layer.trainableWeights},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"nonTrainableWeights",{get:function(){return this.layer.nonTrainableWeights},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"updates",{get:function(){return this.layer._updates},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"losses",{get:function(){return this.layer.losses},enumerable:!0,configurable:!0}),e.prototype.getWeights=function(){return this.layer.getWeights()},e.prototype.setWeights=function(t){this.layer.setWeights(t)},e.prototype.getConfig=function(){var e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},n=t.prototype.getConfig.call(this);return Object.assign(e,n),e},e.prototype.setFastWeightInitDuringBuild=function(e){t.prototype.setFastWeightInitDuringBuild.call(this,e),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(e)},e.fromConfig=function(t,e,n){void 0===n&&(n={});var r=Bs(e.layer,n);delete e.layer;var i={layer:r};return Object.assign(i,e),new t(i)},e}(Ns),Yl=function(t){function n(e){var n=t.call(this,e)||this;return n.supportsMasking=!0,n}return fi(n,t),n.prototype.build=function(e){if((e=ps(e)).length<3)throw new Si("TimeDistributed layer expects an input shape >= 3D, but received input shape "+JSON.stringify(e));this.inputSpec=[{shape:e}];var n=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(n),this.layer.built=!0),t.prototype.build.call(this,e)},n.prototype.computeOutputShape=function(t){var e=[(t=ps(t))[0]].concat(t.slice(2)),n=this.layer.computeOutputShape(e),r=t[1];return[n[0],r].concat(n.slice(1))},n.prototype.call=function(t,n){var r=this;return e.tidy((function(){return qu((function(t,e){return[hs(r.layer.call(t,n)),[]]}),t=hs(t),[],!1,null,null,!1,!0)[1]}))},n.className="TimeDistributed",n}(Zl);e.serialization.registerClass(Yl);var Xl=function(t){function n(e){var n=t.call(this,e)||this,r=e.layer.getConfig(),i={};i.className=e.layer.getClassName(),i.config=r,n.forwardLayer=Bs(i),r.goBackwards=!0!==r.goBackwards;var a,s={};if(s.className=e.layer.getClassName(),s.config=r,n.backwardLayer=Bs(s),n.forwardLayer.name="forward_"+n.forwardLayer.name,n.backwardLayer.name="backward_"+n.backwardLayer.name,n.mergeMode=void 0===e.mergeMode?"concat":e.mergeMode,a=n.mergeMode,Pi(aa,"BidirectionalMergeMode",a),e.weights)throw new Ni("weights support is not implemented for Bidirectional layer yet.");return n._stateful=e.layer.stateful,n.returnSequences=e.layer.returnSequences,n.returnState=e.layer.returnState,n.supportsMasking=!0,n._trainable=!0,n.inputSpec=e.layer.inputSpec,n.numConstants=null,n}return fi(n,t),Object.defineProperty(n.prototype,"trainable",{get:function(){return this._trainable},set:function(t){this._trainable=t,null!=this.forwardLayer&&(this.forwardLayer.trainable=t),null!=this.backwardLayer&&(this.backwardLayer.trainable=t)},enumerable:!0,configurable:!0}),n.prototype.getWeights=function(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())},n.prototype.setWeights=function(t){var e=t.length,n=Math.floor(e/2);this.forwardLayer.setWeights(t.slice(0,n)),this.backwardLayer.setWeights(t.slice(n))},n.prototype.computeOutputShape=function(t){var e,n,r,i=this.forwardLayer.computeOutputShape(t);return Array.isArray(i)&&Array.isArray(i[0])||(i=[i]),i=i,this.returnState?(r=i.slice(1),e=i[0]):e=i[0],e=e,"concat"===this.mergeMode?(e[e.length-1]*=2,n=[e]):n=null==this.mergeMode?[e,e.slice()]:[e],this.returnState?null==this.mergeMode?n.concat(r).concat(r.slice()):[e].concat(r).concat(r.slice()):Ci(n)},n.prototype.apply=function(e,n){var r=null==n?null:n.initialState,i=null==n?null:n.constants;null==n&&(n={});var a=Ku(e,r,i,this.numConstants);if(e=a.inputs,r=a.initialState,i=a.constants,Array.isArray(e)&&(r=e.slice(1),e=e[0]),(null==r||0===r.length)&&null==i)return t.prototype.apply.call(this,e,n);var s=[],o=[];if(null!=r){var u=r.length;if(u%2>0)throw new Si("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");n.initialState=r,s.push.apply(s,r);var l=r.map((function(t){return new vs({shape:t.shape})}));this.forwardLayer.stateSpec=l.slice(0,u/2),this.backwardLayer.stateSpec=l.slice(u/2),o.push.apply(o,l)}if(null!=i)throw new Ni("Support for constants in Bidirectional layers is not implemented yet.");for(var c=s[0]instanceof bs,h=0,p=s;h<p.length;h++){if(p[h]instanceof bs!==c)throw new Si("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors")}if(c){var d=[e].concat(s),f=this.inputSpec.concat(o),g=this.inputSpec;this.inputSpec=f;var m=t.prototype.apply.call(this,d,n);return this.inputSpec=g,m}return t.prototype.apply.call(this,e,n)},n.prototype.call=function(t,n){var r=this;return e.tidy((function(){var i,a,s,o,u=n.initialState;if(null==u)i=r.forwardLayer.call(t,n),a=r.backwardLayer.call(t,n);else{var l=u.slice(0,u.length/2),c=u.slice(u.length/2);i=r.forwardLayer.call(t,Object.assign(n,{initialState:l})),a=r.backwardLayer.call(t,Object.assign(n,{initialState:c}))}return r.returnState&&(Array.isArray(i)&&(s=i.slice(1).concat(a.slice(1))),i=i[0],a=a[0]),r.returnSequences&&(a=e.reverse(a,1)),"concat"===r.mergeMode?o=za([i,a]):"sum"===r.mergeMode?o=e.add(i,a):"ave"===r.mergeMode?o=e.mul(.5,e.add(i,a)):"mul"===r.mergeMode?o=e.mul(i,a):null==r.mergeMode&&(o=[i,a]),r.returnState?null==r.mergeMode?o.concat(s):[o].concat(s):o}))},n.prototype.resetStates=function(t){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()},n.prototype.build=function(t){var e=this;ha(this.forwardLayer.name,(function(){e.forwardLayer.build(t)})),ha(this.backwardLayer.name,(function(){e.backwardLayer.build(t)})),this.built=!0},n.prototype.computeMask=function(t,e){var n;if(Array.isArray(e)&&(e=e[0]),n=this.returnSequences?null==this.mergeMode?[e,e]:e:null==this.mergeMode?[null,null]:null,this.returnState){var r=this.forwardLayer.states.map((function(t){return null}));return Array.isArray(n)?n.concat(r).concat(r):[n].concat(r).concat(r)}return n},Object.defineProperty(n.prototype,"trainableWeights",{get:function(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"nonTrainableWeights",{get:function(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)},enumerable:!0,configurable:!0}),n.prototype.setFastWeightInitDuringBuild=function(e){t.prototype.setFastWeightInitDuringBuild.call(this,e),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(e),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(e)},n.prototype.getConfig=function(){var e={mergeMode:this.mergeMode},n=t.prototype.getConfig.call(this);return Object.assign(e,n),e},n.fromConfig=function(t,e){var n=Bs(e.layer);if(delete e.layer,null!=e.numConstants)throw new Ni("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");var r=e;return r.layer=n,new t(r)},n.className="Bidirectional",n}(Zl);function Ql(t){return new Ml(t)}function tc(t){return new $l(t)}function ec(t){return new jl(t)}function nc(t){return new ql(t)}function rc(t){return new Jl(t)}function ic(t){return new Ol(t)}function ac(t){return new Pl(t)}e.serialization.registerClass(Xl);var sc={__proto__:null,inputLayer:function(t){return new Is(t)},elu:function(t){return new zu(t)},reLU:function(t){return new Su(t)},leakyReLU:function(t){return new Nu(t)},prelu:function(t){return new xu(t)},softmax:function(t){return new Au(t)},thresholdedReLU:function(t){return new Iu(t)},conv1d:function(t){return new Wu(t)},conv2d:function(t){return new Ou(t)},conv2dTranspose:function(t){return new Bu(t)},conv3d:function(t){return new Mu(t)},conv3dTranspose:function(t){return new Pu(t)},separableConv2d:function(t){return new $u(t)},cropping2D:function(t){return new Uu(t)},upSampling2d:function(t){return new ju(t)},depthwiseConv2d:function(t){return new Vu(t)},activation:function(t){return new cl(t)},dense:function(t){return new ul(t)},dropout:function(t){return new sl(t)},spatialDropout1d:function(t){return new ol(t)},flatten:function(t){return new ll(t)},repeatVector:function(t){return new hl(t)},reshape:function(t){return new pl(t)},permute:function(t){return new dl(t)},embedding:function(t){return new gl(t)},add:function(t){return new yl(t)},average:function(t){return new bl(t)},concatenate:function(t){return new Sl(t)},maximum:function(t){return new wl(t)},minimum:function(t){return new kl(t)},multiply:function(t){return new vl(t)},dot:function(t){return new xl(t)},batchNormalization:function(t){return new El(t)},layerNormalization:function(t){return new Fl(t)},zeroPadding2d:function(t){return new Dl(t)},averagePooling1d:Ql,avgPool1d:function(t){return Ql(t)},avgPooling1d:function(t){return Ql(t)},averagePooling2d:tc,avgPool2d:function(t){return tc(t)},avgPooling2d:function(t){return tc(t)},averagePooling3d:ec,avgPool3d:function(t){return ec(t)},avgPooling3d:function(t){return ec(t)},globalAveragePooling1d:function(t){return new Kl(t)},globalAveragePooling2d:function(t){return new Hl(t)},globalMaxPooling1d:nc,globalMaxPooling2d:rc,maxPooling1d:ic,maxPooling2d:ac,maxPooling3d:function(t){return new Ul(t)},gru:function(t){return new Xu(t)},gruCell:function(t){return new Yu(t)},lstm:function(t){return new tl(t)},lstmCell:function(t){return new Qu(t)},simpleRNN:function(t){return new Zu(t)},simpleRNNCell:function(t){return new Ju(t)},convLstm2d:function(t){return new al(t)},convLstm2dCell:function(t){return new il(t)},rnn:function(t){return new Gu(t)},stackedRNNCells:function(t){return new el(t)},bidirectional:function(t){return new Xl(t)},timeDistributed:function(t){return new Yl(t)},globalMaxPool1d:nc,globalMaxPool2d:rc,maxPool1d:ic,maxPool2d:ac,Layer:Ns,RNN:Gu,RNNCell:Hu,input:Zo,gaussianNoise:function(t){return new zl(t)},gaussianDropout:function(t){return new Il(t)},alphaDropout:function(t){return new Al(t)},masking:function(t){return new fl(t)}};var oc={__proto__:null,binaryAccuracy:function(t,e){return Js(t,e)},binaryCrossentropy:function(t,e){return to(t,e)},sparseCategoricalAccuracy:function(t,e){return eo(t,e)},categoricalAccuracy:function(t,e){return Zs(t,e)},categoricalCrossentropy:function(t,e){return no(t,e)},precision:function(t,e){return Xs(t,e)},recall:function(t,e){return Qs(t,e)},cosineProximity:function(t,e){return qs(t,e)},meanAbsoluteError:function(t,e){return Ws(t,e)},meanAbsolutePercentageError:function(t,e){return Us(t,e)},MAPE:function(t,e){return Us(t,e)},mape:function(t,e){return Us(t,e)},meanSquaredError:function(t,e){return $s(t,e)},MSE:function(t,e){return $s(t,e)},mse:function(t,e){return $s(t,e)}},uc={__proto__:null,modelFromJSON:function(t,n){return yi(this,void 0,void 0,(function(){var r,i,a,s,o,u,l,c;return vi(this,(function(h){switch(h.label){case 0:return"modelTopology"in t||(t={modelTopology:t}),null!=(r=(t=t).modelTopology).model_config&&(r=r.model_config),i=go(r),a=Bs(i,n),null==t.weightsManifest?[3,2]:[4,e.io.loadWeights(t.weightsManifest,t.pathPrefix,a.weights.map((function(t){return t.originalName})))];case 1:for(s=h.sent(),o={},u=0,l=a.weights;u<l.length;u++)c=l[u],o[c.originalName]=s[c.originalName];a.loadWeights(o),e.dispose(s),h.label=2;case 2:return[2,a]}}))}))}};var lc={__proto__:null,l1l2:function(t){return new yu(t)},l1:function(t){return gu(e=t),new yu({l1:null!=e?e.l1:null,l2:0});var e},l2:function(t){return gu(e=t),new yu({l2:null!=e?e.l2:null,l1:0});var e}},cc=function(t){function e(){var e=null!==t&&t.apply(this,arguments)||this;return e.model=null,e}return fi(e,t),e.prototype.setModel=function(t){if(!(t instanceof qo))throw new Error("model must be a LayersModel, not some other Container");this.model=t},e}(Es);function hc(t,e){return t<e}function pc(t,e){return t>e}var dc=function(t){function e(e){var n=t.call(this)||this;if(null==e&&(e={}),e.restoreBestWeights)throw new Ni("restoreBestWeights = True is not implemented in EarlyStopping yet.");return n.monitor=e.monitor||"val_loss",n.minDelta=Math.abs(e.minDelta||0),n.patience=e.patience||0,n.verbose=e.verbose||0,n.mode=e.mode||"auto",n.baseline=e.baseline,-1===["auto","min","max"].indexOf(n.mode)&&(console.warn("EarlyStopping mode '"+n.mode+"' is invalid. Falling back to mode 'auto'."),n.mode="auto"),"min"===n.mode?n.monitorFunc=hc:"max"===n.mode||-1!==n.monitor.indexOf("acc")?n.monitorFunc=pc:n.monitorFunc=hc,n.monitorFunc===hc&&(n.minDelta*=-1),n}return fi(e,t),e.prototype.onTrainBegin=function(t){return yi(this,void 0,void 0,(function(){return vi(this,(function(t){return this.wait=0,this.stoppedEpoch=0,null!=this.baseline?this.best=this.baseline:this.best=this.monitorFunc===hc?1/0:-1/0,[2]}))}))},e.prototype.onEpochEnd=function(t,e){return yi(this,void 0,void 0,(function(){var n;return vi(this,(function(r){switch(r.label){case 0:return[4,Cs(e)];case 1:return r.sent(),null==(n=this.getMonitorValue(e))?[2]:(this.monitorFunc(n-this.minDelta,this.best)?(this.best=n,this.wait=0):(this.wait++,this.wait>=this.patience&&(this.stoppedEpoch=t,this.model.stopTraining=!0)),[2])}}))}))},e.prototype.onTrainEnd=function(t){return yi(this,void 0,void 0,(function(){return vi(this,(function(t){return this.stoppedEpoch>0&&this.verbose&&console.log("Epoch "+this.stoppedEpoch+": early stopping."),[2]}))}))},e.prototype.getMonitorValue=function(t){null==t&&(t={});var e=t[this.monitor];return null==e&&console.warn("Metric for EarlyStopping "+this.monitor+" is not available. Available metrics are: "+Object.keys(t)),e},e}(cc);var fc={earlyStopping:function(t){return new dc(t)}};t.Callback=cc,t.CallbackList=Fs,t.CustomCallback=_s,t.EarlyStopping=dc,t.History=Ls,t.InputSpec=vs,t.LayerVariable=gs,t.LayersModel=qo,t.RNN=Gu,t.Sequential=Jo,t.SymbolicTensor=bs,t.callbacks=fc,t.constraints=ta,t.initializers=is,t.input=Zo,t.layers=sc,t.loadLayersModel=function(t,n){return null==n&&(n={}),function(t,n){return yi(this,void 0,void 0,(function(){var r;return vi(this,(function(i){if(null==n&&(n={}),"string"==typeof t){if(0===(r=e.io.getLoadHandlers(t,n)).length)r.push(e.io.browserHTTPRequest(t,n));else if(r.length>1)throw new Si("Found more than one ("+r.length+") load handlers for URL '"+t+"'");t=r[0]}return[2,Ho(t,void 0,n)]}))}))}(t,n)},t.metrics=oc,t.model=function(t){return new qo(t)},t.models=uc,t.registerCallbackConstructor=function(t,e){Os.registerCallbackConstructor(t,e)},t.regularizers=lc,t.sequential=function(t){return new Jo(t)},t.version_layers=yo,Object.defineProperty(t,"__esModule",{value:!0})}));
//# sourceMappingURL=tf-layers.min.js.map
